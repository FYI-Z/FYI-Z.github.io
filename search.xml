<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Redis基础知识</title>
      <link href="/2022/09/05/redis-ji-chu-zhi-shi/"/>
      <url>/2022/09/05/redis-ji-chu-zhi-shi/</url>
      
        <content type="html"><![CDATA[<div class="note success no-icon"><p>尚硅谷Redis 6笔记</p></div><h3 id="1-NoSQL-数据库"><a href="#1-NoSQL-数据库" class="headerlink" title="1. NoSQL 数据库"></a>1. NoSQL 数据库</h3><h4 id="1-1-NoSQL-数据库简介"><a href="#1-1-NoSQL-数据库简介" class="headerlink" title="1.1 NoSQL 数据库简介"></a>1.1 NoSQL 数据库简介</h4><p>NoSQL( <strong>Not Only SQL</strong> )，意即“不仅仅是SQL”，泛指<strong>非关系型的数据库</strong>（Redis、MongoDB ……）。 </p><p>NoSQL 不依赖业务逻辑方式存储，而以简单的key-value模式存储。因此大大的增加了数据库的扩展能力。</p><ul><li>不遵循SQL标准</li><li>不支持ACID</li><li>远超于SQL的性能</li></ul><h4 id="1-2-NoSQL-适用场景"><a href="#1-2-NoSQL-适用场景" class="headerlink" title="1.2 NoSQL 适用场景"></a>1.2 NoSQL 适用场景</h4><ul><li>对数据高并发的读写</li><li>海量数据的读写</li><li>对数据高扩展性的</li></ul><h4 id="1-3-NoSQL-不适用场景"><a href="#1-3-NoSQL-不适用场景" class="headerlink" title="1.3 NoSQL 不适用场景"></a>1.3 NoSQL 不适用场景</h4><ul><li>需要事务支持</li><li>基于sql的结构化查询存储，处理复杂的关系</li></ul><h3 id="2-Redis-介绍"><a href="#2-Redis-介绍" class="headerlink" title="2. Redis 介绍"></a>2. Redis 介绍</h3><p>Redis 是完全开源的，遵守 BSD 协议，是一个高性能的 key-value 数据库。</p><p>默认16个数据库，类似数组下标从0开始，默认使用0号库，使用命令select <dbid>来切换数据库。如：select 15</dbid></p><p>Redis 与其他 key - value 缓存产品有以下三个特点：</p><ul><li>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</li><li>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。</li><li>Redis支持数据的备份，即master-slave模式的数据备份。</li></ul><p>Redis是单线程 + 多路IO复用技术：</p><ul><li>Redis 内部使用文件事件处理器 file event handler，这个文件事件处理器是单线程的，所以 Redis 才叫做单线程的模型。</li><li>它采用 IO 多路复用机制同时监听多个 Socket，并把所有产生事件的socket压入一个队列中，然后有序地每次仅一个socket的方式传送给文件事件分派器，文件事件分派器接收到socket之后会根据socket产生的事件类型调用对应的事件处理器进行处理。</li></ul><img src="/2022/09/05/redis-ji-chu-zhi-shi/01.png" class=""><h3 id="3-常用五大数据类型"><a href="#3-常用五大数据类型" class="headerlink" title="3. 常用五大数据类型"></a>3. 常用五大数据类型</h3><p>String(字符串 最多长度512M)、Hash(哈希)、List(列表)、Set(集合)、ZSet(有序集合)</p><p>相关操作命令：<a href="http://www.redis.cn/commands.html">http://www.redis.cn/commands.html</a></p><h3 id="4-Redis的发布和订阅"><a href="#4-Redis的发布和订阅" class="headerlink" title="4. Redis的发布和订阅"></a>4. Redis的发布和订阅</h3><ol><li><p>客户端可以订阅频道如下图：</p><img src="/2022/09/05/redis-ji-chu-zhi-shi/02.png" class=""></li><li><p>当给这个频道发布消息后，消息就会发送给订阅的客户端</p><img src="/2022/09/05/redis-ji-chu-zhi-shi/03.png" class=""></li></ol><p><strong>注：</strong>发布的消息没有持久化，这就会导致新订阅的客户端将不会收到历史消息。（使用专业MQ）</p><h3 id="5-Redis新数据类型"><a href="#5-Redis新数据类型" class="headerlink" title="5. Redis新数据类型"></a>5. Redis新数据类型</h3><p> Bitmaps、HyperLogLog、Geospatial</p><h3 id="6-Redis与SpringBoot整合"><a href="#6-Redis与SpringBoot整合" class="headerlink" title="6. Redis与SpringBoot整合"></a>6. Redis与SpringBoot整合</h3><h4 id="1-在pom-xml文件中引入redis相关依赖"><a href="#1-在pom-xml文件中引入redis相关依赖" class="headerlink" title="1. 在pom.xml文件中引入redis相关依赖"></a>1. 在pom.xml文件中引入redis相关依赖</h4><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- redis --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-data-redis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!-- springboot2.x之后，操作redis的底层使用的Lettuce,而不是jedis --&gt;</span><span class="token comment">&lt;!-- Jedis：采用的直连，多个线程操作的话，是不安全的，如果想要避免不安全的，使用jedis pool 连接池！ --&gt;</span><span class="token comment">&lt;!-- Lettuce：采用netty,实例可以在多个线程中进行共享，不存在线程不安全的情况！可以减少线程数据了！--&gt;</span><span class="token comment">&lt;!-- spring2.X集成redis所需common-pool2--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.apache.commons<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>commons-pool2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>2.6.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span></code></pre><h4 id="2-application-yml-配置redis配置"><a href="#2-application-yml-配置redis配置" class="headerlink" title="2. application.yml 配置redis配置"></a>2. application.yml 配置redis配置</h4><pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">redis</span><span class="token punctuation">:</span>    <span class="token comment"># redis数据库索引(默认为0)，我们使用索引为3的数据库，避免和其他数据库冲突</span>    <span class="token key atrule">database</span><span class="token punctuation">:</span> <span class="token number">0</span>    <span class="token comment"># redis服务器地址（默认为loaclhost）</span>    <span class="token key atrule">host</span><span class="token punctuation">:</span> 192.168.79.150    <span class="token comment"># redis端口（默认为6379）</span>    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">6379</span>    <span class="token comment"># redis访问密码（默认为空）</span>    <span class="token key atrule">password</span><span class="token punctuation">:</span> <span class="token number">123456</span>    <span class="token comment"># redis连接超时时间（单位毫秒）</span>    <span class="token key atrule">timeout</span><span class="token punctuation">:</span> <span class="token number">0</span>    <span class="token comment"># redis连接池配置</span>    <span class="token key atrule">pool</span><span class="token punctuation">:</span>      <span class="token comment"># 最大可用连接数（默认为8，负数表示无限）</span>      <span class="token key atrule">max-active</span><span class="token punctuation">:</span> <span class="token number">8</span>      <span class="token comment"># 最大空闲连接数（默认为8，负数表示无限）</span>      <span class="token key atrule">max-idle</span><span class="token punctuation">:</span> <span class="token number">8</span>      <span class="token comment"># 最小空闲连接数（默认为0，该值只有为正数才有用）</span>      <span class="token key atrule">min-idle</span><span class="token punctuation">:</span> <span class="token number">0</span>      <span class="token comment"># 从连接池中获取连接最大等待时间（默认为-1，单位为毫秒，负数表示无限）</span>      <span class="token key atrule">max-wait</span><span class="token punctuation">:</span> <span class="token number">-1</span></code></pre><h4 id="3-添加redis配置类"><a href="#3-添加redis配置类" class="headerlink" title="3. 添加redis配置类"></a>3. 添加redis配置类</h4><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@EnableCaching</span><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedisConfig</span> <span class="token keyword">extends</span> <span class="token class-name">CachingConfigurerSupport</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> <span class="token function">redisTemplate</span><span class="token punctuation">(</span><span class="token class-name">RedisConnectionFactory</span> factory<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> template <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">RedisSerializer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> redisSerializer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringRedisSerializer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Jackson2JsonRedisSerializer</span> jackson2JsonRedisSerializer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Jackson2JsonRedisSerializer</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">ObjectMapper</span> om <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        om<span class="token punctuation">.</span><span class="token function">setVisibility</span><span class="token punctuation">(</span><span class="token class-name">PropertyAccessor</span><span class="token punctuation">.</span>ALL<span class="token punctuation">,</span> <span class="token class-name">JsonAutoDetect<span class="token punctuation">.</span>Visibility</span><span class="token punctuation">.</span>ANY<span class="token punctuation">)</span><span class="token punctuation">;</span>        om<span class="token punctuation">.</span><span class="token function">enableDefaultTyping</span><span class="token punctuation">(</span><span class="token class-name">ObjectMapper<span class="token punctuation">.</span>DefaultTyping</span><span class="token punctuation">.</span>NON_FINAL<span class="token punctuation">)</span><span class="token punctuation">;</span>        jackson2JsonRedisSerializer<span class="token punctuation">.</span><span class="token function">setObjectMapper</span><span class="token punctuation">(</span>om<span class="token punctuation">)</span><span class="token punctuation">;</span>        template<span class="token punctuation">.</span><span class="token function">setConnectionFactory</span><span class="token punctuation">(</span>factory<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//key序列化方式</span>        template<span class="token punctuation">.</span><span class="token function">setKeySerializer</span><span class="token punctuation">(</span>redisSerializer<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//value序列化</span>        template<span class="token punctuation">.</span><span class="token function">setValueSerializer</span><span class="token punctuation">(</span>jackson2JsonRedisSerializer<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//value hashmap序列化</span>        template<span class="token punctuation">.</span><span class="token function">setHashValueSerializer</span><span class="token punctuation">(</span>jackson2JsonRedisSerializer<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> template<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">CacheManager</span> <span class="token function">cacheManager</span><span class="token punctuation">(</span><span class="token class-name">RedisConnectionFactory</span> factory<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">RedisSerializer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> redisSerializer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringRedisSerializer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Jackson2JsonRedisSerializer</span> jackson2JsonRedisSerializer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Jackson2JsonRedisSerializer</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//解决查询缓存转换异常的问题</span>        <span class="token class-name">ObjectMapper</span> om <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        om<span class="token punctuation">.</span><span class="token function">setVisibility</span><span class="token punctuation">(</span><span class="token class-name">PropertyAccessor</span><span class="token punctuation">.</span>ALL<span class="token punctuation">,</span> <span class="token class-name">JsonAutoDetect<span class="token punctuation">.</span>Visibility</span><span class="token punctuation">.</span>ANY<span class="token punctuation">)</span><span class="token punctuation">;</span>        om<span class="token punctuation">.</span><span class="token function">enableDefaultTyping</span><span class="token punctuation">(</span><span class="token class-name">ObjectMapper<span class="token punctuation">.</span>DefaultTyping</span><span class="token punctuation">.</span>NON_FINAL<span class="token punctuation">)</span><span class="token punctuation">;</span>        jackson2JsonRedisSerializer<span class="token punctuation">.</span><span class="token function">setObjectMapper</span><span class="token punctuation">(</span>om<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 配置序列化（解决乱码的问题）,过期时间600秒</span>        <span class="token class-name">RedisCacheConfiguration</span> config <span class="token operator">=</span> <span class="token class-name">RedisCacheConfiguration</span><span class="token punctuation">.</span><span class="token function">defaultCacheConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">entryTtl</span><span class="token punctuation">(</span><span class="token class-name">Duration</span><span class="token punctuation">.</span><span class="token function">ofSeconds</span><span class="token punctuation">(</span><span class="token number">600</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">serializeKeysWith</span><span class="token punctuation">(</span><span class="token class-name">RedisSerializationContext<span class="token punctuation">.</span>SerializationPair</span><span class="token punctuation">.</span><span class="token function">fromSerializer</span><span class="token punctuation">(</span>redisSerializer<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">serializeValuesWith</span><span class="token punctuation">(</span><span class="token class-name">RedisSerializationContext<span class="token punctuation">.</span>SerializationPair</span><span class="token punctuation">.</span><span class="token function">fromSerializer</span><span class="token punctuation">(</span>jackson2JsonRedisSerializer<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">disableCachingNullValues</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">RedisCacheManager</span> cacheManager <span class="token operator">=</span> <span class="token class-name">RedisCacheManager</span><span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span>factory<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">cacheDefaults</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> cacheManager<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="7-Redis事务"><a href="#7-Redis事务" class="headerlink" title="7. Redis事务"></a>7. Redis事务</h3><h4 id="7-1-事务定义"><a href="#7-1-事务定义" class="headerlink" title="7.1 事务定义"></a>7.1 事务定义</h4><p>Redis事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p><p>Redis事务的主要作用就是串联多个命令防止别的命令插队。</p><h4 id="7-2-Multi、Exec、discard"><a href="#7-2-Multi、Exec、discard" class="headerlink" title="7.2 Multi、Exec、discard"></a>7.2 Multi、Exec、discard</h4><p>从输入Multi命令开始，输入的命令都会依次进入命令队列中，但不会执行，直到输入Exec后，Redis会将之前的命令队列中的命令依次执行。</p><p>组队的过程中可以通过discard来放弃组队。 </p><h4 id="7-3-事务的错误处理"><a href="#7-3-事务的错误处理" class="headerlink" title="7.3 事务的错误处理"></a>7.3 事务的错误处理</h4><ul><li><p>组队中某个命令出现了报告错误，执行时整个的所有队列都会被取消。</p></li><li><p>执行阶段某个命令报出了错误，则只有报错的命令不会被执行，而其他的命令都会执行，不会回滚。</p></li></ul><h4 id="7-4-事务冲突问题"><a href="#7-4-事务冲突问题" class="headerlink" title="7.4 事务冲突问题"></a>7.4 事务冲突问题</h4><img src="/2022/09/05/redis-ji-chu-zhi-shi/04.jpg" class=""><h5 id="7-4-1-悲观锁"><a href="#7-4-1-悲观锁" class="headerlink" title="7.4.1 悲观锁"></a>7.4.1 悲观锁</h5><p><strong>悲观锁(Pessimistic Lock)<strong>，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。</strong>传统的关系型数据库里边就用到了很多这种锁机制</strong>，比如<strong>行锁</strong>，<strong>表锁</strong>等，<strong>读锁</strong>，<strong>写锁</strong>等，都是在做操作之前先上锁。</p><img src="/2022/09/05/redis-ji-chu-zhi-shi/05.jpg" class=""><h5 id="7-4-2-乐观锁"><a href="#7-4-2-乐观锁" class="headerlink" title="7.4.2 乐观锁"></a>7.4.2 乐观锁</h5><p><strong>乐观锁(Optimistic Lock)<strong>，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。</strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量</strong>。Redis就是利用这种check-and-set机制实现事务的。</p><img src="/2022/09/05/redis-ji-chu-zhi-shi/06.jpg" class=""><h5 id="7-4-3-watch-key-key-…"><a href="#7-4-3-watch-key-key-…" class="headerlink" title="7.4.3 watch key [key …]"></a>7.4.3 watch key [key …]</h5><p>在执行multi之前，先执行watch key1 [key2],可以监视一个(或多个) key ，如果在事务<strong>执行之前这个(或这些) key被其他命令所改动，那么事务将被打断。</strong></p><h5 id="7-4-4-unwatch"><a href="#7-4-4-unwatch" class="headerlink" title="7.4.4 unwatch"></a>7.4.4 unwatch</h5><p>取消 watch命令对所有 key 的监视。</p><p>如果在执行 watch 命令之后，exec命令或discard命令先被执行了的话，那么就不需要再执行unwatch了。</p><h5 id="7-4-5-Redis事务三特性"><a href="#7-4-5-Redis事务三特性" class="headerlink" title="7.4.5 Redis事务三特性"></a>7.4.5 Redis事务三特性</h5><p>单独的隔离操作：</p><ul><li>事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断</li></ul><p>没有隔离级别的概念：</p><ul><li>队列中的命令没有提交之前都不会实际被执行，因为事务提交前任何指令都不会被实际执行</li></ul><p>不保证原子性：</p><ul><li>事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚</li></ul><h3 id="8-Redis持久化之RDB"><a href="#8-Redis持久化之RDB" class="headerlink" title="8. Redis持久化之RDB"></a>8. Redis持久化之RDB</h3><p>RDB(Redis DataBase)：</p><p>​在指定的时间间隔内将内存中的数据集快照写入磁盘， 也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里</p><h4 id="8-1-备份是如何执行的"><a href="#8-1-备份是如何执行的" class="headerlink" title="8.1 备份是如何执行的"></a>8.1 备份是如何执行的</h4><p>​Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到 一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。 整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能 如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。<strong>RDB的缺点是最后一次持久化后的数据可能丢失</strong>。</p><h4 id="8-2-Fork"><a href="#8-2-Fork" class="headerlink" title="8.2 Fork"></a>8.2 Fork</h4><ul><li>Fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等） 数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程</li><li>在Linux程序中，fork()会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，Linux中引入了“<strong>写时复制技术</strong>”</li><li><strong>一般情况父进程和子进程会共用同一段物理内存</strong>，只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。</li></ul><h4 id="8-3-dump-rdb文件"><a href="#8-3-dump-rdb文件" class="headerlink" title="8.3 dump.rdb文件"></a>8.3 dump.rdb文件</h4><p>在redis.conf中配置文件名称，默认为dump.rdb         </p><img src="/2022/09/05/redis-ji-chu-zhi-shi/07.png" class="">                     <h4 id="8-4-配置位置"><a href="#8-4-配置位置" class="headerlink" title="8.4 配置位置"></a>8.4 配置位置</h4><p>rdb文件的保存路径，也可以修改。默认为Redis启动时命令行所在的目录下</p><p>dir “/myredis/“</p> <img src="/2022/09/05/redis-ji-chu-zhi-shi/08.png" class="">         <h4 id="8-5-如何触发RDB快照；保持策略"><a href="#8-5-如何触发RDB快照；保持策略" class="headerlink" title="8.5 如何触发RDB快照；保持策略"></a>8.5 如何触发RDB快照；保持策略</h4><h5 id="8-5-1-配置文件中默认的快照配置"><a href="#8-5-1-配置文件中默认的快照配置" class="headerlink" title="8.5.1 配置文件中默认的快照配置"></a>8.5.1 配置文件中默认的快照配置</h5> <img src="/2022/09/05/redis-ji-chu-zhi-shi/09.png" class="">         <h5 id="8-5-2-命令save-VS-bgsave"><a href="#8-5-2-命令save-VS-bgsave" class="headerlink" title="8.5.2 命令save VS bgsave"></a>8.5.2 命令save VS bgsave</h5><p>save ：save时只管保存，其它不管，全部阻塞。手动保存。不建议。</p><p><strong>bgsave：Redis会在后台异步进行快照操作，快照同时还可以响应客户端请求。</strong></p><p>可以通过lastsave 命令获取最后一次成功执行快照的时间</p><h5 id="8-5-3-flushall命令"><a href="#8-5-3-flushall命令" class="headerlink" title="8.5.3  flushall命令"></a>8.5.3  flushall命令</h5><p>执行flushall命令，也会产生dump.rdb文件，但里面是空的，无意义</p><h5 id="8-5-4-Save"><a href="#8-5-4-Save" class="headerlink" title="8.5.4 Save"></a>8.5.4 Save</h5><p>格式：save 秒钟 写操作次数</p><p>RDB是整个内存的压缩过的Snapshot，RDB的数据结构，可以配置复合的快照触发条件，</p><p><strong>默认是1分钟内改了万次，或5分钟内改了10次，或15分钟内改了1次。</strong></p><p>禁用</p><p>不设置save指令，或者给save传入空字符串</p><h5 id="8-5-5-stop-writes-on-bgsave-error"><a href="#8-5-5-stop-writes-on-bgsave-error" class="headerlink" title="8.5.5 stop-writes-on-bgsave-error"></a>8.5.5 <strong>stop-writes-on-bgsave-error</strong></h5><img src="/2022/09/05/redis-ji-chu-zhi-shi/10.png" class="">      <p>当Redis无法写入磁盘的话，直接关掉Redis的写操作。推荐yes.</p><h5 id="8-5-6-rdbcompression压缩文件"><a href="#8-5-6-rdbcompression压缩文件" class="headerlink" title="8.5.6 rdbcompression压缩文件"></a>8.5.6 rdbcompression压缩文件</h5><img src="/2022/09/05/redis-ji-chu-zhi-shi/11.png" class="">     <p>对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用LZF算法进行压缩。</p><p>如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能。推荐yes.</p><h5 id="8-5-7-rdbchecksum-检查完整性"><a href="#8-5-7-rdbchecksum-检查完整性" class="headerlink" title="8.5.7 rdbchecksum 检查完整性"></a>8.5.7 rdbchecksum 检查完整性</h5><img src="/2022/09/05/redis-ji-chu-zhi-shi/12.png" class="">     <p>在存储快照后，还可以让redis使用CRC64算法来进行数据校验，</p><p>但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能</p><p>推荐yes.</p><h5 id="8-5-8-rdb的备份"><a href="#8-5-8-rdb的备份" class="headerlink" title="8.5.8 rdb的备份"></a>8.5.8 rdb的备份</h5><p>先通过config get dir 查询rdb文件的目录 </p><p>将*.rdb的文件拷贝到别的地方</p><p>rdb的恢复</p><ul><li><p>关闭Redis</p></li><li><p>先把备份的文件拷贝到工作目录下 cp dump2.rdb dump.rdb</p></li><li><p>启动Redis, 备份数据会直接加载</p></li></ul><h4 id="8-6-优势"><a href="#8-6-优势" class="headerlink" title="8.6 优势"></a>8.6 优势</h4><ul><li>适合大规模的数据恢复</li><li>对数据完整性和一致性要求不高更适合使用</li><li>节省磁盘空间</li><li>恢复速度快</li></ul> <img src="/2022/09/05/redis-ji-chu-zhi-shi/13.jpg" class="">   <h4 id="8-7劣势"><a href="#8-7劣势" class="headerlink" title="8.7劣势"></a>8.7劣势</h4><ul><li>Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑</li><li>虽然Redis在fork时使用了<strong>写时拷贝技术</strong>,但是如果数据庞大时还是比较消耗性能。</li><li>在备份周期在一定间隔时间做一次备份，所以如果Redis意外down掉的话，就会丢失最后一次快照后的所有修改。</li></ul><h4 id="8-8-如何停止"><a href="#8-8-如何停止" class="headerlink" title="8.8 如何停止"></a>8.8 如何停止</h4><p>动态停止RDB：redis-cli config set save “”#save后给空值，表示禁用保存策略</p><h4 id="8-9-小总结"><a href="#8-9-小总结" class="headerlink" title="8.9 小总结"></a>8.9 小总结</h4>  <img src="/2022/09/05/redis-ji-chu-zhi-shi/14.jpg" class="">   <h3 id="9-Redis持久化之AOF"><a href="#9-Redis持久化之AOF" class="headerlink" title="9. Redis持久化之AOF"></a>9. Redis持久化之AOF</h3><p>AOF(Append Only File)：</p><p>​以<strong>日志</strong>的形式来记录每个写操作（增量保存），将Redis执行过的所有写指令记录下来(<strong>读操作不记录</strong>)， <strong>只许追加文件但不可以改写文件</strong>，redis启动之初会读取该文件重新构建数据，换言之，redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作</p><h4 id="9-1-AOF持久化流程"><a href="#9-1-AOF持久化流程" class="headerlink" title="9.1 AOF持久化流程"></a>9.1 AOF持久化流程</h4><p>（1）客户端的请求写命令会被append追加到AOF缓冲区内；</p><p>（2）AOF缓冲区根据AOF持久化策略[always,everysec,no]将操作sync同步到磁盘的AOF文件中；</p><p>（3）AOF文件大小超过重写策略或手动重写时，会对AOF文件rewrite重写，压缩AOF文件容量；</p><p>（4）Redis服务重启时，会重新load加载AOF文件中的写操作达到数据恢复的目的；</p>  <img src="/2022/09/05/redis-ji-chu-zhi-shi/15.png" class="">   <h4 id="9-2-AOF默认不开启"><a href="#9-2-AOF默认不开启" class="headerlink" title="9.2 AOF默认不开启"></a>9.2 AOF默认不开启</h4><p>​可以在redis.conf中配置文件名称，默认为 appendonly.aof</p><p>​AOF文件的保存路径，同RDB的路径一致。</p><h4 id="9-3-AOF和RDB同时开启，redis听谁的？"><a href="#9-3-AOF和RDB同时开启，redis听谁的？" class="headerlink" title="9.3 AOF和RDB同时开启，redis听谁的？"></a>9.3 AOF和RDB同时开启，redis听谁的？</h4><p>AOF和RDB同时开启，系统默认取AOF的数据（数据不会存在丢失）</p><h4 id="9-4-AOF启动-x2F-修复-x2F-恢复"><a href="#9-4-AOF启动-x2F-修复-x2F-恢复" class="headerlink" title="9.4 AOF启动/修复/恢复"></a>9.4 AOF启动/修复/恢复</h4><p>​AOF的备份机制和性能虽然和RDB不同, 但是备份和恢复的操作同RDB一样，都是拷贝备份文件，需要恢复时再拷贝到Redis工作目录下，启动系统即加载。</p><p>​正常恢复</p><ul><li>修改默认的appendonly no，改为yes</li><li>将有数据的aof文件复制一份保存到对应目录(查看目录：config get dir)</li><li>恢复：重启redis然后重新加载</li></ul><p>​异常恢复</p><ul><li>修改默认的appendonly no，改为yes</li><li>如遇到<strong>AOF文件损坏</strong>，通过/usr/local/bin/<strong>redis-check-aof–fix appendonly.aof</strong>进行恢复</li><li>备份被写坏的AOF文件</li><li>恢复：重启redis，然后重新加载</li></ul><h4 id="9-5-AOF同步频率设置"><a href="#9-5-AOF同步频率设置" class="headerlink" title="9.5 AOF同步频率设置"></a>9.5 AOF同步频率设置</h4><p>​appendfsync always</p><p>​始终同步，每次Redis的写入都会立刻记入日志；性能较差但数据完整性比较好</p><p>​appendfsync everysec</p><p>​每秒同步，每秒记入日志一次，如果宕机，本秒的数据可能丢失。</p><p>​appendfsync no</p><p>​redis不主动进行同步，把同步时机交给操作系统。</p><h4 id="9-6-Rewrite压缩"><a href="#9-6-Rewrite压缩" class="headerlink" title="9.6 Rewrite压缩"></a>9.6 Rewrite压缩</h4><h5 id="9-6-1-是什么："><a href="#9-6-1-是什么：" class="headerlink" title="9.6.1 是什么："></a>9.6.1 是什么：</h5><p>AOF采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制, 当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩， 只保留可以恢复数据的最小指令集.可以使用命令bgrewriteaof</p><h5 id="9-6-2-重写原理，如何实现重写"><a href="#9-6-2-重写原理，如何实现重写" class="headerlink" title="9.6.2 重写原理，如何实现重写"></a>9.6.2 重写原理，如何实现重写</h5><p>AOF文件持续增长而过大时，会fork出一条新进程来将文件重写(也是先写临时文件最后再rename)，redis4.0版本后的重写，是指上就是把rdb 的快照，以二级制的形式附在新的aof头部，作为已有的历史数据，替换掉原来的流水账操作。</p><p>no-appendfsync-on-rewrite：</p><p>如果 no-appendfsync-on-rewrite=yes ,不写入aof文件只写入缓存，用户请求不会阻塞，但是在这段时间如果宕机会丢失这段时间的缓存数据。（降低数据安全性，提高性能）</p><p>   如果 no-appendfsync-on-rewrite=no, 还是会把数据往磁盘里刷，但是遇到重写操作，可能会发生阻塞。（数据安全，但是性能降低）</p><p>触发机制，何时重写</p><p>Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发</p><p>重写虽然可以节约大量磁盘空间，减少恢复时间。但是每次重写还是有一定的负担的，因此设定Redis要满足一定条件才会进行重写。 </p><p>auto-aof-rewrite-percentage：设置重写的基准值，文件达到100%时开始重写（文件是原来重写后文件的2倍时触发）</p><p>auto-aof-rewrite-min-size：设置重写的基准值，最小文件64MB。达到这个值开始重写。</p><p>例如：文件达到70MB开始重写，降到50MB，下次什么时候开始重写？100MB</p><p>系统载入时或者上次重写完毕时，Redis会记录此时AOF大小，设为base_size,</p><p>如果Redis的AOF当前大小&gt;= base_size +base_size*100% (默认)且当前大小&gt;=64mb(默认)的情况下，Redis会对AOF进行重写。 </p><h5 id="9-6-3-重写流程"><a href="#9-6-3-重写流程" class="headerlink" title="9.6.3 重写流程"></a>9.6.3 重写流程</h5><p>（1）bgrewriteaof触发重写，判断是否当前有bgsave或bgrewriteaof在运行，如果有，则等待该命令结束后再继续执行。</p><p>（2）主进程fork出子进程执行重写操作，保证主进程不会阻塞。</p><p>（3）子进程遍历redis内存中数据到临时文件，客户端的写请求同时写入aof_buf缓冲区和aof_rewrite_buf重写缓冲区保证原AOF文件完整以及新AOF文件生成期间的新的数据修改动作不会丢失。</p><p>（4）1).子进程写完新的AOF文件后，向主进程发信号，父进程更新统计信息。2).主进程把aof_rewrite_buf中的数据写入到新的AOF文件。</p><p>（5）使用新的AOF文件覆盖旧的AOF文件，完成AOF重写。</p>  <img src="/2022/09/05/redis-ji-chu-zhi-shi/16.png" class="">                      <h4 id="9-7-优势"><a href="#9-7-优势" class="headerlink" title="9.7 优势"></a>9.7 优势</h4>   <img src="/2022/09/05/redis-ji-chu-zhi-shi/17.jpg" class="">       <ul><li><p>备份机制更稳健，丢失数据概率更低。</p></li><li><p>可读的日志文本，通过操作AOF稳健，可以处理误操作。</p></li></ul><h4 id="9-8-劣势"><a href="#9-8-劣势" class="headerlink" title="9.8 劣势"></a>9.8 劣势</h4><ul><li><p>比起RDB占用更多的磁盘空间。</p></li><li><p>恢复备份速度要慢。</p></li><li><p>每次读写都同步的话，有一定的性能压力。</p></li><li><p>存在个别Bug，造成恢复不能。</p></li></ul><h4 id="9-9-小总结"><a href="#9-9-小总结" class="headerlink" title="9.9 小总结"></a>9.9 小总结</h4><p>​    <img src="/2022/09/05/redis-ji-chu-zhi-shi/18.jpg" class="">    </p><h4 id="9-10-总结-Which-one"><a href="#9-10-总结-Which-one" class="headerlink" title="9.10 总结(Which one)"></a>9.10 总结(Which one)</h4><h5 id="9-10-1-用哪个好"><a href="#9-10-1-用哪个好" class="headerlink" title="9.10.1 用哪个好"></a>9.10.1 用哪个好</h5><p>官方推荐两个都启用。</p><p>如果对数据不敏感，可以选单独用RDB。</p><p>不建议单独用 AOF，因为可能会出现Bug。</p><p>如果只是做纯内存缓存，可以都不用。</p><h5 id="9-10-2-官网建议"><a href="#9-10-2-官网建议" class="headerlink" title="9.10.2 官网建议"></a>9.10.2 官网建议</h5><ul><li><p>RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储</p></li><li><p>AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据,AOF命令以redis协议追加保存每次写的操作到文件末尾. </p></li><li><p>Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大</p></li><li><p>只做缓存：如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式.</p></li><li><p>同时开启两种持久化方式</p></li><li><p>在这种情况下,当redis重启的时候会优先载入AOF文件来恢复原始的数据, 因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整.</p></li><li><p>RDB的数据不实时，同时使用两者时服务器重启也只会找AOF文件。那要不要只使用AOF呢？ </p></li><li><p>建议不要，因为RDB更适合用于备份数据库(AOF在不断变化不好备份)， 快速重启，而且不会有AOF可能潜在的bug，留着作为一个万一的手段。</p></li><li><p>性能建议</p><pre class="language-none"><code class="language-none">因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留save 900 1这条规则。如果使用AOF，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了。代价,一是带来了持续的IO，二是AOF rewrite的最后将rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上。默认超过原大小100%大小时重写可以改到适当的数值。</code></pre></li></ul><h3 id="10-Redis主从复制"><a href="#10-Redis主从复制" class="headerlink" title="10 Redis主从复制"></a>10 Redis主从复制</h3><h4 id="10-1-是什么"><a href="#10-1-是什么" class="headerlink" title="10.1 是什么"></a>10.1 是什么</h4><p>主机数据更新后根据配置和策略， 自动同步到备机的master/slaver机制，<strong>Master以写为主，Slave以读为主</strong></p><h4 id="10-2-能干嘛"><a href="#10-2-能干嘛" class="headerlink" title="10.2 能干嘛"></a>10.2 能干嘛</h4><ul><li>读写分离，性能扩展</li><li>容灾快速恢复</li></ul><p>​     <img src="/2022/09/05/redis-ji-chu-zhi-shi/19.jpg" class="">          </p><h4 id="10-3-怎么玩：主从复制"><a href="#10-3-怎么玩：主从复制" class="headerlink" title="10.3 怎么玩：主从复制"></a>10.3 怎么玩：主从复制</h4><p>​拷贝多个redis.conf文件include(写绝对路径)</p><p>​开启daemonize yes</p><p>​Pid文件名字pidfile</p><p>​指定端口port</p><p>​Log文件名字</p><p>​dump.rdb名字dbfilename</p><p>​Appendonly 关掉或者换名字</p><h5 id="10-3-1-新建redis6379-conf，填写以下内容"><a href="#10-3-1-新建redis6379-conf，填写以下内容" class="headerlink" title="10.3.1 新建redis6379.conf，填写以下内容"></a>10.3.1 新建redis6379.conf，填写以下内容</h5><p>include /myredis/redis.conf</p><p>pidfile /var/run/redis_6379.pid</p><p>port 6379</p><p>dbfilename dump6379.rdb</p> <img src="/2022/09/05/redis-ji-chu-zhi-shi/20.jpg" class="">         <h5 id="10-3-2-新建redis6380-conf，填写以下内容"><a href="#10-3-2-新建redis6380-conf，填写以下内容" class="headerlink" title="10.3.2 新建redis6380.conf，填写以下内容"></a>10.3.2 新建redis6380.conf，填写以下内容</h5><img src="/2022/09/05/redis-ji-chu-zhi-shi/21.jpg" class="">         <h5 id="10-3-3-新建redis6381-conf，填写以下内容"><a href="#10-3-3-新建redis6381-conf，填写以下内容" class="headerlink" title="10.3.3 新建redis6381.conf，填写以下内容"></a>10.3.3 新建redis6381.conf，填写以下内容</h5><img src="/2022/09/05/redis-ji-chu-zhi-shi/22.jpg" class="">         <p>replica-priority 10</p><p>设置从机的优先级，值越小，优先级越高，用于选举主机时使用。默认100</p><h5 id="10-3-4-启动三台redis服务器"><a href="#10-3-4-启动三台redis服务器" class="headerlink" title="10.3.4 启动三台redis服务器"></a>10.3.4 启动三台redis服务器</h5> <img src="/2022/09/05/redis-ji-chu-zhi-shi/23.jpg" class="">    <h5 id="10-3-5-查看系统进程，看看三台服务器是否启动"><a href="#10-3-5-查看系统进程，看看三台服务器是否启动" class="headerlink" title="10.3.5 查看系统进程，看看三台服务器是否启动"></a>10.3.5 查看系统进程，看看三台服务器是否启动</h5>  <img src="/2022/09/05/redis-ji-chu-zhi-shi/24.jpg" class="">    <h5 id="10-3-6-查看三台主机运行情况"><a href="#10-3-6-查看三台主机运行情况" class="headerlink" title="10.3.6 查看三台主机运行情况"></a>10.3.6 查看三台主机运行情况</h5><p>info replication</p><p>打印主从复制的相关信息</p><img src="/2022/09/05/redis-ji-chu-zhi-shi/25.jpg" class="">  <h5 id="10-3-7-配从-库-不配主-库"><a href="#10-3-7-配从-库-不配主-库" class="headerlink" title="10.3.7 配从(库)不配主(库)"></a>10.3.7 配从(库)不配主(库)</h5><p>slaveof <ip><port></port></ip></p><p>成为某个实例的从服务器</p><p>1、在6380和6381上执行: slaveof 127.0.0.1 6379</p> <img src="/2022/09/05/redis-ji-chu-zhi-shi/26.jpg" class="">  <p>2、在主机上写，在从机上可以读取数据</p><p>在从机上写数据报错</p>  <img src="/2022/09/05/redis-ji-chu-zhi-shi/27.jpg" class="">  <p>3、主机挂掉，重启就行，一切如初</p><p>4、从机重启需重设：slaveof 127.0.0.1 6379</p><p>可以将配置增加到文件中。永久生效。</p>   <img src="/2022/09/05/redis-ji-chu-zhi-shi/28.jpg" class="">  <h4 id="10-4-常用3招"><a href="#10-4-常用3招" class="headerlink" title="10.4 常用3招"></a>10.4 常用3招</h4><h5 id="10-4-1-一主二仆"><a href="#10-4-1-一主二仆" class="headerlink" title="10.4.1 一主二仆"></a>10.4.1 一主二仆</h5><p>切入点问题？slave1、slave2是从头开始复制还是从切入点开始复制?比如从k4进来，那之前的k1,k2,k3是否也可以复制？</p><p>从机是否可以写？set可否？ </p><p>主机shutdown后情况如何？从机是上位还是原地待命？</p><p>主机又回来了后，主机新增记录，从机还能否顺利复制？ </p><p>其中一台从机down后情况如何？依照原有它能跟上大部队吗？</p>  <img src="/2022/09/05/redis-ji-chu-zhi-shi/29.jpg" class="">  <h5 id="10-4-2-薪火相传"><a href="#10-4-2-薪火相传" class="headerlink" title="10.4.2 薪火相传"></a>10.4.2 薪火相传</h5><p>上一个Slave可以是下一个slave的Master，Slave同样可以接收其他 slaves的连接和同步请求，那么该slave作为了链条中下一个的master, 可以有效减轻master的写压力,去中心化降低风险。</p><p>用 slaveof <ip><port></port></ip></p><p>中途变更转向:会清除之前的数据，重新建立拷贝最新的</p><p>风险是一旦某个slave宕机，后面的slave都没法备份</p><p>主机挂了，从机还是从机，无法写数据了</p>  <img src="/2022/09/05/redis-ji-chu-zhi-shi/30.jpg" class="">    <img src="/2022/09/05/redis-ji-chu-zhi-shi/31.jpg" class="">  <h5 id="10-4-3-反客为主"><a href="#10-4-3-反客为主" class="headerlink" title="10.4.3 反客为主"></a>10.4.3 反客为主</h5><p>当一个master宕机后，后面的slave可以立刻升为master，其后面的slave不用做任何修改。</p><p>用 slaveof no one  将从机变为主机。</p>   <img src="/2022/09/05/redis-ji-chu-zhi-shi/32.jpg" class="">  <h4 id="10-5-复制原理"><a href="#10-5-复制原理" class="headerlink" title="10.5 复制原理"></a>10.5 复制原理</h4><ul><li>Slave启动成功连接到master后会发送一个sync命令</li><li>Master接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令， 在后台进程执行完毕之后，master将传送整个数据文件到slave,以完成一次完全同步</li><li>全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。</li><li>增量复制：Master继续将新的所有收集到的修改命令依次传给slave,完成同步</li><li>但是只要是重新连接master,一次完全同步（全量复制)将被自动执行</li></ul><h4 id="10-6-哨兵模式-sentinel"><a href="#10-6-哨兵模式-sentinel" class="headerlink" title="10.6 哨兵模式(sentinel)"></a>10.6 哨兵模式(sentinel)</h4><h5 id="10-6-1-是什么"><a href="#10-6-1-是什么" class="headerlink" title="10.6.1 是什么"></a>10.6.1 是什么</h5><p><strong>反客为主的自动版</strong>，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库</p><p>​    <img src="/2022/09/05/redis-ji-chu-zhi-shi/33.jpg" class="">  </p><h4 id="10-6-2-怎么玩-使用步骤"><a href="#10-6-2-怎么玩-使用步骤" class="headerlink" title="10.6.2 怎么玩(使用步骤)"></a>10.6.2 怎么玩(使用步骤)</h4><h5 id="10-6-2-1-调整为一主二仆模式，6379带着6380、6381"><a href="#10-6-2-1-调整为一主二仆模式，6379带着6380、6381" class="headerlink" title="10.6.2.1 调整为一主二仆模式，6379带着6380、6381"></a>10.6.2.1 调整为一主二仆模式，6379带着6380、6381</h5> <img src="/2022/09/05/redis-ji-chu-zhi-shi/34.jpg" class="">  <h5 id="10-6-2-2-自定义的-x2F-myredis目录下新建sentinel-conf文件，名字绝不能错"><a href="#10-6-2-2-自定义的-x2F-myredis目录下新建sentinel-conf文件，名字绝不能错" class="headerlink" title="10.6.2.2 自定义的/myredis目录下新建sentinel.conf文件，名字绝不能错"></a>10.6.2.2 自定义的/myredis目录下新建sentinel.conf文件，名字绝不能错</h5><h5 id="10-6-2-3-配置哨兵-填写内容"><a href="#10-6-2-3-配置哨兵-填写内容" class="headerlink" title="10.6.2.3 配置哨兵,填写内容"></a>10.6.2.3 配置哨兵,填写内容</h5><p>sentinel monitor mymaster 127.0.0.1 6379 1</p><p>其中mymaster为监控对象起的服务器名称， 1 为至少有多少个哨兵同意迁移的数量。 </p><h5 id="10-6-2-4-启动哨兵"><a href="#10-6-2-4-启动哨兵" class="headerlink" title="10.6.2.4 启动哨兵"></a>10.6.2.4 启动哨兵</h5><p>/usr/local/bin</p><p>redis做压测可以用自带的redis-benchmark工具</p><p>执行redis-sentinel /myredis/sentinel.conf </p>  <img src="/2022/09/05/redis-ji-chu-zhi-shi/35.jpg" class="">  <h5 id="10-6-2-5-当主机挂掉，从机选举中产生新的主机"><a href="#10-6-2-5-当主机挂掉，从机选举中产生新的主机" class="headerlink" title="10.6.2.5 当主机挂掉，从机选举中产生新的主机"></a>10.6.2.5 当主机挂掉，从机选举中产生新的主机</h5><p>(大概10秒左右可以看到哨兵窗口日志，切换了新的主机)</p><p>哪个从机会被选举为主机呢？根据优先级别：slave-priority </p><p>原主机重启后会变为从机。</p>  <img src="/2022/09/05/redis-ji-chu-zhi-shi/36.jpg" class="">  <h5 id="10-6-2-6-复制延时"><a href="#10-6-2-6-复制延时" class="headerlink" title="10.6.2.6 复制延时"></a>10.6.2.6 复制延时</h5><p>由于所有的写操作都是先在Master上操作，然后同步更新到Slave上，所以从Master同步到Slave机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重。</p><h4 id="10-6-3-故障恢复"><a href="#10-6-3-故障恢复" class="headerlink" title="10.6.3 故障恢复"></a>10.6.3 故障恢复</h4> <img src="/2022/09/05/redis-ji-chu-zhi-shi/37.jpg" class="">  <p>优先级在redis.conf中默认：replica-priority 100，值越小优先级越高</p><p>偏移量是指获得原主机数据最全的</p><p>每个redis实例启动后都会随机生成一个40位的runid</p><h4 id="10-6-4-主从复制"><a href="#10-6-4-主从复制" class="headerlink" title="10.6.4 主从复制"></a>10.6.4 主从复制</h4><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">JedisSentinelPool</span> jedisSentinelPool<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span>  <span class="token class-name">Jedis</span> <span class="token function">getJedisFromSentinel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span><span class="token punctuation">(</span>jedisSentinelPool<span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> sentinelSet<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            sentinelSet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"192.168.11.103:26379"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">JedisPoolConfig</span> jedisPoolConfig <span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">JedisPoolConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            jedisPoolConfig<span class="token punctuation">.</span><span class="token function">setMaxTotal</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//最大可用连接数</span>jedisPoolConfig<span class="token punctuation">.</span><span class="token function">setMaxIdle</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//最大闲置连接数</span>jedisPoolConfig<span class="token punctuation">.</span><span class="token function">setMinIdle</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//最小闲置连接数</span>jedisPoolConfig<span class="token punctuation">.</span><span class="token function">setBlockWhenExhausted</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//连接耗尽是否等待</span>jedisPoolConfig<span class="token punctuation">.</span><span class="token function">setMaxWaitMillis</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//等待时间</span>jedisPoolConfig<span class="token punctuation">.</span><span class="token function">setTestOnBorrow</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//取连接的时候进行一下测试 ping pong</span>jedisSentinelPool<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">JedisSentinelPool</span><span class="token punctuation">(</span><span class="token string">"mymaster"</span><span class="token punctuation">,</span>sentinelSet<span class="token punctuation">,</span>jedisPoolConfig<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> jedisSentinelPool<span class="token punctuation">.</span><span class="token function">getResource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span><span class="token keyword">return</span> jedisSentinelPool<span class="token punctuation">.</span><span class="token function">getResource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="11-Redis集群"><a href="#11-Redis集群" class="headerlink" title="11. Redis集群"></a>11. Redis集群</h3><h4 id="11-1-问题"><a href="#11-1-问题" class="headerlink" title="11.1 问题"></a>11.1 问题</h4><p>容量不够，redis如何进行扩容？</p><p>并发写操作， redis如何分摊？</p><p>另外，主从模式，薪火相传模式，主机宕机，导致ip地址发生变化，应用程序中配置需要修改对应的主机地址、端口等信息。</p><p>之前通过代理主机来解决，但是redis3.0中提供了解决方案。就是无中心化集群配置。</p><h4 id="11-2-什么是集群"><a href="#11-2-什么是集群" class="headerlink" title="11.2 什么是集群"></a>11.2 什么是集群</h4><p>Redis 集群实现了对Redis的水平扩容，即启动N个redis节点，将整个数据库分布存储在这N个节点中，每个节点存储总数据的1/N。</p><p>Redis 集群通过分区（partition）来提供一定程度的可用性（availability）： 即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求。</p><h4 id="11-3-删除持久化数据"><a href="#11-3-删除持久化数据" class="headerlink" title="11.3 删除持久化数据"></a>11.3 删除持久化数据</h4><p>将rdb,aof文件都删除掉。</p><h4 id="11-4-制作6个实例，6379-6380-6381-6389-6390-6391"><a href="#11-4-制作6个实例，6379-6380-6381-6389-6390-6391" class="headerlink" title="11.4 制作6个实例，6379,6380,6381,6389,6390,6391"></a>11.4 制作6个实例，6379,6380,6381,6389,6390,6391</h4><h5 id="11-4-1-配置基本信息"><a href="#11-4-1-配置基本信息" class="headerlink" title="11.4.1 配置基本信息"></a>11.4.1 配置基本信息</h5><p>开启daemonize yes</p><p>Pid文件名字</p><p>指定端口</p><p>Log文件名字</p><p>Dump.rdb名字</p><p>Appendonly 关掉或者换名字</p><h5 id="11-4-2-redis-cluster配置修改"><a href="#11-4-2-redis-cluster配置修改" class="headerlink" title="11.4.2 redis cluster配置修改"></a>11.4.2 redis cluster配置修改</h5><p>cluster-enabled <strong>yes</strong>  打开集群模式</p><p>cluster-config-file <strong>nodes-6379.conf</strong> 设定节点配置文件名</p><p>cluster-node-timeout <strong>15000</strong>  设定节点失联时间，超过该时间（毫秒），集群自动进行主从切换。</p><pre class="language-none"><code class="language-none">include /home/bigdata/redis.confport 6379  pidfile  "/var/run/redis_6379.pid"  dbfilename "dump6379.rdb"  dir  "/home/bigdata/redis_cluster"  logfile "/home/bigdata/redis_cluster/redis_err_6379.log"  cluster-enabled yes  cluster-config-file nodes-6379.conf  cluster-node-timeout 15000  </code></pre><h5 id="11-4-3-修改好redis6379-conf文件，拷贝多个redis-conf文件"><a href="#11-4-3-修改好redis6379-conf文件，拷贝多个redis-conf文件" class="headerlink" title="11.4.3 修改好redis6379.conf文件，拷贝多个redis.conf文件"></a>11.4.3 修改好redis6379.conf文件，拷贝多个redis.conf文件</h5><img src="/2022/09/05/redis-ji-chu-zhi-shi/38.jpg" class="">  <h5 id="11-4-4-使用查找替换修改另外5个文件"><a href="#11-4-4-使用查找替换修改另外5个文件" class="headerlink" title="11.4.4 使用查找替换修改另外5个文件"></a>11.4.4 使用查找替换修改另外5个文件</h5><p>例如：:%s/6379/6380 </p><h5 id="11-4-5-启动6个redis服务"><a href="#11-4-5-启动6个redis服务" class="headerlink" title="11.4.5 启动6个redis服务"></a>11.4.5 启动6个redis服务</h5><img src="/2022/09/05/redis-ji-chu-zhi-shi/39.jpg" class=""><h4 id="11-5-将六个节点合成一个集群"><a href="#11-5-将六个节点合成一个集群" class="headerlink" title="11.5 将六个节点合成一个集群"></a>11.5 将六个节点合成一个集群</h4><p>组合之前，请确保所有redis实例启动后，nodes-xxxx.conf文件都生成正常。</p> <img src="/2022/09/05/redis-ji-chu-zhi-shi/40.jpg" class=""><ul><li>合体：</li></ul><p>cd /opt/redis-6.2.1/src</p><pre class="language-none"><code class="language-none">redis-cli --cluster  create --cluster-replicas 1 192.168.11.101:6379 192.168.11.101:6380  192.168.11.101:6381 192.168.11.101:6389 192.168.11.101:6390  192.168.11.101:6391  </code></pre><p><strong>此处不要用127.0.0.1， 请用真实IP地址</strong></p><p><strong>–replicas 1 采用最简单的方式配置集群，一台主机，一台从机，正好三组。</strong></p> <img src="/2022/09/05/redis-ji-chu-zhi-shi/41.jpg" class=""> <img src="/2022/09/05/redis-ji-chu-zhi-shi/42.jpg" class=""><ul><li>普通方式登录</li></ul><p>可能直接进入读主机，存储数据时，会出现MOVED重定向操作。所以，应该以集群方式登录。</p><img src="/2022/09/05/redis-ji-chu-zhi-shi/43.jpg" class=""><h4 id="11-6-c采用集群策略连接，设置数据会自动切换到相应的写主机"><a href="#11-6-c采用集群策略连接，设置数据会自动切换到相应的写主机" class="headerlink" title="11.6 -c采用集群策略连接，设置数据会自动切换到相应的写主机"></a>11.6 -c采用集群策略连接，设置数据会自动切换到相应的写主机</h4><img src="/2022/09/05/redis-ji-chu-zhi-shi/44.jpg" class=""><h4 id="11-7-通过-cluster-nodes-命令查看集群信息"><a href="#11-7-通过-cluster-nodes-命令查看集群信息" class="headerlink" title="11.7 通过 cluster nodes 命令查看集群信息"></a>11.7 通过 cluster nodes 命令查看集群信息</h4> <img src="/2022/09/05/redis-ji-chu-zhi-shi/45.jpg" class=""><h4 id="11-8-redis-cluster如何分配这六个节点"><a href="#11-8-redis-cluster如何分配这六个节点" class="headerlink" title="11.8 redis cluster如何分配这六个节点?"></a>11.8 redis cluster如何分配这六个节点?</h4><p>一个集群至少要有三个主节点。</p><p>选项 –cluster-replicas 1 表示我们希望为集群中的每个主节点创建一个从节点。</p><p>分配原则尽量保证每个主数据库运行在不同的IP地址，每个从库和主库不在一个IP地址上。</p><h4 id="11-9-什么是slots"><a href="#11-9-什么是slots" class="headerlink" title="11.9 什么是slots"></a>11.9 什么是slots</h4><p><strong>[OK] All nodes agree about slots configuration.</strong></p><p><strong>&gt;&gt;&gt; Check for open slots…</strong></p><p><strong>&gt;&gt;&gt; Check slots coverage…</strong></p><p><strong>[OK] All 16384 slots covered.</strong></p><p>一个 Redis 集群包含 16384 个插槽（hash slot）， 数据库中的每个键都属于这 16384 个插槽的其中一个， </p><p>集群使用公式 CRC16(key) % 16384 来计算键 key 属于哪个槽， 其中 CRC16(key) 语句用于计算键 key 的 CRC16 校验和 。</p><p>集群中的每个节点负责处理一部分插槽。 举个例子， 如果一个集群可以有主节点， 其中：</p><p>节点 A 负责处理 0 号至 5460 号插槽。</p><p>节点 B 负责处理 5461 号至 10922 号插槽。</p><p>节点 C 负责处理 10923 号至 16383 号插槽。</p><h4 id="11-10-在集群中录入值"><a href="#11-10-在集群中录入值" class="headerlink" title="11.10 在集群中录入值"></a>11.10 在集群中录入值</h4><p>在redis-cli每次录入、查询键值，redis都会计算出该key应该送往的插槽，如果不是该客户端对应服务器的插槽，redis会报错，并告知应前往的redis实例地址和端口。</p><p>redis-cli客户端提供了 –c 参数实现自动重定向。</p><p>如 redis-cli -c –p 6379 登入后，再录入、查询键值对可以自动重定向。</p><p>不在一个slot下的键值，是<strong>不能使用mget,mset等多键操作</strong>。</p><img src="/2022/09/05/redis-ji-chu-zhi-shi/46.jpg" class=""><p>可以通过{}来定义组的概念，从而使key中{}内相同内容的键值对放到一个slot中去。</p><img src="/2022/09/05/redis-ji-chu-zhi-shi/47.jpg" class=""><h4 id="11-11-查询集群中的值"><a href="#11-11-查询集群中的值" class="headerlink" title="11.11 查询集群中的值"></a>11.11 查询集群中的值</h4><p>CLUSTER GETKEYSINSLOT <slot><count> 返回 count 个 slot 槽中的键。</count></slot></p><img src="/2022/09/05/redis-ji-chu-zhi-shi/48.jpg" class=""><h4 id="11-12-故障恢复"><a href="#11-12-故障恢复" class="headerlink" title="11.12 故障恢复"></a>11.12 故障恢复</h4><p>如果主节点下线？从节点能否自动升为主节点？注意：<strong>15秒超时</strong></p><img src="/2022/09/05/redis-ji-chu-zhi-shi/49.jpg" class=""><p>主节点恢复后，主从关系会如何？主节点回来变成从机。</p> <img src="/2022/09/05/redis-ji-chu-zhi-shi/50.jpg" class=""><p>如果所有某一段插槽的主从节点都宕掉，redis服务是否还能继续?</p><p>如果某一段插槽的主从都挂掉，而cluster-require-full-coverage 为yes ，那么 ，整个集群都挂掉</p><p>如果某一段插槽的主从都挂掉，而cluster-require-full-coverage 为no ，那么，该插槽数据全都不能使用，也无法存储。</p><p>redis.conf中的参数 cluster-require-full-coverage</p><h4 id="11-13-集群的Jedis开发"><a href="#11-13-集群的Jedis开发" class="headerlink" title="11.13 集群的Jedis开发"></a>11.13 集群的Jedis开发</h4><p>即使连接的不是主机，集群会自动切换主机存储。主机写，从机读。</p><p>无中心化主从集群。无论从哪台主机写的数据，其他主机上都能读到数据。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JedisClusterTest</span> <span class="token punctuation">{</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span>  <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">HostAndPort</span><span class="token punctuation">&gt;</span></span>set <span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">HostAndPort</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HostAndPort</span><span class="token punctuation">(</span><span class="token string">"192.168.31.211"</span><span class="token punctuation">,</span><span class="token number">6379</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token class-name">JedisCluster</span> jedisCluster<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">JedisCluster</span><span class="token punctuation">(</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span>jedisCluster<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"k1"</span><span class="token punctuation">,</span> <span class="token string">"v1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token class-name">System</span><span class="token punctuation">.</span>*out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>jedisCluster<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"k1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span>  </code></pre><h4 id="11-14-Redis集群提供了以下好处"><a href="#11-14-Redis集群提供了以下好处" class="headerlink" title="11.14 Redis集群提供了以下好处"></a>11.14 Redis集群提供了以下好处</h4><p>实现扩容</p><p>分摊压力</p><p>无中心配置相对简单</p><h4 id="11-15-Redis集群的不足"><a href="#11-15-Redis集群的不足" class="headerlink" title="11.15 Redis集群的不足"></a>11.15 Redis集群的不足</h4><p>多键操作是不被支持的 </p><p>多键的Redis事务是不被支持的。lua脚本不被支持</p><p>由于集群方案出现较晚，很多公司已经采用了其他的集群方案，而代理或者客户端分片的方案想要迁移至redis cluster，需要整体迁移而不是逐步过渡，复杂度较大。</p><h3 id="12-Redis应用问题解决"><a href="#12-Redis应用问题解决" class="headerlink" title="12. Redis应用问题解决"></a>12. Redis应用问题解决</h3><h4 id="12-1-缓存穿透"><a href="#12-1-缓存穿透" class="headerlink" title="12.1 缓存穿透"></a>12.1 缓存穿透</h4><h5 id="12-1-1-问题描述"><a href="#12-1-1-问题描述" class="headerlink" title="12.1.1 问题描述"></a>12.1.1 问题描述</h5><p>​key对应的数据在数据源并不存在，每次针对此key的请求从缓存获取不到，请求都会压到数据源，从而可能压垮数据源。比如用一个不存在的用户id获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。</p><img src="/2022/09/05/redis-ji-chu-zhi-shi/51.png" class=""><h5 id="12-1-2-解决方案"><a href="#12-1-2-解决方案" class="headerlink" title="12.1.2 解决方案"></a>12.1.2 解决方案</h5><p>​一个一定不存在缓存及查询不到的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。</p><p>解决方案：</p><p>（1）  <strong>对空值缓存：</strong>如果一个查询返回的数据为空（不管是数据是否不存在），我们仍然把这个空结果（null）进行缓存，设置空结果的过期时间会很短，最长不超过五分钟</p><p>（2）  <strong>设置可访问的名单（白名单）：</strong></p><p>使用bitmaps类型定义一个可以访问的名单，名单id作为bitmaps的偏移量，每次访问和bitmap里面的id进行比较，如果访问id不在bitmaps里面，进行拦截，不允许访问。</p><p>（3）  <strong>采用布隆过滤器</strong>：(布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量(位图)和一系列随机映射函数（哈希函数）。</p><p>布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。)</p><p>将所有可能存在的数据哈希到一个足够大的bitmaps中，一个一定不存在的数据会被 这个bitmaps拦截掉，从而避免了对底层存储系统的查询压力。</p><p><strong>（4）</strong>  <strong>进行实时监控：</strong>当发现Redis的命中率开始急速降低，需要排查访问对象和访问的数据，和运维人员配合，可以设置黑名单限制服务</p><h4 id="12-2-缓存击穿"><a href="#12-2-缓存击穿" class="headerlink" title="12.2 缓存击穿"></a>12.2 缓存击穿</h4><h5 id="12-2-1-问题描述"><a href="#12-2-1-问题描述" class="headerlink" title="12.2.1 问题描述"></a>12.2.1 问题描述</h5><p>​key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</p><img src="/2022/09/05/redis-ji-chu-zhi-shi/52.png" class=""><h5 id="12-2-2-解决方案"><a href="#12-2-2-解决方案" class="headerlink" title="12.2.2 解决方案"></a>12.2.2 解决方案</h5><p>​key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题。</p><p>解决问题：</p><p><strong>（1）预先设置热门数据：</strong>在redis高峰访问之前，把一些热门数据提前存入到redis里面，加大这些热门数据key的时长</p><p><strong>（2）实时调整：</strong>现场监控哪些数据热门，实时调整key的过期时长</p><p><strong>（3）使用锁：</strong></p><p>（1）  就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db。</p><p>（2）  先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX）去set一个mutex key</p><p>（3）  当操作返回成功时，再进行load db的操作，并回设缓存,最后删除mutex key；</p><p>（4）  当操作返回失败，证明有线程在load db，当前线程睡眠一段时间再重试整个get缓存的方法。</p><img src="/2022/09/05/redis-ji-chu-zhi-shi/53.png" class=""><h4 id="12-3-缓存雪崩"><a href="#12-3-缓存雪崩" class="headerlink" title="12.3 缓存雪崩"></a>12.3 缓存雪崩</h4><h5 id="12-3-1-问题描述"><a href="#12-3-1-问题描述" class="headerlink" title="12.3.1 问题描述"></a>12.3.1 问题描述</h5><p>​key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</p><p>缓存雪崩与缓存击穿的区别在于这里针对很多key缓存，前者则是某一个key</p><p>正常访问</p> <img src="/2022/09/05/redis-ji-chu-zhi-shi/54.png" class=""><p>缓存失效瞬间</p> <img src="/2022/09/05/redis-ji-chu-zhi-shi/55.png" class=""><h5 id="12-3-2-解决方案"><a href="#12-3-2-解决方案" class="headerlink" title="12.3.2 解决方案"></a>12.3.2 解决方案</h5><p>缓存失效时的雪崩效应对底层系统的冲击非常可怕！</p><p>解决方案：</p><p><strong>（1）</strong>  <strong>构建多级缓存架构：</strong>nginx缓存 + redis缓存 +其他缓存（ehcache等）</p><p><strong>（2）使用锁或队列：</strong></p><p>用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。不适用高并发情况</p><p><strong>（3）</strong>  <strong>设置过期标志更新缓存：</strong></p><p>记录缓存数据是否过期（设置提前量），如果过期会触发通知另外的线程在后台去更新实际key的缓存。</p><p><strong>（4）</strong>  <strong>将缓存失效时间分散开：</strong></p><p>比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p><h4 id="12-4-分布式锁"><a href="#12-4-分布式锁" class="headerlink" title="12.4 分布式锁"></a>12.4 分布式锁</h4><h5 id="11-4-1-问题描述"><a href="#11-4-1-问题描述" class="headerlink" title="11.4.1 问题描述"></a>11.4.1 问题描述</h5><p>​随着业务发展的需要，原单体单机部署的系统被演化成分布式集群系统后，由于分布式系统多线程、多进程并且分布在不同机器上，这将使原单机部署情况下的并发控制锁策略失效，单纯的Java API并不能提供分布式锁的能力。为了解决这个问题就需要一种跨JVM的互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题！</p><p>分布式锁主流的实现方案：</p><ol><li><p>基于数据库实现分布式锁</p></li><li><p>基于缓存（Redis等）</p></li><li><p>基于Zookeeper</p></li></ol><p>每一种分布式锁解决方案都有各自的优缺点：</p><ol><li><p>性能：redis最高</p></li><li><p>可靠性：zookeeper最高</p></li></ol><p>这里，我们就基于redis实现分布式锁。</p><h5 id="12-4-2-解决方案：使用redis实现分布式锁"><a href="#12-4-2-解决方案：使用redis实现分布式锁" class="headerlink" title="12.4.2 解决方案：使用redis实现分布式锁"></a>12.4.2 解决方案：使用redis实现分布式锁</h5><p>redis:命令</p><p># set sku:1:info “OK” NX PX 10000</p><p>EX second ：设置键的过期时间为 second 秒。 SET key value EX second 效果等同于 SETEX key second value 。</p><p>PX millisecond ：设置键的过期时间为 millisecond 毫秒。 SET key value PX millisecond 效果等同于 PSETEX key millisecond value 。</p><p>NX ：只在键不存在时，才对键进行设置操作。 SET key value NX 效果等同于 SETNX key value 。</p><p>XX ：只在键已经存在时，才对键进行设置操作。</p><img src="/2022/09/05/redis-ji-chu-zhi-shi/56.png" class=""><ol><li><p>多个客户端同时获取锁（setnx）</p></li><li><p>获取成功，执行业务逻辑{从db获取数据，放入缓存}，执行完成释放锁（del）</p></li><li><p>其他客户端等待重试</p></li></ol><h5 id="12-4-3-编写代码"><a href="#12-4-3-编写代码" class="headerlink" title="12.4.3 编写代码"></a>12.4.3 编写代码</h5><p>Redis: set num 0</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token operator">*</span><span class="token string">"testLock"</span><span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token operator">*</span><span class="token comment">//1获取锁，setne    </span><span class="token class-name">Boolean</span>  lock <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setIfAbsent</span><span class="token punctuation">(</span><span class="token string">"lock"</span><span class="token punctuation">,</span> <span class="token string">"111"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//2获取锁成功、查询num的值   </span><span class="token keyword">if</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">{</span>               <span class="token class-name">Object</span> value <span class="token operator">=</span> redisTemplate<span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"num"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//2.1判断num为空return      </span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                     <span class="token keyword">return</span><span class="token punctuation">;</span>               <span class="token punctuation">}</span>               <span class="token comment">//2.2有值就转成成int     </span>        <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>value<span class="token operator">+</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//2.3把redis的num加1       </span>        redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"num"</span><span class="token punctuation">,</span> <span class="token operator">++</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//2.4释放锁，del       </span>    redisTemplate<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token string">"lock"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>               <span class="token comment">//3获取锁失败、每隔0.1秒再获取 </span>        <span class="token keyword">try</span><span class="token punctuation">{</span>                     <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">testLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span>  <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>               e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>        <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  </code></pre><p>重启，服务集群，通过网关压力测试：</p><p>ab -n 1000 -c 100 <a href="http://192.168.140.1:8080/test/testLock">http://192.168.140.1:8080/test/testLock</a></p> <img src="/2022/09/05/redis-ji-chu-zhi-shi/57.png" class=""><p>查看redis中num的值：</p>  <img src="/2022/09/05/redis-ji-chu-zhi-shi/58.png" class=""><p>基本实现。</p><p>问题：setnx刚好获取到锁，业务逻辑出现异常，导致锁无法释放</p><p>解决：设置过期时间，自动释放锁。</p><h5 id="12-4-4-优化之设置锁的过期时间"><a href="#12-4-4-优化之设置锁的过期时间" class="headerlink" title="12.4.4 优化之设置锁的过期时间"></a>12.4.4 优化之设置锁的过期时间</h5><p>设置过期时间有两种方式：</p><ol><li><p>首先想到通过expire设置过期时间（缺乏原子性：如果在setnx和expire之间出现异常，锁也无法释放）</p></li><li><p>在set时指定过期时间（推荐）</p><img src="/2022/09/05/redis-ji-chu-zhi-shi/59.png" class=""></li></ol><p>设置过期时间：</p><p>​    <img src="/2022/09/05/redis-ji-chu-zhi-shi/60.png" class=""></p><p>压力测试肯定也没有问题。自行测试</p><p>问题：可能会释放其他服务器的锁。</p><p>场景：如果业务逻辑的执行时间是7s。执行流程如下</p><ol><li><p>index1业务逻辑没执行完，3秒后锁被自动释放。</p></li><li><p>index2获取到锁，执行业务逻辑，3秒后锁被自动释放。</p></li><li><p>index3获取到锁，执行业务逻辑</p></li><li><p>index1业务逻辑执行完成，开始调用del释放锁，这时释放的是index3的锁，导致index3的业务只执行1s就被别人释放。</p></li></ol><p>最终等于没锁的情况。</p><p>解决：setnx获取锁时，设置一个指定的唯一值（例如：uuid）；释放前获取这个值，判断是否自己的锁</p><h5 id="12-4-5-优化之UUID防误删"><a href="#12-4-5-优化之UUID防误删" class="headerlink" title="12.4.5 优化之UUID防误删"></a>12.4.5 优化之UUID防误删</h5> <img src="/2022/09/05/redis-ji-chu-zhi-shi/61.png" class=""> <img src="/2022/09/05/redis-ji-chu-zhi-shi/62.png" class=""><p>问题：删除操作缺乏原子性。</p><p>场景：</p><ol><li><p>index1执行删除时，查询到的lock值确实和uuid相等</p><p>​uuid=v1</p><p>​set(lock,uuid)；</p></li></ol>  <img src="/2022/09/05/redis-ji-chu-zhi-shi/63.png" class=""><ol start="2"><li><p>index1执行删除前，lock刚好过期时间已到，被redis自动释放</p><p>在redis中没有了lock，没有了锁。</p></li></ol> <img src="/2022/09/05/redis-ji-chu-zhi-shi/64.png" class=""><ol start="3"><li><p>index2获取了lock</p><p>​index2线程获取到了cpu的资源，开始执行方法</p><p>​uuid=v2</p><p>​set(lock,uuid)；</p></li><li><p>index1执行删除，此时会把index2的lock删除</p><p>​index1 因为已经在方法中了，所以不需要重新上锁。index1有执行的权限。index1已经比较完成了，这个时候，开始执行</p></li></ol>  <img src="/2022/09/05/redis-ji-chu-zhi-shi/65.png" class=""><p>​删除的index2的锁！</p><h5 id="12-4-6-优化之LUA脚本保证删除的原子性"><a href="#12-4-6-优化之LUA脚本保证删除的原子性" class="headerlink" title="12.4.6 优化之LUA脚本保证删除的原子性"></a>12.4.6 优化之LUA脚本保证删除的原子性</h5><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"testLockLua"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testLockLua</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//1 声明一个uuid ,将做为一个value 放入我们的key所对应的值中</span>    <span class="token class-name">String</span> uuid <span class="token operator">=</span> UUID<span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//2 定义一个锁：lua 脚本可以使用同一把锁，来实现删除！</span>    <span class="token class-name">String</span> skuId <span class="token operator">=</span> <span class="token string">"25"</span><span class="token punctuation">;</span> <span class="token comment">// 访问skuId 为25号的商品 100008348542</span>    <span class="token class-name">String</span> locKey <span class="token operator">=</span> <span class="token string">"lock:"</span> <span class="token operator">+</span> skuId<span class="token punctuation">;</span> <span class="token comment">// 锁住的是每个商品的数据</span>    <span class="token comment">// 3 获取锁</span>    <span class="token class-name">Boolean</span> lock <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setIfAbsent</span><span class="token punctuation">(</span>locKey<span class="token punctuation">,</span> uuid<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 第一种： lock 与过期时间中间不写任何的代码。</span>    <span class="token comment">// redisTemplate.expire("lock",10, TimeUnit.SECONDS);//设置过期时间</span>    <span class="token comment">// 如果true</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 执行的业务逻辑开始</span>        <span class="token comment">// 获取缓存中的num 数据</span>        <span class="token class-name">Object</span> value <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"num"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 如果是空直接返回</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 不是空 如果说在这出现了异常！ 那么delete 就删除失败！ 也就是说锁永远存在！</span>        <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>value <span class="token operator">+</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 使num 每次+1 放入缓存</span>        redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"num"</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token operator">++</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/*使用lua脚本来锁*/</span>        <span class="token comment">// 定义lua 脚本</span>        <span class="token class-name">String</span> script <span class="token operator">=</span> <span class="token string">"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end"</span><span class="token punctuation">;</span>        <span class="token comment">// 使用redis执行lua执行</span>        <span class="token class-name">DefaultRedisScript</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">&gt;</span></span> redisScript <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultRedisScript</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        redisScript<span class="token punctuation">.</span><span class="token function">setScriptText</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 设置一下返回值类型 为Long</span>        <span class="token comment">// 因为删除判断的时候，返回的0,给其封装为数据类型。如果不封装那么默认返回String 类型，</span>        <span class="token comment">// 那么返回字符串与0 会有发生错误。</span>        redisScript<span class="token punctuation">.</span><span class="token function">setResultType</span><span class="token punctuation">(</span><span class="token class-name">Long</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 第一个要是script 脚本 ，第二个需要判断的key，第三个就是key所对应的值。</span>        redisTemplate<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>redisScript<span class="token punctuation">,</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>locKey<span class="token punctuation">)</span><span class="token punctuation">,</span> uuid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment">// 其他线程等待</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment">// 睡眠</span>            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 睡醒了之后，调用方法。</span>            <span class="token function">testLockLua</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>Lua 脚本详解：</p>   <img src="/2022/09/05/redis-ji-chu-zhi-shi/66.png" class=""><p>项目中正确使用：</p><ol><li>定义key，key应该是为每个sku定义的，也就是每个sku有一把锁。</li></ol><p>String locKey =”lock:”+skuId; // 锁住的是每个商品的数据 </p><p>Boolean lock = redisTemplate.opsForValue().setIfAbsent(locKey, uuid,3,TimeUnit.SECONDS);</p>   <img src="/2022/09/05/redis-ji-chu-zhi-shi/67.png" class=""><h5 id="12-4-7-总结"><a href="#12-4-7-总结" class="headerlink" title="12.4.7 总结"></a>12.4.7 总结</h5><p>1、加锁</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// 1. 从redis中获取锁,set k1 v1 px 20000 nx</span><span class="token class-name">String</span> uuid <span class="token operator">=</span> UUID<span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Boolean</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">.</span><span class="token function">setIfAbsent</span><span class="token punctuation">(</span><span class="token string">"lock"</span><span class="token punctuation">,</span> uuid<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>2、使用lua释放锁</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// 2. 释放锁 del</span><span class="token class-name">String</span> script <span class="token operator">=</span> <span class="token string">"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end"</span><span class="token punctuation">;</span><span class="token comment">// 设置lua脚本返回的数据类型</span><span class="token class-name">DefaultRedisScript</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">&gt;</span></span> redisScript <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultRedisScript</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 设置lua脚本返回类型为Long</span>redisScript<span class="token punctuation">.</span><span class="token function">setResultType</span><span class="token punctuation">(</span><span class="token class-name">Long</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>redisScript<span class="token punctuation">.</span><span class="token function">setScriptText</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span><span class="token punctuation">;</span>redisTemplate<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>redisScript<span class="token punctuation">,</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"lock"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>uuid<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>3、重试</p><pre class="language-none"><code class="language-none">Thread.sleep(500);testLock();</code></pre><p> 为了确保分布式锁可用，我们至少要确保锁的实现同时<strong>满足以下四个条件</strong>：</p><p>- 互斥性。在任意时刻，只有一个客户端能持有锁。</p><p>- 不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。</p><p>- 解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。</p><p>- 加锁和解锁必须具有原子性。</p><h3 id="13-Redis6-0新功能"><a href="#13-Redis6-0新功能" class="headerlink" title="13. Redis6.0新功能"></a>13. Redis6.0新功能</h3><h4 id="13-1-ACL"><a href="#13-1-ACL" class="headerlink" title="13.1 ACL"></a>13.1 ACL</h4><h5 id="13-1-1-简介"><a href="#13-1-1-简介" class="headerlink" title="13.1.1 简介"></a>13.1.1 简介</h5><p>​Redis ACL是Access Control List（访问控制列表）的缩写，该功能允许根据可以执行的命令和可以访问的键来限制某些连接。</p><p>​在Redis 5版本之前，Redis 安全规则只有密码控制 还有通过rename 来调整高危命令比如 flushdb ， KEYS* ， shutdown 等。Redis 6 则提供ACL的功能对用户进行更细粒度的权限控制 ：</p><p>（1）接入权限:用户名和密码 </p><p>（2）可以执行的命令 </p><p>（3）可以操作的 KEY</p><p>参考官网：<a href="https://redis.io/topics/acl">https://redis.io/topics/acl</a></p><h5 id="13-1-2-命令"><a href="#13-1-2-命令" class="headerlink" title="13.1.2 命令"></a>13.1.2 命令</h5><p>1、使用acl list命令展现用户权限列表</p><p>（1）数据说明</p><img src="/2022/09/05/redis-ji-chu-zhi-shi/68.png" class=""><p>2、使用acl cat命令</p><p>（1）查看添加权限指令类别</p> <img src="/2022/09/05/redis-ji-chu-zhi-shi/69.png" class=""><p>（2）加参数类型名可以查看类型下具体命令</p><img src="/2022/09/05/redis-ji-chu-zhi-shi/70.png" class=""><p>3、使用acl whoami命令查看当前用户</p><p>4、使用aclsetuser命令创建和编辑用户ACL</p><p>（1）ACL规则</p><p>下面是有效ACL规则的列表。某些规则只是用于激活或删除标志，或对用户ACL执行给定更改的单个单词。其他规则是字符前缀，它们与命令或类别名称、键模式等连接在一起。</p><table><thead><tr><th>ACL规则</th><th></th><th></th></tr></thead><tbody><tr><td>类型</td><td>参数</td><td>说明</td></tr><tr><td>启动和禁用用户</td><td><strong>on</strong></td><td>激活某用户账号</td></tr><tr><td><strong>off</strong></td><td>禁用某用户账号。注意，已验证的连接仍然可以工作。如果默认用户被标记为off，则新连接将在未进行身份验证的情况下启动，并要求用户使用AUTH选项发送AUTH或HELLO，以便以某种方式进行身份验证。</td><td></td></tr><tr><td>权限的添加删除</td><td><strong>+<command></command></strong></td><td>将指令添加到用户可以调用的指令列表中</td></tr><tr><td><strong>-<command></command></strong></td><td>从用户可执行指令列表移除指令</td><td></td></tr><tr><td><strong>+@<category></category></strong></td><td>添加该类别中用户要调用的所有指令，有效类别为@admin、@set、@sortedset…等，通过调用ACL CAT命令查看完整列表。特殊类别@all表示所有命令，包括当前存在于服务器中的命令，以及将来将通过模块加载的命令。</td><td></td></tr><tr><td>-@<actegory></actegory></td><td>从用户可调用指令中移除类别</td><td></td></tr><tr><td><strong>allcommands</strong></td><td>+@all的别名</td><td></td></tr><tr><td><strong>nocommand</strong></td><td>-@all的别名</td><td></td></tr><tr><td>可操作键的添加或删除</td><td><strong>~<pattern></pattern></strong></td><td>添加可作为用户可操作的键的模式。例如~*允许所有的键</td></tr></tbody></table><p>（2）通过命令创建新用户默认权限</p><p>acl setuser user1</p> <img src="/2022/09/05/redis-ji-chu-zhi-shi/72.png" class=""><p>在上面的示例中，我根本没有指定任何规则。如果用户不存在，这将使用just created的默认属性来创建用户。如果用户已经存在，则上面的命令将不执行任何操作。</p><p>（3）设置有用户名、密码、ACL权限、并启用的用户</p><p>acl setuser user2 on &gt;password ~cached:* +get</p> <img src="/2022/09/05/redis-ji-chu-zhi-shi/73.png" class=""><p>(4)切换用户，验证权限</p> <img src="/2022/09/05/redis-ji-chu-zhi-shi/74.png" class=""><h4 id="13-2-IO多线程"><a href="#13-2-IO多线程" class="headerlink" title="13.2 IO多线程"></a>13.2 IO多线程</h4><h5 id="13-2-1-简介"><a href="#13-2-1-简介" class="headerlink" title="13.2.1 简介"></a>13.2.1 简介</h5><p>​Redis6终于支撑多线程了，告别单线程了吗？</p><p>​IO多线程其实指<strong>客户端交互部分</strong>的<strong>网络IO</strong>交互处理模块<strong>多线程</strong>，而非<strong>执行命令多线程</strong>。Redis6执行命令依然是单线程。</p><h5 id="13-2-2-原理架构"><a href="#13-2-2-原理架构" class="headerlink" title="13.2.2 原理架构"></a>13.2.2 原理架构</h5><p>​Redis 6 加入多线程,但跟 Memcached 这种从 IO处理到数据访问多线程的实现模式有些差异。Redis 的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程。之所以这么设计是不想因为多线程而变得复杂，需要去控制 key、lua、事务，LPUSH/LPOP 等等的并发问题。整体的设计大体如下:</p> <img src="/2022/09/05/redis-ji-chu-zhi-shi/75.png" class=""><p>另外，多线程IO默认也是不开启的，需要再配置文件中配置</p><p>io-threads-do-reads yes </p><p>io-threads 4</p><h4 id="13-3-工具支持Cluster"><a href="#13-3-工具支持Cluster" class="headerlink" title="13.3 工具支持Cluster"></a>13.3 工具支持Cluster</h4><p>​之前老版Redis想要搭集群需要单独安装ruby环境，Redis 5 将 redis-trib.rb 的功能集成到 redis-cli 。另外官方 redis-benchmark 工具开始支持 cluster 模式了，通过多线程的方式对多个分片进行压测。</p>  <img src="/2022/09/05/redis-ji-chu-zhi-shi/76.png" class=""><h4 id="13-4-Redis新功能持续关注"><a href="#13-4-Redis新功能持续关注" class="headerlink" title="13.4 Redis新功能持续关注"></a>13.4 Redis新功能持续关注</h4><p>Redis6新功能还有：</p><p>1、RESP3新的 Redis 通信协议：优化服务端与客户端之间通信</p><p>2、Client side caching客户端缓存：基于 RESP3 协议实现的客户端缓存功能。为了进一步提升缓存的性能，将客户端经常访问的数据cache到客户端。减少TCP网络交互。</p><p>3、Proxy集群代理模式：Proxy 功能，让 Cluster 拥有像单实例一样的接入方式，降低大家使用cluster的门槛。不过需要注意的是代理不改变 Cluster 的功能限制，不支持的命令还是不会支持，比如跨 slot 的多Key操作。</p><p>4、Modules API</p><p>Redis 6中模块API开发进展非常大，因为Redis Labs为了开发复杂的功能，从一开始就用上Redis模块。Redis可以变成一个框架，利用Modules来构建不同系统，而不需要从头开始写然后还要BSD许可。Redis一开始就是一个向编写各种系统开放的平台。</p>]]></content>
      
      
      
        <tags>
            
            <tag> NoSQL </tag>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dialog预览URL文件</title>
      <link href="/2022/08/28/dialog-yu-lan-url-wen-jian/"/>
      <url>/2022/08/28/dialog-yu-lan-url-wen-jian/</url>
      
        <content type="html"><![CDATA[<div class="note success no-icon"><p>Android使用Dialog预览URL资源文件</p></div><h2 id="1-Dialog弹窗"><a href="#1-Dialog弹窗" class="headerlink" title="1. Dialog弹窗"></a>1. Dialog弹窗</h2><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">//R.style.ActionSheetDialogStyle为dialog效果样式</span><span class="token class-name">Dialog</span> dialog <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dialog</span><span class="token punctuation">(</span><span class="token class-name">MyUploadGwActivity</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token class-name">R</span><span class="token punctuation">.</span>style<span class="token punctuation">.</span>ActionSheetDialogStyle<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//填充对话框的布局</span><span class="token class-name">View</span> inflate <span class="token operator">=</span> <span class="token class-name">LayoutInflater</span><span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token class-name">MyUploadGwActivity</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">inflate</span><span class="token punctuation">(</span><span class="token class-name">R</span><span class="token punctuation">.</span>layout<span class="token punctuation">.</span>video_dialog<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//通过view绑定布局中的控件</span><span class="token class-name">WebView</span> webView <span class="token operator">=</span> inflate<span class="token punctuation">.</span><span class="token function">findViewById</span><span class="token punctuation">(</span><span class="token class-name">R</span><span class="token punctuation">.</span>id<span class="token punctuation">.</span>mv_webview<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//填充对话框的布局</span>dialog<span class="token punctuation">.</span><span class="token function">setContentView</span><span class="token punctuation">(</span>inflate<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取当前Activity所在的窗体</span><span class="token class-name">Window</span> dialogWindow <span class="token operator">=</span> dialog<span class="token punctuation">.</span><span class="token function">getWindow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//设置Dialog窗体弹出位置</span>dialogWindow<span class="token punctuation">.</span><span class="token function">setGravity</span><span class="token punctuation">(</span><span class="token class-name">Gravity</span><span class="token punctuation">.</span>CENTER<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获得窗体的属性</span><span class="token class-name">WindowManager<span class="token punctuation">.</span>LayoutParams</span> lp <span class="token operator">=</span> dialogWindow<span class="token punctuation">.</span><span class="token function">getAttributes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//设置dialog的宽度</span>lp<span class="token punctuation">.</span>width <span class="token operator">=</span> <span class="token class-name">WindowManager<span class="token punctuation">.</span>LayoutParams</span><span class="token punctuation">.</span>MATCH_PARENT<span class="token punctuation">;</span><span class="token comment">//获取屏幕的分辨率</span><span class="token class-name">DisplayMetrics</span> dm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DisplayMetrics</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>dialog<span class="token punctuation">.</span><span class="token function">getWindow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getWindowManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDefaultDisplay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMetrics</span><span class="token punctuation">(</span>dm<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//按屏幕高度比例设置dialog高度</span>lp<span class="token punctuation">.</span>height <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>dm<span class="token punctuation">.</span>heightPixels <span class="token operator">*</span> <span class="token number">0.7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>dialogWindow<span class="token punctuation">.</span><span class="token function">setAttributes</span><span class="token punctuation">(</span>lp<span class="token punctuation">)</span><span class="token punctuation">;</span>dialog<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//显示对话框</span></code></pre><h2 id="2-WebView显示网页内容"><a href="#2-WebView显示网页内容" class="headerlink" title="2. WebView显示网页内容"></a>2. WebView显示网页内容</h2><pre class="language-java" data-language="java"><code class="language-java"><span class="token number">1.</span>添加网络权限<span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 添加网络权限 <span class="token operator">--</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token keyword">uses</span><span class="token operator">-</span>permission android<span class="token operator">:</span>name<span class="token operator">=</span><span class="token string">"android.permission.INTERNET"</span> <span class="token operator">/</span><span class="token operator">&gt;</span>    <span class="token number">2.</span>在布局文件中添加<span class="token class-name">WebView</span>控件；<span class="token operator">&lt;</span><span class="token class-name">WebView</span>         android<span class="token operator">:</span>id<span class="token operator">=</span><span class="token string">"@+id/wv_webview"</span>         android<span class="token operator">:</span>layout_width<span class="token operator">=</span><span class="token string">"match_parent"</span>         android<span class="token operator">:</span>layout_height<span class="token operator">=</span><span class="token string">"match_parent"</span> <span class="token operator">/</span><span class="token operator">&gt;</span>             <span class="token number">3.</span>在代码中让<span class="token class-name">WebView</span>控件加载显示网页<span class="token comment">//获得控件</span><span class="token class-name">WebView</span> webView <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">WebView</span><span class="token punctuation">)</span> <span class="token function">findViewById</span><span class="token punctuation">(</span><span class="token class-name">R</span><span class="token punctuation">.</span>id<span class="token punctuation">.</span>wv_webview<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//访问网页</span>webView<span class="token punctuation">.</span><span class="token function">loadUrl</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//系统默认会通过手机浏览器打开网页，为了能够直接通过WebView显示网页，则必须设置</span>webView<span class="token punctuation">.</span><span class="token function">setWebViewClient</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">WebViewClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">shouldOverrideUrlLoading</span><span class="token punctuation">(</span><span class="token class-name">WebView</span> view<span class="token punctuation">,</span> <span class="token class-name">WebResourceRequest</span> url<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//返回true</span>       <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment">//开始加载资源监听</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onPageStarted</span><span class="token punctuation">(</span><span class="token class-name">WebView</span> view<span class="token punctuation">,</span> <span class="token class-name">String</span> url<span class="token punctuation">,</span> <span class="token class-name">Bitmap</span> favicon<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//可添加loading动画</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onPageStarted</span><span class="token punctuation">(</span>view<span class="token punctuation">,</span> url<span class="token punctuation">,</span> favicon<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//加载资源完成监听</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onPageFinished</span><span class="token punctuation">(</span><span class="token class-name">WebView</span> view<span class="token punctuation">,</span> <span class="token class-name">String</span> url<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment">//结束loading动画</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onPageFinished</span><span class="token punctuation">(</span>view<span class="token punctuation">,</span> url<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>WebView更多使用可参考：</strong><a href="https://blog.csdn.net/weixin_40438421/article/details/85700109">https://blog.csdn.net/weixin_40438421/article/details/85700109</a></p><h2 id="3-Webview设置缩放以及自适应"><a href="#3-Webview设置缩放以及自适应" class="headerlink" title="3. Webview设置缩放以及自适应"></a>3. Webview设置缩放以及自适应</h2><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">WebSettings</span> settings <span class="token operator">=</span> webView<span class="token punctuation">.</span><span class="token function">getSettings</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>settings<span class="token punctuation">.</span><span class="token function">setUseWideViewPort</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//设定支持 viewport</span>settings<span class="token punctuation">.</span><span class="token function">setLoadWithOverviewMode</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//自适应屏幕</span>settings<span class="token punctuation">.</span><span class="token function">setBuiltInZoomControls</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>settings<span class="token punctuation">.</span><span class="token function">setDisplayZoomControls</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>settings<span class="token punctuation">.</span><span class="token function">setSupportZoom</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//设定支持缩放</span></code></pre><h2 id="4-使用WPS预览office文件"><a href="#4-使用WPS预览office文件" class="headerlink" title="4. 使用WPS预览office文件"></a>4. 使用WPS预览office文件</h2><p>使用过程中发现android中的WebView不能直接预览office文档，因此采用本地软件WPS预览。</p><p><strong>简单使用：</strong></p><pre class="language-java" data-language="java"><code class="language-java">   <span class="token comment">/**     * 通过获取应用列表对比判断是否安装有某个应用     * @param context     * @param pkgName  （wps包名："cn.wps.moffice_eng"）     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">checkAppInstalled</span><span class="token punctuation">(</span><span class="token class-name">Context</span> context<span class="token punctuation">,</span> <span class="token class-name">String</span> pkgName<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pkgName<span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> pkgName<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">final</span> <span class="token class-name">PackageManager</span> packageManager <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getPackageManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">PackageInfo</span><span class="token punctuation">&gt;</span></span> info <span class="token operator">=</span> packageManager<span class="token punctuation">.</span><span class="token function">getInstalledPackages</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>info <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> info<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> info<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>pkgName<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>info<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span>packageName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token class-name">Intent</span> intent <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Intent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Bundle</span> bundle <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Bundle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>bundle<span class="token punctuation">.</span><span class="token function">putString</span><span class="token punctuation">(</span><span class="token string">"OpenMode"</span><span class="token punctuation">,</span> <span class="token string">"ReadOnly"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打开模式,只读模式</span>bundle<span class="token punctuation">.</span><span class="token function">putBoolean</span><span class="token punctuation">(</span><span class="token string">"SendCloseBroad"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 关闭时是否发送广播</span>bundle<span class="token punctuation">.</span><span class="token function">putString</span><span class="token punctuation">(</span><span class="token string">"ThirdPackage"</span><span class="token punctuation">,</span> <span class="token function">getPackageName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 第三方应用的包名，用于对改应用合法性的验证</span>bundle<span class="token punctuation">.</span><span class="token function">putBoolean</span><span class="token punctuation">(</span><span class="token string">"ClearTrace"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 清除打开记录</span>bundle<span class="token punctuation">.</span><span class="token function">putBoolean</span><span class="token punctuation">(</span><span class="token string">"ClearFile"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//关闭后删除打开文件</span>intent<span class="token punctuation">.</span><span class="token function">addFlags</span><span class="token punctuation">(</span><span class="token class-name">Intent</span><span class="token punctuation">.</span>FLAG_ACTIVITY_NEW_TASK<span class="token punctuation">)</span><span class="token punctuation">;</span>intent<span class="token punctuation">.</span><span class="token function">setAction</span><span class="token punctuation">(</span><span class="token class-name"><span class="token namespace">android<span class="token punctuation">.</span>content<span class="token punctuation">.</span></span>Intent</span><span class="token punctuation">.</span>ACTION_VIEW<span class="token punctuation">)</span><span class="token punctuation">;</span>intent<span class="token punctuation">.</span><span class="token function">setClassName</span><span class="token punctuation">(</span><span class="token string">"cn.wps.moffice_eng"</span><span class="token punctuation">,</span> <span class="token string">"cn.wps.moffice.documentmanager.PreStartActivity2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//包名和类名</span>intent<span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span><span class="token class-name">Uri</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//这里采用传入文档的在线地址进行打开，免除下载的步骤，也不需要判断安卓版本号</span>intent<span class="token punctuation">.</span><span class="token function">putExtras</span><span class="token punctuation">(</span>bundle<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token function">startActivity</span><span class="token punctuation">(</span>intent<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ActivityNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>更多使用可参考：</strong><a href="https://www.jianshu.com/p/3de8dc4df569">https://www.jianshu.com/p/3de8dc4df569</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用Git命令</title>
      <link href="/2022/08/26/chang-yong-git-ming-ling/"/>
      <url>/2022/08/26/chang-yong-git-ming-ling/</url>
      
        <content type="html"><![CDATA[<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config --global user.name <span class="token string">"用户名"</span>   <span class="token comment">#配置全局的git提交用户名</span><span class="token function">git</span> config --global user.email <span class="token string">"邮箱"</span>    <span class="token comment">#配置全局的git提交者的邮箱</span><span class="token function">git</span> clone 仓库地址<span class="token comment">#将远程仓库克隆到本地</span><span class="token function">git</span> <span class="token function">add</span> <span class="token builtin class-name">.</span><span class="token comment">#添加文件（控制所有文件）</span><span class="token function">git</span> <span class="token function">add</span> 文件名<span class="token comment">#控制单个文件</span><span class="token function">git</span> commit -m <span class="token string">'本次提交的说明'</span><span class="token comment">#提交文件</span><span class="token function">git</span> push<span class="token comment">#上传文件</span><span class="token function">git</span> branch  <span class="token comment">#查看分支</span><span class="token function">git</span> pull<span class="token comment">#合并更新</span><span class="token function">git</span> branch 分支名    <span class="token comment">#创建分支</span><span class="token function">git</span> checkout -b 分支名   <span class="token comment">#创建并切换到当前分支</span><span class="token comment">### 合并分支并提交到远程仓库</span><span class="token function">git</span> checkout master   <span class="token comment">#先切换到主分支</span><span class="token function">git</span> merge 分支名  <span class="token comment">#将分支合并到主分支</span><span class="token function">git</span> push <span class="token comment">#将本地代码推送到云端</span></code></pre><h2 id="速查表"><a href="#速查表" class="headerlink" title="速查表"></a>速查表</h2><img src="/2022/08/26/chang-yong-git-ming-ling/01.png" class="" title="Git命令速查表">]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux安装MySQL5.7</title>
      <link href="/2022/08/25/linux-an-zhuang-mysql5-7/"/>
      <url>/2022/08/25/linux-an-zhuang-mysql5-7/</url>
      
        <content type="html"><![CDATA[<h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><h3 id="查看是否已有老版本MySQL并卸载"><a href="#查看是否已有老版本MySQL并卸载" class="headerlink" title="查看是否已有老版本MySQL并卸载"></a>查看是否已有老版本MySQL并卸载</h3><pre class="language-bash" data-language="bash"><code class="language-bash">查看包名：rpm -qa<span class="token operator">|</span><span class="token function">grep</span> -i mysql删除命令：rpm -ev 文件名</code></pre><p>如果提示依赖包错误，则使用以下命令尝试：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">rpm</span> -ev 文件名 --nodeps</code></pre><p>查找之前老版本MySQL的目录并删除：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">find</span> / -name mysql <span class="token function">rm</span> -rf 目录名</code></pre><p><strong>注意：</strong>卸载后/etc/my.cnf不会删除，需要进行手工删除</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">rm</span> -rf /etc/my.cnf</code></pre><p>再次查找机器是否安装MySQL</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">rpm</span> -qa<span class="token operator">|</span><span class="token function">grep</span> -i mysql</code></pre><h3 id="安装MySQL5-7"><a href="#安装MySQL5-7" class="headerlink" title="安装MySQL5.7"></a>安装MySQL5.7</h3><p>下载地址：<a href="https://dev.mysql.com/downloads/mysql/5.7.html#downloads">https://dev.mysql.com/downloads/mysql/5.7.html#downloads</a></p><p>自己用的安装包：<a href="https://pan.baidu.com/s/1eLjtjBJ-v9CJ19U5CqzbHQ">https://pan.baidu.com/s/1eLjtjBJ-v9CJ19U5CqzbHQ</a></p><p><strong>提取码：ipel</strong></p><img src="/2022/08/25/linux-an-zhuang-mysql5-7/01.png" class=""><p>传输到Linux后解压：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">tar</span> -xvf mysql-5.7.30-linux-glibc2.12-x86_64.tar.gz</code></pre><img src="/2022/08/25/linux-an-zhuang-mysql5-7/02.png" class=""><p>移动到合适目录并重命名：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">mv</span> mysql-5.7.30-linux-glibc2.12-x86_64 /usr/local/mysql</code></pre><img src="/2022/08/25/linux-an-zhuang-mysql5-7/03.png" class=""><p>创建MySQL用户组合用户并修改权限：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">groupadd</span> mysql<span class="token function">useradd</span> -r -g mysql mysql</code></pre><p>创建数据目录并赋予权限：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> -p  /data/mysql              <span class="token comment">#创建目录</span><span class="token function">chown</span> mysql:mysql -R /data/mysql   <span class="token comment">#赋予权限</span></code></pre><img src="/2022/08/25/linux-an-zhuang-mysql5-7/04.png" class=""><p>配置my.cnf：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /etc/my.cnf</code></pre><p>内容如下：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>mysqld<span class="token punctuation">]</span>bind-address<span class="token operator">=</span><span class="token number">0.0</span>.0.0<span class="token assign-left variable">port</span><span class="token operator">=</span><span class="token number">3306</span><span class="token assign-left variable">user</span><span class="token operator">=</span>mysql<span class="token comment">#根据自己路径修改</span><span class="token assign-left variable">basedir</span><span class="token operator">=</span>/usr/local/mysql<span class="token comment">#根据自己路径修改</span><span class="token assign-left variable">datadir</span><span class="token operator">=</span>/data/mysql<span class="token assign-left variable">socket</span><span class="token operator">=</span>/tmp/mysql.socklog-error<span class="token operator">=</span>/data/mysql/mysql.errpid-file<span class="token operator">=</span>/data/mysql/mysql.pid<span class="token comment">#character config</span><span class="token assign-left variable">character_set_server</span><span class="token operator">=</span>utf8mb4symbolic-links<span class="token operator">=</span><span class="token number">0</span><span class="token assign-left variable">explicit_defaults_for_timestamp</span><span class="token operator">=</span>true</code></pre><p>初始化数据库：</p><pre class="language-bash" data-language="bash"><code class="language-bash">进入MySQL的bin目录：<span class="token builtin class-name">cd</span> /usr/local/mysql/bin/初始化：./mysqld --defaults-file<span class="token operator">=</span>/etc/my.cnf --basedir<span class="token operator">=</span>/usr/local/mysql/ --datadir<span class="token operator">=</span>/data/mysql/ --user<span class="token operator">=</span>mysql --initialize</code></pre><p>若出现：</p><p>./mysqld: error while loading shared libraries: libaio.so.1: cannot open shared object file: No such</p><p>查看密码：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> /data/mysql/mysql.err</code></pre><img src="/2022/08/25/linux-an-zhuang-mysql5-7/05.png" class=""><pre class="language-bash" data-language="bash"><code class="language-bash">先将mysql.server放置到/etc/init.d/mysql中：<span class="token function">cp</span> /usr/local/mysql/support-files/mysql.server /etc/init.d/mysql启动MySQL：<span class="token function">service</span> mysql start<span class="token function">ps</span> -ef<span class="token operator">|</span><span class="token function">grep</span> mysql</code></pre><p>如图显示，说明MySQL已经安装成功！</p><img src="/2022/08/25/linux-an-zhuang-mysql5-7/06.png" class=""><p>修改密码</p><pre class="language-bash" data-language="bash"><code class="language-bash">使用上面的随机密码登录MySQL后执行下面三步操作，重新登录SET PASSWORD <span class="token operator">=</span> PASSWORD<span class="token punctuation">(</span><span class="token string">'123456'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ALTER <span class="token environment constant">USER</span> <span class="token string">'root'</span>@<span class="token string">'localhost'</span> PASSWORD EXPIRE NEVER<span class="token punctuation">;</span>FLUSH PRIVILEGES</code></pre><img src="/2022/08/25/linux-an-zhuang-mysql5-7/07.png" class=""><p><strong>设置任意目录都能执行mysql -u root -p登录MySQL（可选）：</strong></p><p>1、进入/etc目录，编辑profile文件</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /etc<span class="token function">vi</span> profile</code></pre><p>2、在文件末尾修改PATH变量，如图：在PATH变量的加上脚本的路径（存在其他路径用冒号“:”隔开在末尾添加）</p><img src="/2022/08/25/linux-an-zhuang-mysql5-7/08.png" class=""><p>3、保存修改的profile文件，让修改立即生效，运行命令：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">source</span> /etc/profile</code></pre><p><strong>这时候仍无法使用远程连接，登录数据库执行下面三个命令</strong></p><pre class="language-bash" data-language="bash"><code class="language-bash">use mysql                                            <span class="token comment">#访问mysql库</span>update user <span class="token builtin class-name">set</span> <span class="token function">host</span> <span class="token operator">=</span> <span class="token string">'%'</span> where user <span class="token operator">=</span> <span class="token string">'root'</span><span class="token punctuation">;</span>      <span class="token comment">#使root能再任何host访问</span>FLUSH PRIVILEGES<span class="token punctuation">;</span>                                    <span class="token comment">#刷新</span></code></pre><img src="/2022/08/25/linux-an-zhuang-mysql5-7/09.png" class=""><p><strong>再次使用远程连接</strong></p><img src="/2022/08/25/linux-an-zhuang-mysql5-7/10.png" class=""><p><strong>连接成功！！！</strong></p><p><strong>MySQL5.7装好了，这是我卸载了其他版本的MySQL重装的过程，按这个流程应该能顺利安装</strong></p><p><strong>远程连接注意防火墙问题！！！</strong><a href="https://feiutech.blog.csdn.net/article/details/74502967?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-8.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-8.control">防火墙相关操作</a></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo常用命令</title>
      <link href="/2022/08/24/hexo-chang-yong-ming-ling/"/>
      <url>/2022/08/24/hexo-chang-yong-ming-ling/</url>
      
        <content type="html"><![CDATA[<h2 id="一、安装、升级"><a href="#一、安装、升级" class="headerlink" title="一、安装、升级"></a>一、安装、升级</h2><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo -g <span class="token comment">#安装  </span><span class="token function">npm</span> update hexo -g <span class="token comment">#升级  </span>hexo init <span class="token comment">#初始化</span></code></pre><h2 id="二、简写"><a href="#二、简写" class="headerlink" title="二、简写"></a>二、简写</h2><pre class="language-bash" data-language="bash"><code class="language-bash">hexo n <span class="token string">"我的博客"</span> <span class="token operator">==</span> hexo new <span class="token string">"我的博客"</span> <span class="token comment">#新建文章</span>hexo p <span class="token operator">==</span> hexo publishhexo g <span class="token operator">==</span> hexo generate<span class="token comment">#生成</span>hexo s <span class="token operator">==</span> hexo server <span class="token comment">#启动服务预览</span>hexo d <span class="token operator">==</span> hexo deploy<span class="token comment">#部署</span></code></pre><h2 id="三、服务器"><a href="#三、服务器" class="headerlink" title="三、服务器"></a>三、服务器</h2><pre class="language-bash" data-language="bash"><code class="language-bash">hexo server <span class="token comment">#Hexo 会监视文件变动并自动更新，您无须重启服务器。</span>hexo server -s <span class="token comment">#静态模式</span>hexo server -p <span class="token number">5000</span> <span class="token comment">#更改端口</span>hexo server -i <span class="token number">192.168</span>.1.1 <span class="token comment">#自定义 IP</span>hexo clean <span class="token comment">#清除缓存 网页正常情况下可以忽略此条命令</span>hexo g <span class="token comment">#生成静态网页</span>hexo d <span class="token comment">#开始部署</span></code></pre><h2 id="四、监视文件变动"><a href="#四、监视文件变动" class="headerlink" title="四、监视文件变动"></a>四、监视文件变动</h2><pre class="language-bash" data-language="bash"><code class="language-bash">hexo generate <span class="token comment">#使用 Hexo 生成静态文件快速而且简单</span>hexo generate --watch <span class="token comment">#监视文件变动</span></code></pre><h2 id="五、完成后部署"><a href="#五、完成后部署" class="headerlink" title="五、完成后部署"></a>五、完成后部署</h2><pre class="language-bash" data-language="bash"><code class="language-bash">两个命令作用相同hexo generate --deployhexo deploy --generatehexo deploy -ghexo server -g</code></pre><h2 id="六、草稿"><a href="#六、草稿" class="headerlink" title="六、草稿"></a>六、草稿</h2><pre class="language-bash" data-language="bash"><code class="language-bash">hexo publish <span class="token punctuation">[</span>layout<span class="token punctuation">]</span> <span class="token operator">&lt;</span>title<span class="token operator">&gt;</span></code></pre><h2 id="七、模板"><a href="#七、模板" class="headerlink" title="七、模板"></a>七、模板</h2><pre class="language-bash" data-language="bash"><code class="language-bash">hexo new <span class="token string">"postName"</span> <span class="token comment">#新建文章</span>hexo new page <span class="token string">"pageName"</span> <span class="token comment">#新建页面</span>hexo generate <span class="token comment">#生成静态页面至public目录</span>hexo server <span class="token comment">#开启预览访问端口（默认端口4000，'ctrl + c'关闭server）</span>hexo deploy <span class="token comment">#将.deploy目录部署到GitHub</span>hexo new <span class="token punctuation">[</span>layout<span class="token punctuation">]</span> <span class="token operator">&lt;</span>title<span class="token operator">&gt;</span>hexo new photo <span class="token string">"My Gallery"</span>hexo new <span class="token string">"Hello World"</span> --lang tw</code></pre><h2 id="八、推送到服务器上"><a href="#八、推送到服务器上" class="headerlink" title="八、推送到服务器上"></a>八、推送到服务器上</h2><pre class="language-bash" data-language="bash"><code class="language-bash">hexo n <span class="token comment">#写文章</span>hexo g <span class="token comment">#生成</span>hexo d <span class="token comment">#部署 #可与hexo g合并为 hexo d -g</span></code></pre><p>更全面详细的指令使用参考官网：<a href="https://hexo.io/zh-cn/docs/commands">指令 | Hexo</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/08/23/hello-world/"/>
      <url>/2022/08/23/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="language-bash" data-language="bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="language-bash" data-language="bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="language-bash" data-language="bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
