<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>RabbitMQ笔记</title>
      <link href="/2022/09/27/rabbitmq-bi-ji/"/>
      <url>/2022/09/27/rabbitmq-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="MQ相关概念"><a href="#MQ相关概念" class="headerlink" title="MQ相关概念"></a>MQ相关概念</h2><h3 id="什么是MQ"><a href="#什么是MQ" class="headerlink" title="什么是MQ"></a>什么是MQ</h3><p>MQ(message queue)，从字面意思上看，本质是个队列，FIFO 先入先出，只不过队列中存放的内容是message 而已，还是一种跨进程的通信机制，用于上下游传递消息。在互联网架构中，MQ 是一种非常常见的上下游“逻辑解耦+物理解耦”的消息通信服务。使用了 MQ 之后，消息发送上游只需要依赖 MQ，不用依赖其他服务。</p><h3 id="为什么要用MQ"><a href="#为什么要用MQ" class="headerlink" title="为什么要用MQ"></a>为什么要用MQ</h3><ol><li>流量削峰</li></ol><p>举个例子，如果订单系统最多能处理一万次订单，这个处理能力应付正常时段的下单时绰绰有余，正常时段我们下单一秒后就能返回结果。但是在高峰期，如果有两万次下单操作系统是处理不了的，只能限制订单超过一万后不允许用户下单。使用消息队列做缓冲，我们可以取消这个限制，把一秒内下的订单分散成一段时间来处理，这时有些用户可能在下单十几秒后才能收到下单成功的操作，但是比不能下单的体验要好。</p><ol start="2"><li>应用解耦</li></ol><p>以电商应用为例，应用中有订单系统、库存系统、物流系统、支付系统。用户创建订单后，如果耦合调用库存系统、物流系统、支付系统，任何一个子系统出了故障，都会造成下单操作异常。当转变成基于消息队列的方式后，系统间调用的问题会减少很多，比如物流系统因为发生故障，需要几分钟来修复。在这几分钟的时间里，物流系统要处理的内存被缓存在消息队列中，用户的下单操作可以正常完成。当物流系统恢复后，继续处理订单信息即可，中单用户感受不到物流系统的故障，提升系统的可用性。</p><img src="/2022/09/27/rabbitmq-bi-ji/01.png" class=""><ol start="3"><li>异步处理</li></ol><p>有些服务间调用是异步的，例如 A 调用 B，B 需要花费很长时间执行，但是 A 需要知道 B 什么时候可以执行完，以前一般有两种方式，A 过一段时间去调用 B 的查询 api 查询。或者 A 提供一个 callback api，B 执行完之后调用 api 通知 A 服务。这两种方式都不是很优雅，使用消息总线，可以很方便解决这个问题，A 调用 B 服务后，只需要监听 B 处理完成的消息，当 B 处理完成后，会发送一条消息给 MQ，MQ 会将此消息转发给 A 服务。这样 A 服务既不用循环调用 B 的查询 api，也不用提供 callback api。同样 B 服务也不用做这些操作。A 服务还能及时的得到异步处理成功的消息。</p><img src="/2022/09/27/rabbitmq-bi-ji/02.png" class=""><h3 id="MQ的分类"><a href="#MQ的分类" class="headerlink" title="MQ的分类"></a>MQ的分类</h3><ol><li>ActiveMQ</li></ol><p><strong>优点：</strong>单机吞吐量万级，时效性 ms 级，可用性高，基于主从架构实现高可用性，消息可靠性较低的概率丢失数据；</p><p><strong>缺点：</strong>官方社区现在对 ActiveMQ 5.x 维护越来越少，高吞吐量场景较少使用。</p><ol start="2"><li>Kafka</li></ol><p>大数据的杀手锏，谈到大数据领域内的消息传输，则绕不开 Kafka，这款为大数据而生的消息中间件，以其百万级 TPS 的吞吐量名声大噪，迅速成为大数据领域的宠儿，在数据采集、传输、存储的过程中发挥着举足轻重的作用。目前已经被 LinkedIn，Uber, Twitter, Netflix 等大公司所采纳。</p><p><strong>优点：</strong> 性能卓越，单机写入 TPS 约在百万条/秒，最大的优点，就是吞吐量高。时效性 ms 级可用性非常高，Kafka 是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用,消费者采用 Pull 方式获取消息, 消息有序, 通过控制能够保证所有消息被消费且仅被消费一次;有优秀的第三方Kafka Web 管理界面 Kafka-Manager；在日志领域比较成熟，被多家公司和多个开源项目使用；功能支持：功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用</p><p><strong>缺点：</strong>Kafka 单机超过 64 个队列/分区，Load 会发生明显的飙高现象，队列越多，load 越高，发送消息响应时间变长，使用短轮询方式，实时性取决于轮询间隔时间，消费失败不支持重试；支持消息顺序，但是一台代理宕机后，就会产生消息乱序，社区更新较慢；</p><ol start="3"><li>RocketMQ</li></ol><p>RocketMQ 出自阿里巴巴的开源产品，用 Java 语言实现，在设计时参考了 Kafka，并做出了自己的一些改进。被阿里巴巴广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理，binglog 分发等场景。</p><p><strong>优点：</strong>单机吞吐量十万级,可用性非常高，分布式架构,消息可以做到 0 丢失,MQ 功能较为完善，还是分布式的，扩展性好,支持10 亿级别的消息堆积，不会因为堆积导致性能下降,源码是 java 我们可以自己阅读源码，定制自己公司的 MQ</p><p> <strong>缺点：</strong>支持的客户端语言不多，目前是 java 及 c++，其中 c++不成熟；社区活跃度一般,没有在 MQ核心中去实现 JMS 等接口,有些系统要迁移需要修改大量代码</p><ol start="4"><li>RabbitMQ</li></ol><p>2007 年发布，是一个在 AMQP(高级消息队列协议)基础上完成的，可复用的企业消息系统，是当前最主流的消息中间件之一。</p><p><strong>优点：</strong>由于 erlang 语言的高并发特性，性能较好；吞吐量到万级，MQ 功能比较完备,健壮、稳定、易用、跨平台、支持多种语言 如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持 AJAX 文档齐全；开源提供的管理界面非常棒，用起来很好用,社区活跃度高；更新频率相当高</p><p><a href="https://www.rabbitmq.com/">https://www.rabbitmq.com</a></p><p><strong>缺点：</strong>商业版需要收费,学习成本较高</p><h3 id="MQ的选择"><a href="#MQ的选择" class="headerlink" title="MQ的选择"></a>MQ的选择</h3><ol><li>Kafka</li></ol><p>Kafka 主要特点是基于 Pull 的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集和传输，适合产生大量数据的互联网服务的数据收集业务。大型公司建议可以选用，如果有日志采集功能，肯定是首选 Kafka 了。</p><ol start="2"><li>RocketMQ</li></ol><p>天生为金融互联网领域而生，对于可靠性要求很高的场景，尤其是电商里面的订单扣款，以及业务削峰，在大量交易涌入时，后端可能无法及时处理的情况。RoketMQ 在稳定性上可能更值得信赖，这些业务场景在阿里双 11 已经经历了多次考验，如果你的业务有上述并发场景，建议可以选择 RocketMQ。</p><ol start="3"><li>RabbitMQ</li></ol><p>结合 erlang 语言本身的并发优势，性能好时效性微秒级，社区活跃度也比较高，管理界面用起来十分方便，如果你的数据量没有那么大，中小型公司优先选择功能比较完备的 RabbitMQ。</p><h2 id="RabbitMQ介绍"><a href="#RabbitMQ介绍" class="headerlink" title="RabbitMQ介绍"></a>RabbitMQ介绍</h2><h3 id="RabbitMQ概念"><a href="#RabbitMQ概念" class="headerlink" title="RabbitMQ概念"></a>RabbitMQ概念</h3><p>RabbitMQ 是一个消息中间件：它接受并转发消息。你可以把它当做一个快递站点，当你要发送一个包裹时，你把你的包裹放到快递站，快递员最终会把你的快递送到收件人那里，按照这种逻辑 RabbitMQ 是一个快递站，一个快递员帮你传递快件。RabbitMQ 与快递站的主要区别在于，它不处理快件而是接收，存储和转发消息数据。</p><h3 id="四大核心概念"><a href="#四大核心概念" class="headerlink" title="四大核心概念"></a>四大核心概念</h3><p><strong>生产者：</strong>产生数据发送消息的程序是生产者</p><p><strong>交换机：</strong>交换机是 RabbitMQ 非常重要的一个部件，一方面它接收来自生产者的消息，另一方面它将消息推送到队列中。交换机必须确切知道如何处理它接收到的消息，是将这些消息推送到特定队列还是推送到多个队列，亦或者是把消息丢弃，这个得有交换机类型决定</p><p><strong>队列：</strong>队列是 RabbitMQ 内部使用的一种数据结构，尽管消息流经 RabbitMQ 和应用程序，但它们只能存储在队列中。队列仅受主机的内存和磁盘限制的约束，本质上是一个大的消息缓冲区。许多生产者可以将消息发送到一个队列，许多消费者可以尝试从一个队列接收数据。这就是我们使用队列的方式</p><p><strong>消费者：</strong>消费与接收具有相似的含义。消费者大多时候是一个等待接收消息的程序。请注意生产者，消费者和消息中间件很多时候并不在同一机器上。同一个应用程序既可以是生产者又是可以是消费者。</p><h3 id="RabbitMQ-核心部分"><a href="#RabbitMQ-核心部分" class="headerlink" title="RabbitMQ 核心部分"></a>RabbitMQ 核心部分</h3><img src="/2022/09/27/rabbitmq-bi-ji/03.png" class=""><h3 id="名词介绍"><a href="#名词介绍" class="headerlink" title="名词介绍"></a>名词介绍</h3><img src="/2022/09/27/rabbitmq-bi-ji/04.png" class=""><p><strong>Broker</strong>：接收和分发消息的应用，RabbitMQ Server 就是 Message Broker</p><p><strong>Virtual</strong> <strong>host</strong>：出于多租户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似于网络中的 namespace 概念。当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出多个 vhost，每个用户在自己的 vhost 创建 exchange／queue 等</p><p><strong>Connection</strong>：publisher／consumer 和 broker 之间的 TCP 连接</p><p><strong>Channel</strong>：如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP Connection 的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，如果应用程序支持多线程，通常每个 thread 创建单独的 channel 进行通讯，AMQP method 包含了 channel id 帮助客户端和 message broker 识别 channel，所以 channel 之间是完全隔离的。Channel 作为轻量级的Connection极大减少了操作系统建立TCP connection 的开销</p><p><strong>Exchange</strong>：message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发消息到 queue 中去。常用的类型有：direct (point-to-point), topic (publish-subscribe) and fanout (multicast)</p><p><strong>Queue</strong>：消息最终被送到这里等待 consumer 取走</p><p><strong>Binding</strong>：exchange 和 queue 之间的虚拟连接，binding 中可以包含 routing key，Binding 信息被保存到 exchange 中的查询表中，用于 message 的分发依据</p><h2 id="RabbitMQ安装"><a href="#RabbitMQ安装" class="headerlink" title="RabbitMQ安装"></a>RabbitMQ安装</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><ol><li>下载RabbitMQ</li></ol><p>首先我们需要2个<code>rpm</code>安装包，分别是 RabbitMQ 安装包和 Erlang 环境安装包，后者提供环境给前者运行。</p><p><a href="https://github.com/rabbitmq/rabbitmq-server/releases">RabbitMQ最新版下载地</a></p><p>选择以<code>noarch.rpm</code>结尾的安装包</p><img src="/2022/09/27/rabbitmq-bi-ji/05.png" class=""><ol start="2"><li>下载Erlang</li></ol><p>RabbitMQ 是采用 Erlang 语言开发的，所以系统环境必须提供 Erlang 环境，需要先安装 Erlang。</p><p><code>Erlang</code> 和 <code>RabbitMQ</code> 版本对照：<a href="https://www.rabbitmq.com/which-erlang.html">点击跳转</a></p><p>这里安装的是 3.8.8 版本的 RabbitMQ，需要的 Erlang 版本依然是21.3</p><p><a href="https://packagecloud.io/rabbitmq/erlang/packages/el/7/erlang-21.3.8.16-1.el7.x86_64.rpm">Erlang 21.3下载地址</a></p><img src="/2022/09/27/rabbitmq-bi-ji/06.png" class=""><p>将下载的两个安装包传输到Linux</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol><li>安装Erlang</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">rpm</span> -ivh erlang-21.3-1.el7.x86_64.rpm<span class="token comment">#解压</span>erl -v<span class="token comment">#安装完成后输入指令查看版本号是否安装成功</span></code></pre><ol start="2"><li>安装RabbitMQ</li></ol><p>在 <code>RabiitMQ</code> 安装过程中需要依赖 <code>socat</code> 插件，首先安装该插件</p><pre class="language-bash" data-language="bash"><code class="language-bash">yum <span class="token function">install</span> socat -y<span class="token comment">#安装socat插件</span><span class="token function">rpm</span> -ivh rabbitmq-server-3.8.8-1.el7.noarch.rpm<span class="token comment">#解压</span></code></pre><p><code>i</code> 代表 install</p><p><code>vh</code> 代表显示安装进度过程</p><ol start="3"><li>启动</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 启动服务</span>systemctl start rabbitmq-server<span class="token comment"># 查看服务状态</span>systemctl status rabbitmq-server<span class="token comment"># 开机自启动</span>systemctl <span class="token builtin class-name">enable</span> rabbitmq-server<span class="token comment"># 停止服务</span>systemctl stop rabbitmq-server<span class="token comment"># 重启服务</span>systemctl restart rabbitmq-server</code></pre><h3 id="管理界面及授权操作"><a href="#管理界面及授权操作" class="headerlink" title="管理界面及授权操作"></a>管理界面及授权操作</h3><div class="note success no-icon"><p>RabbitMQ 的默认访问端口是 15672</p><p>如果 Linux 有防火墙，记得开放 15672 端口，否则 Windows 无法访问</p></div><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#开启web管理插件</span>rabbitmq-plugins <span class="token builtin class-name">enable</span> rabbitmq_management<span class="token comment">#重启服务</span>systemctl restart rabbitmq-server</code></pre><p>通过 <code>http://ip:15672</code> 访问，ip 为 Linux 的 ip。<code>rabbitmq</code> 有一个默认的账号密码 <code>guest</code>，但是登录该账号密码会出现权限问题</p><img src="/2022/09/27/rabbitmq-bi-ji/07.png" class=""><p>默认的账号密码仅限于本机 localhost 进行访问，所以需要添加一个远程登录的用户</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 创建账号和密码</span>rabbitmqctl add_user 用户名 密码<span class="token comment"># 设置用户角色</span>rabbitmqctl set_user_tags 用户名 角色<span class="token comment"># 为用户添加资源权限，添加配置、写、读权限</span><span class="token comment"># set_permissions [-p &lt;vhostpath&gt;] &lt;user&gt; &lt;conf&gt; &lt;write&gt; &lt;read&gt;</span>rabbitmqctl set_permissions -p <span class="token string">"/"</span> y <span class="token string">".*"</span> <span class="token string">".*"</span> <span class="token string">".*"</span></code></pre><p>添加用户和权限后，再次访问 <code>http://ip:15672</code> 登录，输入添加好的用户名和密码，即可进入后台</p><img src="/2022/09/27/rabbitmq-bi-ji/08.png" class=""><p>其他指令：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 修改密码</span>rabbitmqctl change_ password 用户名 新密码<span class="token comment"># 删除用户</span>rabbitmqctl delete_user 用户名<span class="token comment"># 查看用户清单</span>rabbitmqctl list_user</code></pre><h3 id="Docker安装RabbitMQ："><a href="#Docker安装RabbitMQ：" class="headerlink" title="Docker安装RabbitMQ："></a>Docker安装RabbitMQ：</h3><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 安装启动 rabbitmq 容器</span><span class="token function">docker</span> run -d --name myRabbitMQ -e <span class="token assign-left variable">RABBITMQ_DEFAULT_USER</span><span class="token operator">=</span>用户名 -e <span class="token assign-left variable">RABBITMQ_DEFAULT_PASS</span><span class="token operator">=</span>密码 -p <span class="token number">15672</span>:15672 -p <span class="token number">5672</span>:5672 rabbitmq:3.8.14-management</code></pre><h2 id="RabbitMQ入门案例"><a href="#RabbitMQ入门案例" class="headerlink" title="RabbitMQ入门案例"></a>RabbitMQ入门案例</h2><h3 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h3><p>用 Java 编写两个程序。发送单个消息的生产者和接收消息并打印出来的消费者</p><p>在下图中，“ P” 是我们的生产者，“ C” 是我们的消费者。中间的框是一个队列 RabbitMQ 代表使用者保留的消息缓冲区</p><img src="/2022/09/27/rabbitmq-bi-ji/09.png" class=""><div class="note success no-icon"><p><strong>注意</strong></p><p>Java 进行连接的时候，需要 Linux 开放 5672 端口，否则会连接超时</p><p>访问 Web 界面的端口是 15672，连接服务器的端口是 5672</p></div><p>步骤图：</p><img src="/2022/09/27/rabbitmq-bi-ji/10.png" class=""><h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><p>创建好Maven工程，pom.xml添加依赖</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!--rabbitmq 依赖客户端--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.rabbitmq<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>amqp-client<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>5.8.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!--操作文件流的一个依赖--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>commons-io<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>commons-io<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>2.6<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!--指定 jdk 编译版本--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.apache.maven.plugins<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>maven-compiler-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">&gt;</span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>source</span><span class="token punctuation">&gt;</span></span>8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>source</span><span class="token punctuation">&gt;</span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>target</span><span class="token punctuation">&gt;</span></span>8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>target</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">&gt;</span></span></code></pre><h4 id="消息生产者"><a href="#消息生产者" class="headerlink" title="消息生产者"></a>消息生产者</h4><p>创建一个类作为生产者，最终生产消息到 RabbitMQ 的队列里</p><p>步骤：</p><ol><li>创建 RabbitMQ 连接工厂</li><li>进行 RabbitMQ 工厂配置信息</li><li>创建 RabbitMQ 连接</li><li>创建 RabbitMQ 信道</li><li>生成一个队列</li><li>发送一个消息到交换机，交换机发送到队列。”” 代表默认交换机</li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Producer</span> <span class="token punctuation">{</span>    <span class="token comment">//队列名称</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> QUEUE_NAME <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>    <span class="token comment">//发消息</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token comment">//创建一个连接工厂</span>        <span class="token class-name">ConnectionFactory</span> factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConnectionFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//工厂IP 连接RabbitMQ的队列</span>        factory<span class="token punctuation">.</span><span class="token function">setHost</span><span class="token punctuation">(</span><span class="token string">"192.168.42.53"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//用户名</span>        factory<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span><span class="token string">"admin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//密码</span>        factory<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">"woniu123"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//创建连接</span>        <span class="token class-name">Connection</span> connection <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">newConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//获取信道</span>        <span class="token class-name">Channel</span> channel <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">createChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/**         * 生产一个对列         * 1.对列名称         * 2.对列里面的消息是否持久化，默认情况下，消息存储在内存中         * 3.该队列是否只供一个消费者进行消费，是否进行消息共享，true可以多个消费者消费 false：只能一个消费者消费         * 4.是否自动删除，最后一个消费者端开链接以后，该队列是否自动删除，true表示自动删除         * 5.其他参数         */</span>        channel<span class="token punctuation">.</span><span class="token function">queueDeclare</span><span class="token punctuation">(</span>QUEUE_NAME<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//发消息</span>        <span class="token class-name">String</span> message <span class="token operator">=</span> <span class="token string">"Hello World"</span><span class="token punctuation">;</span>        <span class="token comment">/**         * 发送一个消息         * 1.发送到哪个交换机         * 2.路由的key值是哪个本次是队列的名称         * 3.其他参数信息         * 4.发送消息的消息体         */</span>        channel<span class="token punctuation">.</span><span class="token function">basicPublish</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> QUEUE_NAME<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> message<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"消息发送完毕！！！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>管理界面查看结果</li></ul><img src="/2022/09/27/rabbitmq-bi-ji/11.png" class=""><h4 id="消息消费者"><a href="#消息消费者" class="headerlink" title="消息消费者"></a>消息消费者</h4><p>创建一个类作为消费者，消费 RabbitMQ 队列的消息</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Consumer</span> <span class="token punctuation">{</span>    <span class="token comment">//队列名称</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> QUEUE_NAME <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>    <span class="token comment">//接收消息</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token comment">//创建连接工厂</span>        <span class="token class-name">ConnectionFactory</span> factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConnectionFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span><span class="token function">setHost</span><span class="token punctuation">(</span><span class="token string">"192.168.42.53"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span><span class="token string">"admin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">"woniu123"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Connection</span> connection <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">newConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Channel</span> channel <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">createChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//声明接收消息</span>        <span class="token class-name">DeliverCallback</span> deliverCallback <span class="token operator">=</span> <span class="token punctuation">(</span>consumerTag<span class="token punctuation">,</span> message<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token comment">//取消消息时的回调</span>        <span class="token class-name">CancelCallback</span> cancelCallback <span class="token operator">=</span> consumerTag <span class="token operator">-&gt;</span><span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"消息消费被中断"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token comment">/**         * 消费者消费消息         * 1.消费哪个队列         * 2.消费成功之后是否要自动应答true：代表自动应答false:代表手动应答         * 3.消费者未成功消费的回调         * 4.消费者取消消费的回调         */</span>        channel<span class="token punctuation">.</span><span class="token function">basicConsume</span><span class="token punctuation">(</span>QUEUE_NAME<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> deliverCallback<span class="token punctuation">,</span> cancelCallback<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><img src="/2022/09/27/rabbitmq-bi-ji/12.png" class=""><h3 id="Work-Queues"><a href="#Work-Queues" class="headerlink" title="Work Queues"></a>Work Queues</h3><p>Work Queues 是工作队列（又称任务队列）的主要思想是避免立即执行资源密集型任务，而不得不等待它完成。相反我们安排任务在之后执行。我们把任务封装为消息并将其发送到队列。在后台运行的工作进程将弹出任务并最终执行作业。当有多个工作线程时，这些工作线程将一起处理这些任务。</p><h4 id="轮询消费"><a href="#轮询消费" class="headerlink" title="轮询消费"></a>轮询消费</h4><p>案例中生产者叫做 Task，一个消费者就是一个工作队列，启动两个工作队列消费消息，这个两个工作队列会以轮询的方式消费消息。</p><img src="/2022/09/27/rabbitmq-bi-ji/13.png" class=""><ul><li>首先把 RabbitMQ 的配置参数封装为一个工具类：<code>RabbitMQUtils</code></li></ul><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RabbitMQUtils</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Channel</span> <span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">TimeoutException</span> <span class="token punctuation">{</span>        <span class="token comment">//创建一个连接工厂</span>        <span class="token class-name">ConnectionFactory</span> factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConnectionFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//工厂IP 连接RabbitMQ对列</span>        factory<span class="token punctuation">.</span><span class="token function">setHost</span><span class="token punctuation">(</span><span class="token string">"192.168.42.53"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//用户名</span>        factory<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span><span class="token string">"admin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//密码</span>        factory<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">"woniu123"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//创建连接</span>        <span class="token class-name">Connection</span> connection <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">newConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//获取信道</span>        <span class="token class-name">Channel</span> channel <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">createChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> channel<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>创建两个工作队列，并启动</li></ul><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Work01</span> <span class="token punctuation">{</span>    <span class="token comment">//队列的名称</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> QUEUE_NAME <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>    <span class="token comment">//接收消息</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token class-name">Channel</span> channel <span class="token operator">=</span> <span class="token class-name">RabbitMQUtils</span><span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//消息的接受</span>        <span class="token class-name">DeliverCallback</span> deliverCallback <span class="token operator">=</span> <span class="token punctuation">(</span>consumerTag<span class="token punctuation">,</span> message<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"接收到的消息:"</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token comment">//消息接受被取消时，执行下面的内容</span>        <span class="token class-name">CancelCallback</span> cancelCallback <span class="token operator">=</span> consumerTag <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>consumerTag <span class="token operator">+</span> <span class="token string">"消息被消费者取消消费接口回调逻辑"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>         <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"C2等待接收消息"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//消息的接受</span>        channel<span class="token punctuation">.</span><span class="token function">basicConsume</span><span class="token punctuation">(</span>QUEUE_NAME<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> deliverCallback<span class="token punctuation">,</span> cancelCallback<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>创建好一个工作队列，只需要以多线程方式启动两次该 main 函数即可，以 first、second 区别消息队列。</p><p>要开启多线程功能，首先启动该消息队列，然后如图开启多线程：</p><img src="/2022/09/27/rabbitmq-bi-ji/14.png" class=""><p>启动两个队列，通过<code>System.out.println("C2等待接收消息");</code>输出信息标识</p><img src="/2022/09/27/rabbitmq-bi-ji/15.png" class=""><ul><li>创建一个生产者，发送消息进程</li></ul><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Task01</span> <span class="token punctuation">{</span>    <span class="token comment">//队列名称</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> QUEUE_NAME <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>    <span class="token comment">//发送大量消息</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token class-name">Channel</span> channel <span class="token operator">=</span> <span class="token class-name">RabbitMQUtils</span><span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//队列的声明</span>        channel<span class="token punctuation">.</span><span class="token function">queueDeclare</span><span class="token punctuation">(</span>QUEUE_NAME<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//发送消息</span>        <span class="token comment">//从控制台当中接受信息</span>        <span class="token class-name">Scanner</span> scanner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>scanner<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">String</span> message <span class="token operator">=</span> scanner<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            channel<span class="token punctuation">.</span><span class="token function">basicPublish</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> QUEUE_NAME<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> message<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"消息发送完成:"</span> <span class="token operator">+</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>结构演示</li></ul><img src="/2022/09/27/rabbitmq-bi-ji/16.png" class=""><h4 id="Web管理页面添加队列"><a href="#Web管理页面添加队列" class="headerlink" title="Web管理页面添加队列"></a>Web管理页面添加队列</h4><img src="/2022/09/27/rabbitmq-bi-ji/17.png" class=""><h2 id="RabbitMQ消息应答与发布"><a href="#RabbitMQ消息应答与发布" class="headerlink" title="RabbitMQ消息应答与发布"></a>RabbitMQ消息应答与发布</h2><h3 id="消息应答"><a href="#消息应答" class="headerlink" title="消息应答"></a>消息应答</h3><p>消费者完成一个任务可能需要一段时间，如果其中一个消费者处理一个长的任务并仅只完成了部分突然它挂掉了，会发生什么情况。RabbitMQ 一旦向消费者传递了一条消息，便立即将该消息标记为删除。在这种情况下，突然有个消费者挂掉了，我们将丢失正在处理的消息。以及后续发送给该消费这的消息，因为它无法接收到。</p><p>为了保证消息在发送过程中不丢失，rabbitmq 引入消息应答机制，消息应答就是：<strong>消费者在接</strong></p><p><strong>收到消息并且处理该消息之后，告诉rabbitmq它已经处理了，rabbitmq可以把该消息删除了。</strong></p><h3 id="自动应答"><a href="#自动应答" class="headerlink" title="自动应答"></a>自动应答</h3><p>消息发送后立即被认为已经传送成功，这种模式需要在<strong>高吞吐量和数据传输安全性方面做权衡</strong>,因为这种模式如果消息在接收到之前，消费者那边出现连接或者 channel 关闭，那么消息就丢失了,当然另一方面这种模式消费者那边可以传递过载的消息，<strong>没有对传递的消息数量进行限制</strong>，当然这样有可能使得消费者这边由于接收太多还来不及处理的消息，导致这些消息的积压，最终使得内存耗尽，最终这些消费者线程被操作系统杀死，<strong>所以这种模式仅适用在消费者可以高效并以某种速率能够处理这些消息的情况下使用。</strong></p><h3 id="手动消息应答的方法"><a href="#手动消息应答的方法" class="headerlink" title="手动消息应答的方法"></a>手动消息应答的方法</h3><ul><li><code>Channel.basicAck</code>(肯定确认应答)</li></ul><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">//第一个参数是消息的标记，第二个参数表示是否应用于多消息</span><span class="token comment">//RabbitMQ 已知道该消息并且成功的处理消息，可以将其丢弃了</span><span class="token function">basicAck</span><span class="token punctuation">(</span><span class="token keyword">long</span> deliveryTag<span class="token punctuation">,</span> <span class="token keyword">boolean</span> multiple<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li><code>Channel.basicReject</code> (否定确认应答)</li></ul><pre class="language-java" data-language="java"><code class="language-java"><span class="token function">basicReject</span><span class="token punctuation">(</span><span class="token keyword">long</span> deliveryTag<span class="token punctuation">,</span> <span class="token keyword">boolean</span> requeue<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>第一个参数表示拒绝 <code>deliveryTag</code> 对应的消息，第二个参数表示是否 <code>requeue</code>：true 则重新入队列，false 则丢弃或者进入死信队列。</p><p>该方法 reject 后，该消费者还是会消费到该条被 reject 的消息。</p><ul><li><code>Channel.basicNack</code> (用于否定确认)：示己拒绝处理该消息，可以将其丢弃了</li></ul><pre class="language-java" data-language="java"><code class="language-java"><span class="token function">basicNack</span><span class="token punctuation">(</span><span class="token keyword">long</span> deliveryTag<span class="token punctuation">,</span> <span class="token keyword">boolean</span> multiple<span class="token punctuation">,</span> <span class="token keyword">boolean</span> requeue<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>第一个参数表示拒绝 <code>deliveryTag</code> 对应的消息，第二个参数是表示否应用于多消息，第三个参数表示是否 <code>requeue</code>，与 basicReject 区别就是同时支持多个消息，可以拒绝签收该消费者先前接收未 ack 的所有消息。拒绝签收后的消息也会被自己消费到。</p><ul><li><code>Channel.basicRecover</code></li></ul><pre class="language-java" data-language="java"><code class="language-java"><span class="token function">basicRecover</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> requeue<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>是否恢复消息到队列，参数是是否 <code>requeue</code>，true 则重新入队列，并且尽可能的将之前 <code>recover</code> 的消息投递给其他消费者消费，而不是自己再次消费。false 则消息会重新被投递给自己。</p><h3 id="Multiple的解释"><a href="#Multiple的解释" class="headerlink" title="Multiple的解释"></a>Multiple的解释</h3><p>手动应答的好处是可以批量应答并且减少网络拥堵</p><ul><li><p>true 代表批量应答 channel 上未应答的消息</p><p>比如说 channel 上有传送 tag 的消息 5,6,7,8 当前 tag 是 8 那么此时 5-8 的这些还未应答的消息都会被确认收到消息应答</p></li><li><p>false 同上面相比只会应答 tag=8 的消息 5,6,7 这三个消息依然不会被确认收到消息应答</p></li></ul><img src="/2022/09/27/rabbitmq-bi-ji/18.png" class=""><h3 id="消息自动重新入队"><a href="#消息自动重新入队" class="headerlink" title="消息自动重新入队"></a>消息自动重新入队</h3><p>如果消费者由于某些原因失去连接(其通道已关闭，连接已关闭或 TCP 连接丢失)，导致消息未发送 ACK 确认，RabbitMQ 将了解到消息未完全处理，并将对其重新排队。如果此时其他消费者可以处理，它将很快将其重新分发给另一个消费者。这样，即使某个消费者偶尔死亡，也可以确保不会丢失任何消息。</p><img src="/2022/09/27/rabbitmq-bi-ji/19.png" class=""><h3 id="手动应答案例"><a href="#手动应答案例" class="headerlink" title="手动应答案例"></a>手动应答案例</h3><p>默认消息采用的是自动应答，所以我们要想实现消息消费过程中不丢失，需要把自动应答改为手动应答</p><p>消费者启用两个线程，消费 1 一秒消费一个消息，消费者 2 十秒消费一个消息，然后在消费者 2 消费消息的时候，停止运行，这时正在消费的消息是否会重新进入队列，而后给消费者 1 消费呢？</p><ul><li>工具类</li></ul><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SleepUtils</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token keyword">int</span> second<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span> <span class="token operator">*</span> second<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>消息生产者</li></ul><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Task02</span> <span class="token punctuation">{</span>    <span class="token comment">//队列名称</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> TASK_QUEUE_NAME <span class="token operator">=</span> <span class="token string">"ACK_QUEUE"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token class-name">Channel</span> channel <span class="token operator">=</span> <span class="token class-name">RabbitMQUtils</span><span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//声明队列</span>        channel<span class="token punctuation">.</span><span class="token function">queueDeclare</span><span class="token punctuation">(</span>TASK_QUEUE_NAME<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//在控制台中输入信息</span>        <span class="token class-name">Scanner</span> scanner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"请输入信息："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>scanner<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">String</span> message <span class="token operator">=</span> scanner<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            channel<span class="token punctuation">.</span><span class="token function">basicPublish</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> TASK_QUEUE_NAME<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> message<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"生产者发出消息:"</span> <span class="token operator">+</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>消费者1</li></ul><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Work03</span> <span class="token punctuation">{</span>    <span class="token comment">//队列名称</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> TASK_QUEUE_NAME <span class="token operator">=</span> <span class="token string">"ACK_QUEUE"</span><span class="token punctuation">;</span>    <span class="token comment">//接受消息</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token class-name">Channel</span> channel <span class="token operator">=</span> <span class="token class-name">RabbitMQUtils</span><span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"C1等待接受消息处理时间较短"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">DeliverCallback</span> deliverCallback <span class="token operator">=</span> <span class="token punctuation">(</span>consumerTag<span class="token punctuation">,</span> message<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>            <span class="token comment">//沉睡1S</span>            <span class="token class-name">SleepUtils</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"接受到的消息:"</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//手动应答</span>            <span class="token comment">/**             * 1.消息的标记Tag             * 2.是否批量应答 false表示不批量应答信道中的消息             */</span>            channel<span class="token punctuation">.</span><span class="token function">basicAck</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">getEnvelope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDeliveryTag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token class-name">CancelCallback</span> cancelCallback <span class="token operator">=</span> <span class="token punctuation">(</span>consumerTag <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>consumerTag <span class="token operator">+</span> <span class="token string">"消费者取消消费接口回调逻辑"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//采用手动应答</span>        <span class="token keyword">boolean</span> autoAck <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        channel<span class="token punctuation">.</span><span class="token function">basicConsume</span><span class="token punctuation">(</span>TASK_QUEUE_NAME<span class="token punctuation">,</span> autoAck<span class="token punctuation">,</span> deliverCallback<span class="token punctuation">,</span> cancelCallback<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>消费者2</li></ul><p>将休眠1秒代码改为休眠10秒：</p><p><code>SleepUtils.sleep(10);</code></p><ul><li>效果演示</li></ul><img src="/2022/09/27/rabbitmq-bi-ji/20.png" class=""><p>当发送者发送消息 DD 到队列，此时是 Work04来消费该消息，但是由于它处理时间较长，在还未处理完时间里停止运行，也就是说  Work04还没有执行到 ack 代码的时候， Work04被停掉了，此时会看到消息被  Work03接收到了，说明消息 DD 被重新入队，然后分配给能处理消息的  Work03处理了</p><h3 id="RabbitMQ持久化"><a href="#RabbitMQ持久化" class="headerlink" title="RabbitMQ持久化"></a>RabbitMQ持久化</h3><p>当 RabbitMQ 服务停掉以后，消息生产者发送过来的消息不丢失要如何保障？默认情况下 RabbitMQ 退出或由于某种原因崩溃时，它忽视队列和消息，除非告知它不要这样做。确保消息不会丢失需要做两件事：<strong>我们需要将队列和消息都标记为持久化。</strong></p><h4 id="队列持久化"><a href="#队列持久化" class="headerlink" title="队列持久化"></a>队列持久化</h4><p>之前我们创建的队列都是非持久化的，RabbitMQ 如果重启，该队列就会被删除掉，如果要队列实现持久化需要在声明队列的时候把 durable 参数设置为true，代表开启持久化</p><p>在<strong>消息生产者</strong>开启持久化：</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Task02</span> <span class="token punctuation">{</span>    <span class="token comment">//队列名称</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> TASK_QUEUE_NAME <span class="token operator">=</span> <span class="token string">"ack_queue"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token class-name">Channel</span> channel <span class="token operator">=</span> <span class="token class-name">RabbitMQUtils</span><span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//开启持久化</span>        <span class="token keyword">boolean</span> durable <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token comment">//声明队列</span>        channel<span class="token punctuation">.</span><span class="token function">queueDeclare</span><span class="token punctuation">(</span>TASK_QUEUE_NAME<span class="token punctuation">,</span> durable<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//在控制台中输入信息</span>        <span class="token class-name">Scanner</span> scanner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"请输入信息："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>scanner<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">String</span> message <span class="token operator">=</span> scanner<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            channel<span class="token punctuation">.</span><span class="token function">basicPublish</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> TASK_QUEUE_NAME<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> message<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"生产者发出消息:"</span> <span class="token operator">+</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><img src="/2022/09/27/rabbitmq-bi-ji/21.png" class=""><div class="note warning no-icon"><p><strong>注意</strong></p><p>如果之前声明的队列不是持久化的，需要把原先队列先删除，或者重新创建一个持久化的队列</p></div><p>不然就会出现如下错误：</p><img src="/2022/09/27/rabbitmq-bi-ji/22.png" class=""><h4 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h4><p>需要在<strong>消息生产者</strong>发布消息的时候，开启消息的持久化</p><p>在 basicPublish 方法的第二个参数添加这个属性： <code>MessageProperties.PERSISTENT_TEXT_PLAIN</code></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Task02</span> <span class="token punctuation">{</span>    <span class="token comment">//队列名称</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> TASK_QUEUE_NAME <span class="token operator">=</span> <span class="token string">"ack_queue"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token class-name">Channel</span> channel <span class="token operator">=</span> <span class="token class-name">RabbitMQUtils</span><span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//开启持久化</span>        <span class="token keyword">boolean</span> durable <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token comment">//声明队列</span>        channel<span class="token punctuation">.</span><span class="token function">queueDeclare</span><span class="token punctuation">(</span>TASK_QUEUE_NAME<span class="token punctuation">,</span> durable<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//在控制台中输入信息</span>        <span class="token class-name">Scanner</span> scanner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"请输入信息："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>scanner<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">String</span> message <span class="token operator">=</span> scanner<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//设置生产者发送消息为持久化消息(要求保存到磁盘上)</span>            channel<span class="token punctuation">.</span><span class="token function">basicPublish</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> TASK_QUEUE_NAME<span class="token punctuation">,</span> <span class="token class-name">MessageProperties</span><span class="token punctuation">.</span>PERSISTENT_TEXT_PLAIN<span class="token punctuation">,</span> message<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"生产者发出消息:"</span> <span class="token operator">+</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>将消息标记为持久化并不能完全保证不会丢失消息。尽管它告诉 RabbitMQ 将消息保存到磁盘，但是这里依然存在当消息刚准备存储在磁盘的时候 但是还没有存储完，消息还在缓存的一个间隔点。此时并没 有真正写入磁盘。持久性保证并不强，但是对于我们的简单任务队列而言，这已经绰绰有余了</p><h3 id="不公平分发"><a href="#不公平分发" class="headerlink" title="不公平分发"></a>不公平分发</h3><ul><li>介绍</li></ul><p>在最开始的时候我们学习到 RabbitMQ 分发消息采用的轮询分发，但是在某种场景下这种策略并不是很好，比方说有两个消费者在处理任务，其中有个<strong>消费者 1</strong> 处理任务的速度非常快，而另外一个<strong>消费者 2</strong> 处理速度却很慢，这个时候我们还是采用轮询分发的化就会到这处理速度快的这个消费者很大一部分时间处于空闲状态，而处理慢的那个消费者一直在干活，这种分配方式在这种情况下其实就不太好，但是 RabbitMQ 并不知道这种情况它依然很公平的进行分发。</p><p>为了避免这种情况，<strong>在消费者中消费消息之前</strong>，设置参数 <code>channel.basicQos(1);</code></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Work03</span> <span class="token punctuation">{</span>    <span class="token comment">//队列名称</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> TASK_QUEUE_NAME <span class="token operator">=</span> <span class="token string">"ack_queue"</span><span class="token punctuation">;</span>    <span class="token comment">//接受消息</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token class-name">Channel</span> channel <span class="token operator">=</span> <span class="token class-name">RabbitMQUtils</span><span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"C1等待接受消息处理时间较短"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">DeliverCallback</span> deliverCallback <span class="token operator">=</span> <span class="token punctuation">(</span>consumerTag<span class="token punctuation">,</span> message<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>            <span class="token comment">//休眠1S</span>            <span class="token class-name">SleepUtils</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"接受到的消息:"</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//手动应答</span>            <span class="token comment">/**             * 1.消息的标记Tag             * 2.是否批量应答 false表示不批量应答信道中的消息             */</span>            channel<span class="token punctuation">.</span><span class="token function">basicAck</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">getEnvelope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDeliveryTag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token class-name">CancelCallback</span> cancelCallback <span class="token operator">=</span> <span class="token punctuation">(</span>consumerTag <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>consumerTag <span class="token operator">+</span> <span class="token string">"消费者取消消费接口回调逻辑"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//设置不公平分发</span>        <span class="token keyword">int</span> prefetchCount <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        channel<span class="token punctuation">.</span><span class="token function">basicQos</span><span class="token punctuation">(</span>prefetchCount<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//采用手动应答</span>        <span class="token keyword">boolean</span> autoAck <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        channel<span class="token punctuation">.</span><span class="token function">basicConsume</span><span class="token punctuation">(</span>TASK_QUEUE_NAME<span class="token punctuation">,</span> autoAck<span class="token punctuation">,</span> deliverCallback<span class="token punctuation">,</span> cancelCallback<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>开启成功，会看到如下结果：</p><img src="/2022/09/27/rabbitmq-bi-ji/23.png" class=""><p>不公平分发思想：如果一个工作队列还没有处理完或者没有应答签收一个消息，则不拒绝 RabbitMQ 分配新的消息到该工作队列。此时 RabbitMQ 会优先分配给其他已经处理完消息或者空闲的工作队列。如果所有的消费者都没有完成手上任务，队列还在不停的添加新任务，队列有可能就会遇到队列被撑满的情况，这个时候就只能添加新的 worker (工作队列)或者改变其他存储任务的策略。</p><ul><li>效果演示</li></ul><p>生产者生产多个消息，两个消费者的消费时间不同，则消费消息的次数也不同</p><img src="/2022/09/27/rabbitmq-bi-ji/24.png" class=""><h3 id="预取值分发"><a href="#预取值分发" class="headerlink" title="预取值分发"></a>预取值分发</h3><ul><li>介绍</li></ul><p>带权的消息分发</p><p>默认消息的发送是异步发送的，所以在任何时候，channel 上不止只有一个消息来自消费者的手动确认，所以本质上是异步的。因此这里就存在一个未确认的消息缓冲区，因此希望开发人员能<strong>限制此缓冲区的大小</strong>，<strong>以避免缓冲区里面无限制的未确认消息问题</strong>。这个时候就可以通过使用 <code>basic.qos</code> 方法设置「预取计数」值来完成的。</p><p>该值定义通道上允许的未确认消息的最大数量。一旦数量达到配置的数量， RabbitMQ 将停止在通道上传递更多消息，除非至少有一个未处理的消息被确认，例如，假设在通道上有未确认的消息 5、6、7，8，并且通道的预取计数设置为 4，此时 RabbitMQ 将不会在该通道上再传递任何消息，除非至少有一个未应答的消息被 ack。比方说 tag=6 这个消息刚刚被确认 ACK，RabbitMQ 将会感知这个情况到并再发送一条消息。消息应答和 QoS 预取值对用户吞吐量有重大影响。</p><p>通常，增加预取将提高向消费者传递消息的速度。<strong>虽然自动应答传输消息速率是最佳的，但是，在这种情况下已传递但尚未处理的消息的数量也会增加，从而增加了消费者的 RAM 消耗</strong>(随机存取存储器)应该小心使用具有无限预处理的自动确认模式或手动确认模式，消费者消费了大量的消息如果没有确认的话，会导致消费者连接节点的内存消耗变大，所以找到合适的预取值是一个反复试验的过程，不同的负载该值取值也不同 100 到 300 范围内的值通常可提供最佳的吞吐量，并且不会给消费者带来太大的风险。</p><p>预取值为 1 是最保守的。当然这将使吞吐量变得很低，特别是消费者连接延迟很严重的情况下，特别是在消费者连接等待时间较长的环境 中。对于大多数应用来说，稍微高一点的值将是最佳的。</p><img src="/2022/09/27/rabbitmq-bi-ji/25.png" class=""><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Work03</span> <span class="token punctuation">{</span>    <span class="token comment">//队列名称</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> TASK_QUEUE_NAME <span class="token operator">=</span> <span class="token string">"ack_queue"</span><span class="token punctuation">;</span>    <span class="token comment">//接受消息</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token class-name">Channel</span> channel <span class="token operator">=</span> <span class="token class-name">RabbitMQUtils</span><span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"C1等待接受消息处理时间较短"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">DeliverCallback</span> deliverCallback <span class="token operator">=</span> <span class="token punctuation">(</span>consumerTag<span class="token punctuation">,</span> message<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>            <span class="token comment">//休眠1S</span>            <span class="token class-name">SleepUtils</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"接受到的消息:"</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//手动应答</span>            <span class="token comment">/**             * 1.消息的标记Tag             * 2.是否批量应答 false表示不批量应答信道中的消息             */</span>            channel<span class="token punctuation">.</span><span class="token function">basicAck</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">getEnvelope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDeliveryTag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token class-name">CancelCallback</span> cancelCallback <span class="token operator">=</span> <span class="token punctuation">(</span>consumerTag <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>consumerTag <span class="token operator">+</span> <span class="token string">"消费者取消消费接口回调逻辑"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//设置不公平分发</span><span class="token comment">//        int prefetchCount = 1;</span>        <span class="token comment">//值不等于 1，则代表预取值,预取值为4</span>        <span class="token keyword">int</span> prefetchCount <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>        channel<span class="token punctuation">.</span><span class="token function">basicQos</span><span class="token punctuation">(</span>prefetchCount<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//采用手动应答</span>        <span class="token keyword">boolean</span> autoAck <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        channel<span class="token punctuation">.</span><span class="token function">basicConsume</span><span class="token punctuation">(</span>TASK_QUEUE_NAME<span class="token punctuation">,</span> autoAck<span class="token punctuation">,</span> deliverCallback<span class="token punctuation">,</span> cancelCallback<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><div class="note success no-icon"><p>不公平分发和预取值分发都用到 <code>basic.qos</code> 方法，如果取值为 1，代表不公平分发，取值不为1，代表预取值分发</p></div><ul><li>效果演示</li></ul><p>设置了预取值为 4。生产者发送 5 条消息到 MQ 中</p><img src="/2022/09/27/rabbitmq-bi-ji/26.png" class=""><h3 id="发布确认逻辑"><a href="#发布确认逻辑" class="headerlink" title="发布确认逻辑"></a>发布确认逻辑</h3><p>生产者将信道设置成 confirm 模式，一旦信道进入 confirm 模式，所有在该信道上面发布的消息都将会被指派一个唯一的 ID(从 1 开始)，一旦消息被投递到所有匹配的队列之后，broker 就会发送一个确认给生产者(包含消息的唯一 ID)，这就使得生产者知道消息已经正确到达目的队列了，如果消息和队列是可持久化的，那么确认消息会在将消息写入磁盘之后发出，broker 回传给生产者的确认消息中 delivery-tag 域包含了确认消息的序列号，此外 broker 也可以设置 basic.ack 的 multiple 域，表示到这个序列号之前的所有消息都已经得到了处理。</p><p>confirm 模式最大的好处在于是异步的，一旦发布一条消息，生产者应用程序就可以在等信道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用便可以通过回调方法来处理该确认消息，如果RabbitMQ 因为自身内部错误导致消息丢失，就会发送一条 nack 消息， 生产者应用程序同样可以在回调方法中处理该 nack 消息。</p><h4 id="开启发布确认的方法"><a href="#开启发布确认的方法" class="headerlink" title="开启发布确认的方法"></a>开启发布确认的方法</h4><p>发布确认默认是没有开启的，如果要开启需要调用方法 confirmSelect，每当你要想使用发布确认，都需要在 channel 上调用该方法</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">//开启发布确认</span>channel<span class="token punctuation">.</span><span class="token function">confirmSelect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="单个确认发布"><a href="#单个确认发布" class="headerlink" title="单个确认发布"></a>单个确认发布</h4><p>这是一种简单的确认方式，它是一种<strong>同步确认发布</strong>的方式，也就是发布一个消息之后只有它被确认发布，后续的消息才能继续发布，<code>waitForConfirmsOrDie(long)</code> 这个方法只有在消息被确认的时候才返回，如果在指定时间范围内这个消息没有被确认那么它将抛出异常。</p><p>这种确认方式有一个最大的缺点就是：<strong>发布速度特别的慢</strong>，因为如果没有确认发布的消息就会阻塞所有后续消息的发布，这种方式最多提供每秒不超过数百条发布消息的吞吐量。当然对于某些应用程序来说这可能已经足够了。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConfirmMessage</span> <span class="token punctuation">{</span>    <span class="token comment">//单个发消息的个数</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MESSAGE_COUNT <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span> <span class="token comment">//Ctrl+Shift+U 变大写</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token function">publishMessageIndividually</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//发布1000个单独确认消息，耗时:1305ms</span>    <span class="token punctuation">}</span>    <span class="token comment">//单个确认</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">publishMessageIndividually</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token class-name">Channel</span> channel <span class="token operator">=</span> <span class="token class-name">RabbitMQUtils</span><span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//队列的声明</span>        <span class="token class-name">String</span> queueName <span class="token operator">=</span> UUID<span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        channel<span class="token punctuation">.</span><span class="token function">queueDeclare</span><span class="token punctuation">(</span>queueName<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//开启发布确认</span>        channel<span class="token punctuation">.</span><span class="token function">confirmSelect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//开始时间</span>        <span class="token keyword">long</span> begin <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//批量发消息</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">String</span> message <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token string">""</span><span class="token punctuation">;</span>            channel<span class="token punctuation">.</span><span class="token function">basicPublish</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> queueName<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> message<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//单个消息就马上进行发布确认</span>            <span class="token keyword">boolean</span> flag <span class="token operator">=</span> channel<span class="token punctuation">.</span><span class="token function">waitForConfirms</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"消息发送成功"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment">//结束时间</span>        <span class="token keyword">long</span> end <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"发布"</span> <span class="token operator">+</span> MESSAGE_COUNT <span class="token operator">+</span> <span class="token string">"个单独确认消息，耗时:"</span> <span class="token operator">+</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> begin<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"ms"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>确认发布指的是成功发送到了队列，并不是消费者消费了消息。</p><h4 id="批量确认发布"><a href="#批量确认发布" class="headerlink" title="批量确认发布"></a>批量确认发布</h4><p>单个确认发布方式非常慢，与单个等待确认消息相比，先发布一批消息然后一起确认可以极大地提高吞吐量，当然这种方式的缺点就是：当发生故障导致发布出现问题时，不知道是哪个消息出问题了，我们必须将整个批处理保存在内存中，以记录重要的信息而后重新发布消息。当然这种方案仍然是同步的，也一样阻塞消息的发布。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConfirmMessage2</span> <span class="token punctuation">{</span>    <span class="token comment">//批量发消息的个数</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MESSAGE_COUNT <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span> <span class="token comment">//Ctrl+Shift+U 变大写</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token function">publishMessageBatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//发布1000个批量确认消息，耗时:59ms</span>    <span class="token punctuation">}</span>    <span class="token comment">//批量发布确认</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">publishMessageBatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token class-name">Channel</span> channel <span class="token operator">=</span> <span class="token class-name">RabbitMQUtils</span><span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//队列的声明</span>        <span class="token class-name">String</span> queueName <span class="token operator">=</span> UUID<span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        channel<span class="token punctuation">.</span><span class="token function">queueDeclare</span><span class="token punctuation">(</span>queueName<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//开启发布确认</span>        channel<span class="token punctuation">.</span><span class="token function">confirmSelect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//开始时间</span>        <span class="token keyword">long</span> begin <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//批量确认消息大小</span>        <span class="token keyword">int</span> batchSize <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>        <span class="token comment">//批量发送消息，批量发布确认</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> MESSAGE_COUNT<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">String</span> message <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token string">""</span><span class="token punctuation">;</span>            channel<span class="token punctuation">.</span><span class="token function">basicPublish</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> queueName<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> message<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//判断达到100条消息的时候，批量确认一次</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> batchSize <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">//发布确认</span>                channel<span class="token punctuation">.</span><span class="token function">waitForConfirms</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment">//结束时间</span>        <span class="token keyword">long</span> end <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"发布"</span> <span class="token operator">+</span> MESSAGE_COUNT <span class="token operator">+</span> <span class="token string">"个批量确认消息，耗时:"</span> <span class="token operator">+</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> begin<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"ms"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="异步确认发布"><a href="#异步确认发布" class="headerlink" title="异步确认发布"></a>异步确认发布</h4><p>异步确认虽然编程逻辑比上两个要复杂，但是性价比最高，无论是可靠性还是效率都很好，利用了回调函数来达到消息可靠性传递的，这个中间件也是通过函数回调来保证是否投递成功，下面详细讲解异步确认是怎么实现的。</p><img src="/2022/09/27/rabbitmq-bi-ji/27.png" class=""><p>添加回调函数，在回调函数里进行确认发布</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConfirmMessage3</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MESSAGE_COUNT <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span> <span class="token comment">//Ctrl+Shift+U 变大写</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token function">publishMessageAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//发布1000个异步发布确认消息，耗时:20ms</span>    <span class="token punctuation">}</span>    <span class="token comment">//异步发布确认</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">publishMessageAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token class-name">Channel</span> channel <span class="token operator">=</span> <span class="token class-name">RabbitMQUtils</span><span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//队列的声明</span>        <span class="token class-name">String</span> queueName <span class="token operator">=</span> UUID<span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        channel<span class="token punctuation">.</span><span class="token function">queueDeclare</span><span class="token punctuation">(</span>queueName<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//开启发布确认</span>        channel<span class="token punctuation">.</span><span class="token function">confirmSelect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//开始时间</span>        <span class="token keyword">long</span> begin <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//消息确认回调的函数</span>        <span class="token class-name">ConfirmCallback</span> ackCallback <span class="token operator">=</span> <span class="token punctuation">(</span>deliveryTag<span class="token punctuation">,</span> multiple<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"确认的消息:"</span> <span class="token operator">+</span> deliveryTag<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token comment">/**         * 1.消息的标记         * 2.是否为批量确认         */</span>        <span class="token comment">//消息确认失败回调函数</span>        <span class="token class-name">ConfirmCallback</span> nackCallback <span class="token operator">=</span> <span class="token punctuation">(</span>deliveryTag<span class="token punctuation">,</span> multiple<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"未确认的消息:"</span> <span class="token operator">+</span> deliveryTag<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token comment">//准备消息的监听器 监听那些消息成功了，哪些消息失败了</span>        <span class="token comment">/**         * 1.监听哪些消息成功了         * 2.监听哪些消息失败了         */</span>        channel<span class="token punctuation">.</span><span class="token function">addConfirmListener</span><span class="token punctuation">(</span>ackCallback<span class="token punctuation">,</span> nackCallback<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//异步通知</span>        <span class="token comment">//批量发送消息</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> MESSAGE_COUNT<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">String</span> message <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token string">"消息"</span><span class="token punctuation">;</span>            channel<span class="token punctuation">.</span><span class="token function">basicPublish</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> queueName<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> message<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//结束时间</span>        <span class="token keyword">long</span> end <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"发布"</span> <span class="token operator">+</span> MESSAGE_COUNT <span class="token operator">+</span> <span class="token string">"个异步发布确认消息，耗时:"</span> <span class="token operator">+</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> begin<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"ms"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>实际案例里，将发布的消息存入 Map 里，方便获取。<code>headMap</code> 方法用于将已确认的消息存入新的 Map 缓存区里，然后清除该新缓存区的内容。因为 <code>headMap</code> 方法是浅拷贝，所以清除了缓存区，相当于清除了内容的地址，也就清除了队列的确认的消息。</p><p><strong>如何处理异步未确认消息?</strong></p><p>最好的解决的解决方案就是把未确认的消息放到一个基于内存的能被发布线程访问的队列，比如说用 ConcurrentLinkedQueue 这个队列在 confirm callbacks 与发布线程之间进行消息的传递。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConfirmMessage3</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MESSAGE_COUNT <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span> <span class="token comment">//Ctrl+Shift+U 变大写</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token function">publishMessageAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//发布1000个异步发布确认消息，耗时:22ms</span>    <span class="token punctuation">}</span>    <span class="token comment">//异步发布确认</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">publishMessageAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">{</span>        <span class="token class-name">Channel</span> channel <span class="token operator">=</span> <span class="token class-name">RabbitMQUtils</span><span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//队列的声明</span>        <span class="token class-name">String</span> queueName <span class="token operator">=</span> UUID<span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        channel<span class="token punctuation">.</span><span class="token function">queueDeclare</span><span class="token punctuation">(</span>queueName<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//开启发布确认</span>        channel<span class="token punctuation">.</span><span class="token function">confirmSelect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/**         * 线程安全有序的一个哈希表，适用于高并发的情况下         * 1.轻松的将序号与消息进行关联         * 2.轻松批量删除条目 只要给到序号         * 3.支持高并发(多线程)         */</span>        <span class="token class-name">ConcurrentSkipListMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">,</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> outstandingConfirms<span class="token operator">=</span>                <span class="token keyword">new</span> <span class="token class-name">ConcurrentSkipListMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//消息确认回调的函数</span>        <span class="token class-name">ConfirmCallback</span> ackCallback <span class="token operator">=</span> <span class="token punctuation">(</span>deliveryTag<span class="token punctuation">,</span>multiple<span class="token punctuation">)</span> <span class="token operator">-&gt;</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>multiple<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">//2.删除掉已经确认的消息 剩下的就是未确认的消息</span>                <span class="token class-name">ConcurrentNavigableMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> confirmed <span class="token operator">=</span>                        outstandingConfirms<span class="token punctuation">.</span><span class="token function">headMap</span><span class="token punctuation">(</span>deliveryTag<span class="token punctuation">)</span><span class="token punctuation">;</span>                confirmed<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>                outstandingConfirms<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>deliveryTag<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"确认的消息:"</span> <span class="token operator">+</span> deliveryTag<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token comment">/**         * 1.消息的标记         * 2.是否为批量确认         */</span>        <span class="token comment">//消息确认失败回调函数</span>        <span class="token class-name">ConfirmCallback</span> nackCallback<span class="token operator">=</span> <span class="token punctuation">(</span>deliveryTag<span class="token punctuation">,</span>multiple<span class="token punctuation">)</span> <span class="token operator">-&gt;</span><span class="token punctuation">{</span>            <span class="token comment">//3.打印一下未确认的消息都有哪些</span>            <span class="token class-name">String</span> message <span class="token operator">=</span> outstandingConfirms<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>deliveryTag<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"未确认的消息是:"</span><span class="token operator">+</span>message<span class="token operator">+</span><span class="token string">":::未确认的消息tag:"</span><span class="token operator">+</span>deliveryTag<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token comment">//准备消息的监听器 监听那些消息成功了，哪些消息失败了</span>        <span class="token comment">/**         * 1.监听哪些消息成功了         * 2.监听哪些消息失败了         */</span>        channel<span class="token punctuation">.</span><span class="token function">addConfirmListener</span><span class="token punctuation">(</span>ackCallback<span class="token punctuation">,</span>nackCallback<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//异步通知</span>        <span class="token comment">//开始时间</span>        <span class="token keyword">long</span> begin <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//批量发送消息</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> MESSAGE_COUNT<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">String</span> message<span class="token operator">=</span>i<span class="token operator">+</span><span class="token string">"消息"</span><span class="token punctuation">;</span>            channel<span class="token punctuation">.</span><span class="token function">basicPublish</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span>queueName<span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">,</span>message<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//1.此处记录下所有要发送的消息 消息的总和</span>            outstandingConfirms<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>channel<span class="token punctuation">.</span><span class="token function">getNextPublishSeqNo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//结束时间</span>        <span class="token keyword">long</span> end <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"发布"</span><span class="token operator">+</span>MESSAGE_COUNT<span class="token operator">+</span><span class="token string">"个异步发布确认消息，耗时:"</span><span class="token operator">+</span><span class="token punctuation">(</span>end<span class="token operator">-</span>begin<span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"ms"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>以上 3 种发布确认速度对比:</strong></p><ul><li><p>单独发布消息</p><p>同步等待确认，简单，但吞吐量非常有限。</p></li><li><p>批量发布消息</p><p>批量同步等待确认，简单，合理的吞吐量，一旦出现问题但很难推断出是那条消息出现了问题。</p></li><li><p>异步处理</p><p>最佳性能和资源使用，在出现错误的情况下可以很好地控制，但是实现起来稍微难些</p></li></ul><h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><p>RabbitMQ 消息传递模型的核心思想是: <strong>生产者生产的消息从不会直接发送到队列</strong>。实际上，通常生产者甚至都不知道这些消息传递传递到了哪些队列中。</p><p>相反，**生产者只能将消息发送到交换机(exchange)**，交换机工作的内容非常简单，一方面它接收来自生产者的消息，另一方面将它们推入队列。交换机必须确切知道如何处理收到的消息。是应该把这些消息放到特定队列还是说把他们到许多队列中还是说应该丢弃它们。这就的由交换机的类型来决定。</p><h3 id="交换机的类型"><a href="#交换机的类型" class="headerlink" title="交换机的类型"></a>交换机的类型</h3><ul><li><p>**直接(direct)**：处理路由键。需要将一个队列绑定到交换机上，要求该消息与一个特定的路由键完全匹配。这是一个完整的匹配。如果一个队列绑定到该交换机上要求路由键 abc ，则只有被标记为 abc 的消息才被转发，不会转发 abc.def，也不会转发 dog.ghi，只会转发 abc。</p></li><li><p>**主题(topic)*<em>：将路由键和某模式进行匹配。此时队列需要绑定要一个模式上。符号“#”匹配一个或多个词，符号 * 匹配不多不少一个词。因此 abc.# 能够匹配到 abc.def.ghi，但是 abc.</em> 只会匹配到 abc.def。</p></li><li><p>**标题(headers)**：不处理路由键。而是根据发送的消息内容中的headers属性进行匹配。在绑定 Queue 与 Exchange 时指定一组键值对；当消息发送到RabbitMQ 时会取到该消息的 headers 与 Exchange 绑定时指定的键值对进行匹配；如果完全匹配则消息会路由到该队列，否则不会路由到该队列。headers 属性是一个键值对，可以是 Hashtable，键值对的值可以是任何类型。而 fanout，direct，topic 的路由键都需要要字符串形式的。</p><p>匹配规则 x-match 有下列两种类型：</p><p>x-match = all ：表示所有的键值对都匹配才能接受到消息</p><p>x-match = any ：表示只要有键值对匹配就能接受到消息</p></li><li><p>**扇出(fanout)**：不处理路由键。你只需要简单的将队列绑定到交换机上。一个发送到交换机的消息都会被转发到与该交换机绑定的所有队列上。很像子网广播，每台子网内的主机都获得了一份复制的消息。Fanout 交换机转发消息是最快的。</p></li></ul><h3 id="默认交换机"><a href="#默认交换机" class="headerlink" title="默认交换机"></a>默认交换机</h3><p>通过空字符串(“”)进行标识的交换机是默认交换</p><p><code>channel.basicPublish("", TASK_QUEUE_NAME, null, message.getBytes("UTF-8"));</code></p><p>第一个参数是交换机的名称。空字符串 表示默认或无名称交换机：消息能路由发送到队列中其实是由 routingKey(bindingkey) 绑定指定的 key</p><img src="/2022/09/27/rabbitmq-bi-ji/28.png" class=""><h3 id="临时队列"><a href="#临时队列" class="headerlink" title="临时队列"></a>临时队列</h3><p>之前的章节我们使用的是具有特定名称的队列(还记得 hello 和 ack_queue 吗？)。队列的名称我们来说至关重要，我们需要指定我们的消费者去消费哪个队列的消息。</p><p>每当我们连接到 Rabbit 时，我们都需要一个全新的空队列，为此我们可以创建一个具有<strong>随机名称的队列</strong>，或者能让服务器为我们选择一个随机队列名称那就更好了。其次一旦我们断开了消费者的连接，队列将被自动删除。</p><p>创建临时队列的方式如下:</p><p><code>String queueName = channel.queueDeclare().getQueue();</code></p><img src="/2022/09/27/rabbitmq-bi-ji/29.png" class=""><h3 id="绑定bindings"><a href="#绑定bindings" class="headerlink" title="绑定bindings"></a>绑定bindings</h3><p>什么是 bingding 呢，binding 其实是 exchange 和 queue 之间的桥梁，它告诉我们 exchange 和那个队列进行了绑定关系。比如说下面这张图告诉我们的就是 X 与 Q1 和 Q2 进行了绑定</p><img src="/2022/09/27/rabbitmq-bi-ji/30.png" class=""><h3 id="Fanout实战"><a href="#Fanout实战" class="headerlink" title="Fanout实战"></a>Fanout实战</h3><p>为了说明这种模式，我们将构建一个简单的日志系统。它将由两个程序组成:第一个程序将发出日志消息，第二个程序是消费者。其中启动两个消费者，其中一个消费者接收到消息后把日志存储在磁盘</p><img src="/2022/09/27/rabbitmq-bi-ji/31.png" class=""><p><code>ReceiveLogs01</code> 将接收到的消息打印在控制台</p><p><code>ReceiveLogs02</code> 把消息写出到文件</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">//消费者1</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReceiveLogs01</span> <span class="token punctuation">{</span>    <span class="token comment">//交换机名称</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> EXCHANGE_NAME <span class="token operator">=</span> <span class="token string">"logs"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token class-name">Channel</span> channel <span class="token operator">=</span> <span class="token class-name">RabbitMQUtils</span><span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//声明一个交换机</span>        channel<span class="token punctuation">.</span><span class="token function">exchangeDeclare</span><span class="token punctuation">(</span>EXCHANGE_NAME<span class="token punctuation">,</span> <span class="token string">"fanout"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//声明一个队列 临时队列</span>        <span class="token comment">/**         * 生成一个临时的队列，队列的名称是随机的         * 当消费者断开与队列的连接的时候 队列就自动删除         */</span>        <span class="token class-name">String</span> queueName <span class="token operator">=</span> channel<span class="token punctuation">.</span><span class="token function">queueDeclare</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/**         * 绑定交换机与队列         */</span>        channel<span class="token punctuation">.</span><span class="token function">queueBind</span><span class="token punctuation">(</span>queueName<span class="token punctuation">,</span> EXCHANGE_NAME<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"等待接收消息，把接收到的消息打印在屏幕上..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//接收消息</span>        <span class="token comment">//消费者取消消息时回调接口</span>        <span class="token class-name">DeliverCallback</span> deliverCallback <span class="token operator">=</span> <span class="token punctuation">(</span>consumerTag<span class="token punctuation">,</span> message<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"控制台打印接收到的消息:"</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        channel<span class="token punctuation">.</span><span class="token function">basicConsume</span><span class="token punctuation">(</span>queueName<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> deliverCallback<span class="token punctuation">,</span> consumerTag <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">//消费者2</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReceiveLogs02</span> <span class="token punctuation">{</span>    <span class="token comment">//交换机名称</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> EXCHANGE_NAME <span class="token operator">=</span> <span class="token string">"logs"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token class-name">Channel</span> channel <span class="token operator">=</span> <span class="token class-name">RabbitMQUtils</span><span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//声明一个交换机</span>        channel<span class="token punctuation">.</span><span class="token function">exchangeDeclare</span><span class="token punctuation">(</span>EXCHANGE_NAME<span class="token punctuation">,</span> <span class="token string">"fanout"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//声明一个队列 临时队列</span>        <span class="token comment">/**         * 生成一个临时的队列 队列的名称是随机的         * 当消费者断开和该队列的连接时队列自动删除*/</span>        <span class="token class-name">String</span> queueName <span class="token operator">=</span> channel<span class="token punctuation">.</span><span class="token function">queueDeclare</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/**         * 绑定交换机与队列         */</span>        channel<span class="token punctuation">.</span><span class="token function">queueBind</span><span class="token punctuation">(</span>queueName<span class="token punctuation">,</span> EXCHANGE_NAME<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//把该临时队列绑定我们的exchange 其中routingkey(也称之为binding key)为空字符串channel.queueBind(queueName, EXCHANGE_NAME, "");</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"等待接收消息,把接收到的消息写到文件....."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">DeliverCallback</span> deliverCallback <span class="token operator">=</span> <span class="token punctuation">(</span>consumerTag<span class="token punctuation">,</span> delivery<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>            <span class="token class-name">String</span> message <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>delivery<span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">File</span> file <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"D:\\Learn\\rabbitmq_info.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">FileUtils</span><span class="token punctuation">.</span><span class="token function">writeStringToFile</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> message<span class="token punctuation">,</span> <span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"数据写入文件成功"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        channel<span class="token punctuation">.</span><span class="token function">basicConsume</span><span class="token punctuation">(</span>queueName<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> deliverCallback<span class="token punctuation">,</span> consumerTag <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>生产者<code>EmitLog</code> 发送消息给两个消费者进行消费</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">//负责进行发消息给交换机</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EmitLog</span> <span class="token punctuation">{</span>    <span class="token comment">//交换机名称</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> EXCHANGE_NAME <span class="token operator">=</span> <span class="token string">"logs"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token class-name">Channel</span> channel <span class="token operator">=</span> <span class="token class-name">RabbitMQUtils</span><span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/**         * 声明一个exchange         * 1.exchange的名称         * 2.exchange的类型         */</span>        channel<span class="token punctuation">.</span><span class="token function">exchangeDeclare</span><span class="token punctuation">(</span>EXCHANGE_NAME<span class="token punctuation">,</span> <span class="token string">"fanout"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Scanner</span> scanner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>scanner<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">String</span> message <span class="token operator">=</span> scanner<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            channel<span class="token punctuation">.</span><span class="token function">basicPublish</span><span class="token punctuation">(</span>EXCHANGE_NAME<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> message<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"生产者发出消息:"</span> <span class="token operator">+</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><img src="/2022/09/27/rabbitmq-bi-ji/32.png" class=""><div class="note success no-icon"><p>一个发送，多个接受，发布/订阅模式</p></div><h3 id="Direct-exchange"><a href="#Direct-exchange" class="headerlink" title="Direct exchange"></a>Direct exchange</h3><p>在上一节中，我们构建了一个简单的日志记录系统。我们能够向许多接收者广播日志消息。在本节我们将向其中添加一些特别的功能——让某个消费者订阅发布的部分消息。例如我们只把严重错误消息定向存储到日志文件(以节省磁盘空间)，同时仍然能够在控制台上打印所有日志消息。</p><p>我们再次来回顾一下什么是 bindings，绑定是交换机和队列之间的桥梁关系。也可以这么理解： <strong>队列只对它绑定的交换机的消息感兴趣</strong>。绑定用参数：routingKey 来表示也可称该参数为 binding key， 创建绑定我们用代码:channel.queueBind(queueName, EXCHANGE_NAME, “routingKey”);绑定之后的意义由其交换类型决定。</p><h4 id="Direct介绍"><a href="#Direct介绍" class="headerlink" title="Direct介绍"></a>Direct介绍</h4><p>上一节中的我们的日志系统将所有消息广播给所有消费者，对此我们想做一些改变，例如我们希望将日志消息写入磁盘的程序仅接收严重错误(errros)，而不存储哪些警告(warning)或信息(info)日志 消息避免浪费磁盘空间。Fanout 这种交换类型并不能给我们带来很大的灵活性-它只能进行无意识的广播，在这里我们将使用 direct 这种类型来进行替换，这种类型的工作方式是，消息只去到它绑定的 routingKey 队列中去。</p><img src="/2022/09/27/rabbitmq-bi-ji/33.png" class=""><p>在上面这张图中，我们可以看到 X 绑定了两个队列，绑定类型是 direct。队列 Q1 绑定键为 orange， 队列 Q2 绑定键有两个：一个绑定键为 black，另一个绑定键为 green.</p><p>在这种绑定情况下，生产者发布消息到 exchange 上，绑定键为 orange 的消息会被发布到队列 Q1。绑定键为 blackgreen 和的消息会被发布到队列 Q2，其他消息类型的消息将被丢弃。</p><h4 id="多重绑定"><a href="#多重绑定" class="headerlink" title="多重绑定"></a>多重绑定</h4><img src="/2022/09/27/rabbitmq-bi-ji/34.png" class=""><p>当然如果 exchange 的绑定类型是direct，<strong>但是它绑定的多个队列的 key 如果都相同</strong>，在这种情况下虽然绑定类型是 direct <strong>但是它表现的就和 fanout 有点类似了</strong>，就跟广播差不多，如上图所示</p><h4 id="Direct实战"><a href="#Direct实战" class="headerlink" title="Direct实战"></a>Direct实战</h4><p>关系：</p><img src="/2022/09/27/rabbitmq-bi-ji/35.png" class=""><p>交换机：</p><img src="/2022/09/27/rabbitmq-bi-ji/36.png" class=""><p>C1 消费者：绑定 console 队列，routingKey 为 info、warning</p><p>C2 消费者：绑定 disk 队列，routingKey 为 error</p><p>当生产者生产消息到 <code>direct_logs</code> 交换机里，该交换机会检测消息的 routingKey 条件，然后分配到满足条件的队列里，最后由消费者从队列消费消息。</p><p><strong>生产者</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DirectLogs</span> <span class="token punctuation">{</span>    <span class="token comment">//交换机名称</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> EXCHANGE_NAME <span class="token operator">=</span> <span class="token string">"direct_logs"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token class-name">Channel</span> channel <span class="token operator">=</span> <span class="token class-name">RabbitMQUtils</span><span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Scanner</span> scanner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>scanner<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">String</span> message <span class="token operator">=</span> scanner<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            channel<span class="token punctuation">.</span><span class="token function">basicPublish</span><span class="token punctuation">(</span>EXCHANGE_NAME<span class="token punctuation">,</span> <span class="token string">"info"</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> message<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"生产者发出消息:"</span> <span class="token operator">+</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>消费者1</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReceiveLogsDirect01</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> EXCHANGE_NAME <span class="token operator">=</span> <span class="token string">"direct_logs"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token class-name">Channel</span> channel <span class="token operator">=</span> <span class="token class-name">RabbitMQUtils</span><span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//声明一个direct交换机</span>        channel<span class="token punctuation">.</span><span class="token function">exchangeDeclare</span><span class="token punctuation">(</span>EXCHANGE_NAME<span class="token punctuation">,</span> <span class="token class-name">BuiltinExchangeType</span><span class="token punctuation">.</span>DIRECT<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//声明一个队列</span>        channel<span class="token punctuation">.</span><span class="token function">queueDeclare</span><span class="token punctuation">(</span><span class="token string">"console"</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        channel<span class="token punctuation">.</span><span class="token function">queueBind</span><span class="token punctuation">(</span><span class="token string">"console"</span><span class="token punctuation">,</span> EXCHANGE_NAME<span class="token punctuation">,</span> <span class="token string">"info"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        channel<span class="token punctuation">.</span><span class="token function">queueBind</span><span class="token punctuation">(</span><span class="token string">"console"</span><span class="token punctuation">,</span> EXCHANGE_NAME<span class="token punctuation">,</span> <span class="token string">"warning"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//接收消息</span>        <span class="token class-name">DeliverCallback</span> deliverCallback <span class="token operator">=</span> <span class="token punctuation">(</span>consumerTag<span class="token punctuation">,</span> message<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ReceiveLogsDirect01控制台打印接收到的消息:"</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token comment">//消费者取消消息时回调接口</span>        channel<span class="token punctuation">.</span><span class="token function">basicConsume</span><span class="token punctuation">(</span><span class="token string">"console"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> deliverCallback<span class="token punctuation">,</span> consumerTag <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>消费者2</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReceiveLogsDirect02</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> EXCHANGE_NAME <span class="token operator">=</span> <span class="token string">"direct_logs"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token class-name">Channel</span> channel <span class="token operator">=</span> <span class="token class-name">RabbitMQUtils</span><span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//声明一个direct交换机</span>        channel<span class="token punctuation">.</span><span class="token function">exchangeDeclare</span><span class="token punctuation">(</span>EXCHANGE_NAME<span class="token punctuation">,</span> <span class="token class-name">BuiltinExchangeType</span><span class="token punctuation">.</span>DIRECT<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//声明一个队列</span>        channel<span class="token punctuation">.</span><span class="token function">queueDeclare</span><span class="token punctuation">(</span><span class="token string">"disk"</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        channel<span class="token punctuation">.</span><span class="token function">queueBind</span><span class="token punctuation">(</span><span class="token string">"disk"</span><span class="token punctuation">,</span> EXCHANGE_NAME<span class="token punctuation">,</span> <span class="token string">"error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//接收消息</span>        <span class="token class-name">DeliverCallback</span> deliverCallback <span class="token operator">=</span> <span class="token punctuation">(</span>consumerTag<span class="token punctuation">,</span> message<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ReceiveLogsDirect02控制台打印接收到的消息:"</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token comment">//消费者取消消息时回调接口</span>        channel<span class="token punctuation">.</span><span class="token function">basicConsume</span><span class="token punctuation">(</span><span class="token string">"disk"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> deliverCallback<span class="token punctuation">,</span> consumerTag <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>让消费者1接收,结果</li></ul><img src="/2022/09/27/rabbitmq-bi-ji/37.png" class=""><h3 id="Topics-exchange"><a href="#Topics-exchange" class="headerlink" title="Topics exchange"></a>Topics exchange</h3><h4 id="Topic介绍"><a href="#Topic介绍" class="headerlink" title="Topic介绍"></a>Topic介绍</h4><p>在上一个小节中，我们改进了日志记录系统。我们没有使用只能进行随意广播的 fanout 交换机，而是使用了 direct 交换机，从而有能实现有选择性地接收日志。</p><p>尽管使用 direct 交换机改进了我们的系统，但是它仍然存在局限性——比方说我们想接收的日志类型有 info.base 和 info.advantage，某个队列只想 info.base 的消息，那这个时候direct 就办不到了。这个时候就只能使用 <strong>topic</strong> 类型</p><p><strong>Topic 的要求</strong></p><p>发送到类型是 topic 交换机的消息的 routing_key 不能随意写，必须满足一定的要求，它必须是<strong>一个单词列表</strong>，<strong>以点号分隔开</strong>。这些单词可以是任意单词</p><p>比如说：”stock.usd.nyse”, “nyse.vmw”, “quick.orange.rabbit” 这种类型的。</p><p>当然这个单词列表最多不能超过 255 个字节。</p><p>在这个规则列表中，其中有两个替换符是大家需要注意的：</p><ul><li>***(星号)可以代替一个位置**</li><li><strong>#(井号)可以替代零个或多个位置</strong></li></ul><h4 id="Topic匹配案例"><a href="#Topic匹配案例" class="headerlink" title="Topic匹配案例"></a>Topic匹配案例</h4><p>下图绑定关系如下</p><img src="/2022/09/27/rabbitmq-bi-ji/38.png" class=""><ul><li>Q1–&gt;绑定的是<ul><li>中间带 orange 带 3 个单词的字符串 <code>(*.orange.*)</code></li></ul></li><li>Q2–&gt;绑定的是<ul><li>最后一个单词是 rabbit 的 3 个单词 <code>(*.*.rabbit)</code></li><li>第一个单词是 lazy 的多个单词 <code>(lazy.#)</code></li></ul></li></ul><table><thead><tr><th>例子</th><th>说明</th></tr></thead><tbody><tr><td>quick.orange.rabbit</td><td>被队列 Q1Q2 接收到</td></tr><tr><td>azy.orange.elephant</td><td>被队列 Q1Q2 接收到</td></tr><tr><td>quick.orange.fox</td><td>被队列 Q1 接收到</td></tr><tr><td>lazy.brown.fox</td><td>被队列 Q2 接收到</td></tr><tr><td>lazy.pink.rabbit</td><td>虽然满足两个绑定但只被队列 Q2 接收一次</td></tr><tr><td>quick.brown.fox</td><td>不匹配任何绑定不会被任何队列接收到会被丢弃</td></tr><tr><td>quick.orange.male.rabbit</td><td>是四个单词不匹配任何绑定会被丢弃</td></tr><tr><td>lazy.orange.male.rabbit</td><td>是四个单词但匹配 Q2</td></tr></tbody></table><div class="note success no-icon"><p>当一个队列绑定键是 #，那么这个队列将接收所有数据，就有点像 fanout 了</p><p>如果队列绑定键当中没有 # 和 * 出现，那么该队列绑定类型就是 direct 了</p></div><h4 id="Topic-实战"><a href="#Topic-实战" class="headerlink" title="Topic 实战"></a>Topic 实战</h4><img src="/2022/09/27/rabbitmq-bi-ji/39.png" class=""><p>生产多个消息到交换机，交换机按照通配符分配消息到不同的队列中，队列由消费者进行消费</p><p><strong>生产者 EmitLogTopic</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EmitLogTopic</span> <span class="token punctuation">{</span>    <span class="token comment">//交换机的名称</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> EXCHANGE_NAME <span class="token operator">=</span> <span class="token string">"topic_logs"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token class-name">Channel</span> channel <span class="token operator">=</span> <span class="token class-name">RabbitMQUtils</span><span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/**         * Q1--&gt;绑定的是         *      中间带 orange 带 3 个单词的字符串(*.orange.*)         * Q2--&gt;绑定的是         *      最后一个单词是 rabbit 的 3 个单词(*.*.rabbit)         *      第一个单词是 lazy 的多个单词(lazy.#)         */</span>        <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> bindingKeyMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bindingKeyMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"quick.orange.rabbit"</span><span class="token punctuation">,</span> <span class="token string">"被队列 Q1Q2 接收到"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bindingKeyMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"lazy.orange.elephant"</span><span class="token punctuation">,</span> <span class="token string">"被队列 Q1Q2 接收到"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bindingKeyMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"quick.orange.fox"</span><span class="token punctuation">,</span> <span class="token string">"被队列 Q1 接收到"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bindingKeyMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"lazy.brown.fox"</span><span class="token punctuation">,</span> <span class="token string">"被队列 Q2 接收到"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bindingKeyMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"lazy.pink.rabbit"</span><span class="token punctuation">,</span> <span class="token string">"虽然满足两个绑定但只被队列 Q2 接收一次"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bindingKeyMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"quick.brown.fox"</span><span class="token punctuation">,</span> <span class="token string">"不匹配任何绑定不会被任何队列接收到会被丢弃"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bindingKeyMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"quick.orange.male.rabbit"</span><span class="token punctuation">,</span> <span class="token string">"是四个单词不匹配任何绑定会被丢弃"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bindingKeyMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"lazy.orange.male.rabbit"</span><span class="token punctuation">,</span> <span class="token string">"是四个单词但匹配 Q2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> bindingKeyEntry <span class="token operator">:</span> bindingKeyMap<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">String</span> routingKey <span class="token operator">=</span> bindingKeyEntry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">String</span> message <span class="token operator">=</span> bindingKeyEntry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            channel<span class="token punctuation">.</span><span class="token function">basicPublish</span><span class="token punctuation">(</span>EXCHANGE_NAME<span class="token punctuation">,</span> routingKey<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> message<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"生产者发出消息:"</span> <span class="token operator">+</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>消费者C1</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReceiveLogsTopic01</span> <span class="token punctuation">{</span>    <span class="token comment">//交换机的名称</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> EXCHANGE_NAME <span class="token operator">=</span> <span class="token string">"topic_logs"</span><span class="token punctuation">;</span>    <span class="token comment">//接收消息</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token class-name">Channel</span> channel <span class="token operator">=</span> <span class="token class-name">RabbitMQUtils</span><span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//声明交换机</span>        channel<span class="token punctuation">.</span><span class="token function">exchangeDeclare</span><span class="token punctuation">(</span>EXCHANGE_NAME<span class="token punctuation">,</span> <span class="token class-name">BuiltinExchangeType</span><span class="token punctuation">.</span>TOPIC<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//声明队列</span>        <span class="token class-name">String</span> queueName <span class="token operator">=</span> <span class="token string">"Q1"</span><span class="token punctuation">;</span>        channel<span class="token punctuation">.</span><span class="token function">queueDeclare</span><span class="token punctuation">(</span>queueName<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        channel<span class="token punctuation">.</span><span class="token function">queueBind</span><span class="token punctuation">(</span>queueName<span class="token punctuation">,</span> EXCHANGE_NAME<span class="token punctuation">,</span> <span class="token string">"*.orange.*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"等待接收消息..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">DeliverCallback</span> deliverCallback <span class="token operator">=</span> <span class="token punctuation">(</span>consumerTag<span class="token punctuation">,</span> message<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"接收队列："</span> <span class="token operator">+</span> queueName <span class="token operator">+</span> <span class="token string">"  绑定键:"</span> <span class="token operator">+</span> message<span class="token punctuation">.</span><span class="token function">getEnvelope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getRoutingKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token comment">//接收消息</span>        channel<span class="token punctuation">.</span><span class="token function">basicConsume</span><span class="token punctuation">(</span>queueName<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> deliverCallback<span class="token punctuation">,</span> consumerTag <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>消费者C2</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReceiveLogsTopic02</span> <span class="token punctuation">{</span>    <span class="token comment">//交换机的名称</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> EXCHANGE_NAME <span class="token operator">=</span> <span class="token string">"topic_logs"</span><span class="token punctuation">;</span>    <span class="token comment">//接收消息</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token class-name">Channel</span> channel <span class="token operator">=</span> <span class="token class-name">RabbitMQUtils</span><span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//声明交换机</span>        channel<span class="token punctuation">.</span><span class="token function">exchangeDeclare</span><span class="token punctuation">(</span>EXCHANGE_NAME<span class="token punctuation">,</span> <span class="token class-name">BuiltinExchangeType</span><span class="token punctuation">.</span>TOPIC<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//声明队列</span>        <span class="token class-name">String</span> queueName <span class="token operator">=</span> <span class="token string">"Q2"</span><span class="token punctuation">;</span>        channel<span class="token punctuation">.</span><span class="token function">queueDeclare</span><span class="token punctuation">(</span>queueName<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        channel<span class="token punctuation">.</span><span class="token function">queueBind</span><span class="token punctuation">(</span>queueName<span class="token punctuation">,</span> EXCHANGE_NAME<span class="token punctuation">,</span> <span class="token string">"*.*.rabbit"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        channel<span class="token punctuation">.</span><span class="token function">queueBind</span><span class="token punctuation">(</span>queueName<span class="token punctuation">,</span> EXCHANGE_NAME<span class="token punctuation">,</span> <span class="token string">"lazy.#"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"等待接收消息..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">DeliverCallback</span> deliverCallback <span class="token operator">=</span> <span class="token punctuation">(</span>consumerTag<span class="token punctuation">,</span> message<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"接收队列："</span> <span class="token operator">+</span> queueName <span class="token operator">+</span> <span class="token string">"  绑定键:"</span> <span class="token operator">+</span> message<span class="token punctuation">.</span><span class="token function">getEnvelope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getRoutingKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token comment">//接收消息</span>        channel<span class="token punctuation">.</span><span class="token function">basicConsume</span><span class="token punctuation">(</span>queueName<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> deliverCallback<span class="token punctuation">,</span> consumerTag <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>测试结果</li></ul><img src="/2022/09/27/rabbitmq-bi-ji/40.png" class=""><h2 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h2><h3 id="死信的概念"><a href="#死信的概念" class="headerlink" title="死信的概念"></a>死信的概念</h3><p>先从概念解释上搞清楚这个定义，死信，顾名思义就是无法被消费的消息，字面意思可以这样理解，一般来说，producer 将消息投递到 broker 或者直接到queue 里了，consumer 从 queue 取出消息 进行消费，但某些时候由于特定的原因<strong>导致 queue 中的某些消息无法被消费</strong>，这样的消息如果没有后续的处理，就变成了死信，有死信自然就有了死信队列。</p><p>应用场景：为了保证订单业务的消息数据不丢失，需要使用到 RabbitMQ 的死信队列机制，当消息消费发生异常时，将消息投入死信队列中。还有比如说：用户在商城下单成功并点击去支付后在指定时间未支付时自动失效。</p><h3 id="死信的来源"><a href="#死信的来源" class="headerlink" title="死信的来源"></a>死信的来源</h3><ul><li><p>消息 TTL 过期</p><p>TTL是 Time To Live 的缩写, 也就是生存时间</p></li><li><p>队列达到最大长度</p><p>队列满了，无法再添加数据到 MQ 中</p></li><li><p>消息被拒绝</p><p>(basic.reject 或 basic.nack) 并且 requeue = false</p></li></ul><h3 id="死信实战"><a href="#死信实战" class="headerlink" title="死信实战"></a>死信实战</h3><p>交换机类型是 direct，两个消费者，一个生产者，两个队列：消息队列和死信队列</p><img src="/2022/09/27/rabbitmq-bi-ji/41.png" class=""><h4 id="消息TTL过期"><a href="#消息TTL过期" class="headerlink" title="消息TTL过期"></a>消息TTL过期</h4><p><strong>生产者</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Producer</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> NORMAL_EXCHANGE <span class="token operator">=</span> <span class="token string">"normal_exchange"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> argv<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token class-name">Channel</span> channel <span class="token operator">=</span> <span class="token class-name">RabbitMQUtils</span><span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//死信消息 设置ttl时间 live to time 单位是ms</span>        <span class="token class-name">AMQP<span class="token punctuation">.</span>BasicProperties</span> properties <span class="token operator">=</span>                <span class="token keyword">new</span> <span class="token class-name">AMQP<span class="token punctuation">.</span>BasicProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">expiration</span><span class="token punctuation">(</span><span class="token string">"10000"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//该信息是用作演示队列个数限制</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">11</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">String</span> message <span class="token operator">=</span> <span class="token string">"info"</span> <span class="token operator">+</span> i<span class="token punctuation">;</span>            channel<span class="token punctuation">.</span><span class="token function">basicPublish</span><span class="token punctuation">(</span>NORMAL_EXCHANGE<span class="token punctuation">,</span> <span class="token string">"zhangsan"</span><span class="token punctuation">,</span> properties<span class="token punctuation">,</span>                    message<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"生产者发送消息:"</span> <span class="token operator">+</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>消费者 C1 代码</strong>(启动之后关闭该消费者 模拟其接收不到消息)</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Consumer01</span> <span class="token punctuation">{</span>    <span class="token comment">//普通交换机的名称</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> NORMAL_EXCHANGE <span class="token operator">=</span> <span class="token string">"normal_exchange"</span><span class="token punctuation">;</span>    <span class="token comment">//死信交换机的名称</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> DEAD_EXCHANGE <span class="token operator">=</span> <span class="token string">"dead_exchange"</span><span class="token punctuation">;</span>    <span class="token comment">//普通队列的名称</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> NORMAL_QUEUE <span class="token operator">=</span> <span class="token string">"normal_queue"</span><span class="token punctuation">;</span>    <span class="token comment">//死信队列的名称</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> DEAD_QUEUE <span class="token operator">=</span> <span class="token string">"dead_queue"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token class-name">Channel</span> channel <span class="token operator">=</span> <span class="token class-name">RabbitMQUtils</span><span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//声明死信和普通交换机，类型为direct</span>        channel<span class="token punctuation">.</span><span class="token function">exchangeDeclare</span><span class="token punctuation">(</span>NORMAL_EXCHANGE<span class="token punctuation">,</span> <span class="token class-name">BuiltinExchangeType</span><span class="token punctuation">.</span>DIRECT<span class="token punctuation">)</span><span class="token punctuation">;</span>        channel<span class="token punctuation">.</span><span class="token function">exchangeDeclare</span><span class="token punctuation">(</span>DEAD_EXCHANGE<span class="token punctuation">,</span> <span class="token class-name">BuiltinExchangeType</span><span class="token punctuation">.</span>DIRECT<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//声明普通队列</span>        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> arguments <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//过期时间 10s 由生产者指定 更加灵活</span>        <span class="token comment">//arguments.put("x-message-ttl",10000);</span>        <span class="token comment">//正常的队列设置死信交换机</span>        arguments<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"x-dead-letter-exchange"</span><span class="token punctuation">,</span> DEAD_EXCHANGE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//图中红箭头</span>        <span class="token comment">//设置死信routingKey</span>        arguments<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"x-dead-letter-routing-key"</span><span class="token punctuation">,</span> <span class="token string">"lisi"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        channel<span class="token punctuation">.</span><span class="token function">queueDeclare</span><span class="token punctuation">(</span>NORMAL_QUEUE<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/////////////////////////////////////////////////////////////////////////</span>        <span class="token comment">//声明死信队列</span>        channel<span class="token punctuation">.</span><span class="token function">queueDeclare</span><span class="token punctuation">(</span>DEAD_QUEUE<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//绑定普通的交换机与队列</span>        channel<span class="token punctuation">.</span><span class="token function">queueBind</span><span class="token punctuation">(</span>NORMAL_QUEUE<span class="token punctuation">,</span> NORMAL_EXCHANGE<span class="token punctuation">,</span> <span class="token string">"zhangsan"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//绑定死信的交换机与死信的队列</span>        channel<span class="token punctuation">.</span><span class="token function">queueBind</span><span class="token punctuation">(</span>DEAD_QUEUE<span class="token punctuation">,</span> DEAD_EXCHANGE<span class="token punctuation">,</span> <span class="token string">"lisi"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"等待接收消息..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">DeliverCallback</span> deliverCallback <span class="token operator">=</span> <span class="token punctuation">(</span>consumerTag<span class="token punctuation">,</span> message<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Consumer01接受的消息是："</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        channel<span class="token punctuation">.</span><span class="token function">basicConsume</span><span class="token punctuation">(</span>NORMAL_QUEUE<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> deliverCallback<span class="token punctuation">,</span> consumerTag <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>先启动消费者 C1，创建出队列，然后停止该 C1 的运行，则 C1 将无法收到队列的消息，无法收到的消息 10 秒后进入死信队列。启动生产者 producer 生产消息</p><img src="/2022/09/27/rabbitmq-bi-ji/42.png" class=""><p><strong>消费者 C2 代码</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Consumer02</span> <span class="token punctuation">{</span>    <span class="token comment">//死信队列的名称</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> DEAD_QUEUE <span class="token operator">=</span> <span class="token string">"dead_queue"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token class-name">Channel</span> channel <span class="token operator">=</span> <span class="token class-name">RabbitMQUtils</span><span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"等待接收死信消息..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">DeliverCallback</span> deliverCallback <span class="token operator">=</span> <span class="token punctuation">(</span>consumerTag<span class="token punctuation">,</span> message<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Consumer02接受的消息是："</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        channel<span class="token punctuation">.</span><span class="token function">basicConsume</span><span class="token punctuation">(</span>DEAD_QUEUE<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> deliverCallback<span class="token punctuation">,</span> consumerTag <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li><strong>运行消费者C2后效果</strong></li></ul><img src="/2022/09/27/rabbitmq-bi-ji/43.png" class=""><img src="/2022/09/27/rabbitmq-bi-ji/44.png" class=""><h4 id="死信最大长度"><a href="#死信最大长度" class="headerlink" title="死信最大长度"></a>死信最大长度</h4><ol><li>消息生产者代码去掉 TTL 属性，<code>basicPublish</code> 的第三个参数改为 null</li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Producer</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> NORMAL_EXCHANGE <span class="token operator">=</span> <span class="token string">"normal_exchange"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> argv<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token class-name">Channel</span> channel <span class="token operator">=</span> <span class="token class-name">RabbitMQUtils</span><span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//死信消息 设置ttl时间 live to time 单位是ms</span><span class="token comment">//        AMQP.BasicProperties properties =</span><span class="token comment">//                new AMQP.BasicProperties().builder().expiration("10000").build();</span>        <span class="token comment">//该信息是用作演示队列个数限制</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">11</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">String</span> message <span class="token operator">=</span> <span class="token string">"info"</span> <span class="token operator">+</span> i<span class="token punctuation">;</span>            channel<span class="token punctuation">.</span><span class="token function">basicPublish</span><span class="token punctuation">(</span>NORMAL_EXCHANGE<span class="token punctuation">,</span> <span class="token string">"zhangsan"</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span>                    message<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"生产者发送消息:"</span> <span class="token operator">+</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ol start="2"><li>C1 消费者修改以下代码(<strong>启动之后关闭该消费者 模拟其接收不到消息</strong>)</li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Consumer01</span> <span class="token punctuation">{</span>    <span class="token comment">//普通交换机的名称</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> NORMAL_EXCHANGE <span class="token operator">=</span> <span class="token string">"normal_exchange"</span><span class="token punctuation">;</span>    <span class="token comment">//死信交换机的名称</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> DEAD_EXCHANGE <span class="token operator">=</span> <span class="token string">"dead_exchange"</span><span class="token punctuation">;</span>    <span class="token comment">//普通队列的名称</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> NORMAL_QUEUE <span class="token operator">=</span> <span class="token string">"normal_queue"</span><span class="token punctuation">;</span>    <span class="token comment">//死信队列的名称</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> DEAD_QUEUE <span class="token operator">=</span> <span class="token string">"dead_queue"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token class-name">Channel</span> channel <span class="token operator">=</span> <span class="token class-name">RabbitMQUtils</span><span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//声明死信和普通交换机，类型为direct</span>        channel<span class="token punctuation">.</span><span class="token function">exchangeDeclare</span><span class="token punctuation">(</span>NORMAL_EXCHANGE<span class="token punctuation">,</span> <span class="token class-name">BuiltinExchangeType</span><span class="token punctuation">.</span>DIRECT<span class="token punctuation">)</span><span class="token punctuation">;</span>        channel<span class="token punctuation">.</span><span class="token function">exchangeDeclare</span><span class="token punctuation">(</span>DEAD_EXCHANGE<span class="token punctuation">,</span> <span class="token class-name">BuiltinExchangeType</span><span class="token punctuation">.</span>DIRECT<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//声明普通队列</span>        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> arguments <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//过期时间 10s 由生产者指定 更加灵活</span>        <span class="token comment">//arguments.put("x-message-ttl",10000);</span>        <span class="token comment">//正常的队列设置死信交换机</span>        arguments<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"x-dead-letter-exchange"</span><span class="token punctuation">,</span> DEAD_EXCHANGE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//图中红箭头</span>        <span class="token comment">//设置死信routingKey</span>        arguments<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"x-dead-letter-routing-key"</span><span class="token punctuation">,</span> <span class="token string">"lisi"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//设置正常队列长度的限制，例如发送10个消息，6个为正常，4个为死信</span>        arguments<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"x-max-length"</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        channel<span class="token punctuation">.</span><span class="token function">queueDeclare</span><span class="token punctuation">(</span>NORMAL_QUEUE<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/////////////////////////////////////////////////////////////////////////</span>        <span class="token comment">//声明死信队列</span>        channel<span class="token punctuation">.</span><span class="token function">queueDeclare</span><span class="token punctuation">(</span>DEAD_QUEUE<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//绑定普通的交换机与队列</span>        channel<span class="token punctuation">.</span><span class="token function">queueBind</span><span class="token punctuation">(</span>NORMAL_QUEUE<span class="token punctuation">,</span> NORMAL_EXCHANGE<span class="token punctuation">,</span> <span class="token string">"zhangsan"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//绑定死信的交换机与死信的队列</span>        channel<span class="token punctuation">.</span><span class="token function">queueBind</span><span class="token punctuation">(</span>DEAD_QUEUE<span class="token punctuation">,</span> DEAD_EXCHANGE<span class="token punctuation">,</span> <span class="token string">"lisi"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"等待接收消息..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">DeliverCallback</span> deliverCallback <span class="token operator">=</span> <span class="token punctuation">(</span>consumerTag<span class="token punctuation">,</span> message<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Consumer01接受的消息是："</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        channel<span class="token punctuation">.</span><span class="token function">basicConsume</span><span class="token punctuation">(</span>NORMAL_QUEUE<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> deliverCallback<span class="token punctuation">,</span> consumerTag <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><div class="note success no-icon"><p><strong>注意</strong></p><p>因为参数改变了，所以需要把原先队列删除</p></div><ol start="3"><li>C2 消费者代码不变</li></ol><img src="/2022/09/27/rabbitmq-bi-ji/45.png" class=""><h4 id="死信消息被拒"><a href="#死信消息被拒" class="headerlink" title="死信消息被拒"></a>死信消息被拒</h4><ol><li>消息生产者代码同上生产者一致</li><li>需求：消费者 C1 拒收消息 “info5”，开启手动应答</li></ol><p><strong>消费者C1</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Consumer01</span> <span class="token punctuation">{</span>    <span class="token comment">//普通交换机的名称</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> NORMAL_EXCHANGE <span class="token operator">=</span> <span class="token string">"normal_exchange"</span><span class="token punctuation">;</span>    <span class="token comment">//死信交换机的名称</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> DEAD_EXCHANGE <span class="token operator">=</span> <span class="token string">"dead_exchange"</span><span class="token punctuation">;</span>    <span class="token comment">//普通队列的名称</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> NORMAL_QUEUE <span class="token operator">=</span> <span class="token string">"normal_queue"</span><span class="token punctuation">;</span>    <span class="token comment">//死信队列的名称</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> DEAD_QUEUE <span class="token operator">=</span> <span class="token string">"dead_queue"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token class-name">Channel</span> channel <span class="token operator">=</span> <span class="token class-name">RabbitMQUtils</span><span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//声明死信和普通交换机，类型为direct</span>        channel<span class="token punctuation">.</span><span class="token function">exchangeDeclare</span><span class="token punctuation">(</span>NORMAL_EXCHANGE<span class="token punctuation">,</span> <span class="token class-name">BuiltinExchangeType</span><span class="token punctuation">.</span>DIRECT<span class="token punctuation">)</span><span class="token punctuation">;</span>        channel<span class="token punctuation">.</span><span class="token function">exchangeDeclare</span><span class="token punctuation">(</span>DEAD_EXCHANGE<span class="token punctuation">,</span> <span class="token class-name">BuiltinExchangeType</span><span class="token punctuation">.</span>DIRECT<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//声明普通队列</span>        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> arguments <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//过期时间 10s 由生产者指定 更加灵活</span>        <span class="token comment">//arguments.put("x-message-ttl",10000);</span>        <span class="token comment">//正常的队列设置死信交换机</span>        arguments<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"x-dead-letter-exchange"</span><span class="token punctuation">,</span> DEAD_EXCHANGE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//图中红箭头</span>        <span class="token comment">//设置死信routingKey</span>        arguments<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"x-dead-letter-routing-key"</span><span class="token punctuation">,</span> <span class="token string">"lisi"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//设置正常队列长度的限制，例如发送10个消息，6个为正常，4个为死信</span>        <span class="token comment">//arguments.put("x-max-length",6);</span>        channel<span class="token punctuation">.</span><span class="token function">queueDeclare</span><span class="token punctuation">(</span>NORMAL_QUEUE<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/////////////////////////////////////////////////////////////////////////</span>        <span class="token comment">//声明死信队列</span>        channel<span class="token punctuation">.</span><span class="token function">queueDeclare</span><span class="token punctuation">(</span>DEAD_QUEUE<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//绑定普通的交换机与队列</span>        channel<span class="token punctuation">.</span><span class="token function">queueBind</span><span class="token punctuation">(</span>NORMAL_QUEUE<span class="token punctuation">,</span> NORMAL_EXCHANGE<span class="token punctuation">,</span> <span class="token string">"zhangsan"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//绑定死信的交换机与死信的队列</span>        channel<span class="token punctuation">.</span><span class="token function">queueBind</span><span class="token punctuation">(</span>DEAD_QUEUE<span class="token punctuation">,</span> DEAD_EXCHANGE<span class="token punctuation">,</span> <span class="token string">"lisi"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"等待接收消息..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">DeliverCallback</span> deliverCallback <span class="token operator">=</span> <span class="token punctuation">(</span>consumerTag<span class="token punctuation">,</span> message<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>            <span class="token class-name">String</span> msg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>msg<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"info5"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Consumer01接受的消息是："</span> <span class="token operator">+</span> msg <span class="token operator">+</span> <span class="token string">"： 此消息是被C1拒绝的"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">//requeue 设置为 false 代表拒绝重新入队 该队列如果配置了死信交换机将发送到死信队列中</span>                channel<span class="token punctuation">.</span><span class="token function">basicReject</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">getEnvelope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDeliveryTag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Consumer01接受的消息是："</span> <span class="token operator">+</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>                channel<span class="token punctuation">.</span><span class="token function">basicAck</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">getEnvelope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDeliveryTag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token comment">//开启手动应答</span>        channel<span class="token punctuation">.</span><span class="token function">basicConsume</span><span class="token punctuation">(</span>NORMAL_QUEUE<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> deliverCallback<span class="token punctuation">,</span> consumerTag <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><img src="/2022/09/27/rabbitmq-bi-ji/46.png" class=""><img src="/2022/09/27/rabbitmq-bi-ji/47.png" class=""><h2 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h2><h3 id="延迟队列介绍"><a href="#延迟队列介绍" class="headerlink" title="延迟队列介绍"></a>延迟队列介绍</h3><p><strong>延迟队列概念：</strong></p><p>延时队列,队列内部是有序的，最重要的特性就体现在它的延时属性上，延时队列中的元素是希望 在指定时间到了以后或之前取出和处理，简单来说，延时队列就是用来存放需要在指定时间被处理的 元素的队列。</p><p><strong>延迟队列使用场景：</strong></p><ol><li>订单在十分钟之内未支付则自动取消</li><li>新创建的店铺，如果在十天内都没有上传过商品，则自动发送消息提醒</li><li>用户注册成功后，如果三天内没有登陆则进行短信提醒</li><li>用户发起退款，如果三天内没有得到处理则通知相关运营人员</li><li>预定会议后，需要在预定的时间点前十分钟通知各个与会人员参加会议</li></ol><p>这些场景都有一个特点，需要在某个事件发生之后或者之前的指定时间点完成某一项任务，如： 发生订单生成事件，在十分钟之后检查该订单支付状态，然后将未支付的订单进行关闭；那我们一直轮询数据，每秒查一次，取出需要被处理的数据，然后处理不就完事了吗？</p><p>如果数据量比较少，确实可以这样做，比如：对于「如果账单一周内未支付则进行自动结算」这样的需求， 如果对于时间不是严格限制，而是宽松意义上的一周，那么每天晚上跑个定时任务检查一下所有未支付的账单，确实也是一个可行的方案。但对于数据量比较大，并且时效性较强的场景，如：「订单十分钟内未支付则关闭」，短期内未支付的订单数据可能会有很多，活动期间甚至会达到百万甚至千万级别，对这么庞大的数据量仍旧使用轮询的方式显然是不可取的，很可能在一秒内无法完成所有订单的检查，同时会给数据库带来很大压力，无法满足业务要求而且性能低下。</p><img src="/2022/09/27/rabbitmq-bi-ji/48.png" class=""><h3 id="TTL的两种设置"><a href="#TTL的两种设置" class="headerlink" title="TTL的两种设置"></a>TTL的两种设置</h3><p>TTL 是什么呢？TTL 是 RabbitMQ 中一个消息或者队列的属性，表明一条消息或者该队列中的所有消息的最大存活时间，单位是毫秒。</p><p>换句话说，如果一条消息设置了 TTL 属性或者进入了设置 TTL 属性的队列，那么这条消息如果在 TTL 设置的时间内没有被消费，则会成为「死信」。如果同时配置了队列的 TTL 和消息的 TTL，那么较小的那个值将会被使用，有两种方式设置 TTL。</p><p><strong>队列设置 TTL</strong></p><p>在创建队列的时候设置队列的 x-message-ttl 属性</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> params <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>params<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"x-message-ttl"</span><span class="token punctuation">,</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token class-name">QueueBuilder</span><span class="token punctuation">.</span><span class="token function">durable</span><span class="token punctuation">(</span><span class="token string">"QA"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">withArguments</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// QA 队列的最大存活时间位 5000 毫秒</span></code></pre><p><strong>消息设置 TTL</strong></p><p>针对每条消息设置 TTL</p><pre class="language-java" data-language="java"><code class="language-java">rabbitTemplate<span class="token punctuation">.</span><span class="token function">converAndSend</span><span class="token punctuation">(</span><span class="token string">"X"</span><span class="token punctuation">,</span><span class="token string">"XC"</span><span class="token punctuation">,</span>message<span class="token punctuation">,</span>correlationData <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>    correlationData<span class="token punctuation">.</span><span class="token function">getMessageProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setExpiration</span><span class="token punctuation">(</span><span class="token string">"5000"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>两者区别</strong></p><p>如果设置了队列的 TTL 属性，那么一旦消息过期，就会被队列丢弃(如果配置了死信队列被丢到死信队列中)，而第二种方式，消息即使过期，也不一定会被马上丢弃，因为消息是否过期是在即将投递到消费者之前判定的，如果当前队列有严重的消息积压情况，则已过期的消息也许还能存活较长时间，具体看下方案例。</p><p>另外，还需要注意的一点是，如果不设置 TTL，表示消息永远不会过期，如果将 TTL 设置为 0，则表示除非此时可以直接投递该消息到消费者，否则该消息将会被丢弃</p><h3 id="整合SpringBoot"><a href="#整合SpringBoot" class="headerlink" title="整合SpringBoot"></a>整合SpringBoot</h3><ol><li>创建SpringBoot工程，添加依赖</li></ol><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">&gt;</span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.alibaba<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>fastjson<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.2.47<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.projectlombok<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>lombok<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!--RabbitMQ 依赖--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-amqp<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span></code></pre><ol start="2"><li>修改配置文件</li></ol><pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">server</span><span class="token punctuation">:</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8088</span><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">rabbitmq</span><span class="token punctuation">:</span>    <span class="token key atrule">host</span><span class="token punctuation">:</span> 192.168.42.53    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">5672</span>    <span class="token key atrule">username</span><span class="token punctuation">:</span> admin    <span class="token key atrule">password</span><span class="token punctuation">:</span> woniu123</code></pre><h3 id="代码架构图"><a href="#代码架构图" class="headerlink" title="代码架构图"></a>代码架构图</h3><p>创建两个队列 QA 和 QB，两个队列的 TTL 分别设置为 10S 和 40S，然后再创建一个交换机 X 和死信交换机 Y，它们的类型都是 direct，创建一个死信队列 QD，它们的绑定关系如下：</p><img src="/2022/09/27/rabbitmq-bi-ji/49.png" class=""><p>原先配置队列信息，写在了生产者和消费者代码中，现在可写在配置类中，生产者只发消息，消费者只接受消息</p><p><strong>配置类代码</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TtlQueueConfig</span> <span class="token punctuation">{</span>    <span class="token comment">//普通交换机的名称</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> X_EXCHANGE <span class="token operator">=</span> <span class="token string">"X"</span><span class="token punctuation">;</span>    <span class="token comment">//死信交换机的名称</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> Y_DEAD_LETTER_EXCHANGE <span class="token operator">=</span> <span class="token string">"Y"</span><span class="token punctuation">;</span>    <span class="token comment">//普通队列的名称</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> QUEUE_A <span class="token operator">=</span> <span class="token string">"QA"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> QUEUE_B <span class="token operator">=</span> <span class="token string">"QB"</span><span class="token punctuation">;</span>    <span class="token comment">//死信队列的名称</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> DEAD_LETTER_QUEUE <span class="token operator">=</span> <span class="token string">"QD"</span><span class="token punctuation">;</span>    <span class="token comment">//声明xExchange  别名</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span><span class="token string">"xExchange"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">DirectExchange</span> <span class="token function">xExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">DirectExchange</span><span class="token punctuation">(</span>X_EXCHANGE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//声明yExchange 别名</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span><span class="token string">"yExchange"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">DirectExchange</span> <span class="token function">yExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">DirectExchange</span><span class="token punctuation">(</span>Y_DEAD_LETTER_EXCHANGE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//声明普通队列  要有ttl 为10s</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span><span class="token string">"queueA"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">Queue</span> <span class="token function">queueA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> arguments <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//设置死信交换机</span>        arguments<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"x-dead-letter-exchange"</span><span class="token punctuation">,</span> Y_DEAD_LETTER_EXCHANGE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//设置死信RoutingKey</span>        arguments<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"x-dead-letter-routing-key"</span><span class="token punctuation">,</span> <span class="token string">"YD"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//设置TTL 10s 单位是ms</span>        arguments<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"x-message-ttl"</span><span class="token punctuation">,</span> <span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token class-name">QueueBuilder</span><span class="token punctuation">.</span><span class="token function">durable</span><span class="token punctuation">(</span>QUEUE_A<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">withArguments</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//声明普通队列  要有ttl 为40s</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span><span class="token string">"queueB"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">Queue</span> <span class="token function">queueB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> arguments <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//设置死信交换机</span>        arguments<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"x-dead-letter-exchange"</span><span class="token punctuation">,</span> Y_DEAD_LETTER_EXCHANGE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//设置死信RoutingKey</span>        arguments<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"x-dead-letter-routing-key"</span><span class="token punctuation">,</span> <span class="token string">"YD"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//设置TTL 10s 单位是ms</span>        arguments<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"x-message-ttl"</span><span class="token punctuation">,</span> <span class="token number">40000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token class-name">QueueBuilder</span><span class="token punctuation">.</span><span class="token function">durable</span><span class="token punctuation">(</span>QUEUE_B<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">withArguments</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//声明死信队列  要有ttl 为40s</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span><span class="token string">"queueD"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">Queue</span> <span class="token function">queueD</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">QueueBuilder</span><span class="token punctuation">.</span><span class="token function">durable</span><span class="token punctuation">(</span>DEAD_LETTER_QUEUE<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//声明队列 QA 绑定 X 交换机</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">Binding</span> <span class="token function">queueABindingX</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">"queueA"</span><span class="token punctuation">)</span> <span class="token class-name">Queue</span> queueA<span class="token punctuation">,</span>                                  <span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">"xExchange"</span><span class="token punctuation">)</span> <span class="token class-name">DirectExchange</span> xExchange<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">BindingBuilder</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>queueA<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">to</span><span class="token punctuation">(</span>xExchange<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">with</span><span class="token punctuation">(</span><span class="token string">"XA"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//声明队列 QB 绑定 X 交换机</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">Binding</span> <span class="token function">queueBBindingX</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">"queueB"</span><span class="token punctuation">)</span> <span class="token class-name">Queue</span> queueB<span class="token punctuation">,</span>                                  <span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">"xExchange"</span><span class="token punctuation">)</span> <span class="token class-name">DirectExchange</span> xExchange<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">BindingBuilder</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>queueB<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">to</span><span class="token punctuation">(</span>xExchange<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">with</span><span class="token punctuation">(</span><span class="token string">"XB"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//声明队列 QD 绑定 Y 交换机</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">Binding</span> <span class="token function">queueDBindingY</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">"queueD"</span><span class="token punctuation">)</span> <span class="token class-name">Queue</span> queueD<span class="token punctuation">,</span>                                  <span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">"yExchange"</span><span class="token punctuation">)</span> <span class="token class-name">DirectExchange</span> yExchange<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">BindingBuilder</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>queueD<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">to</span><span class="token punctuation">(</span>yExchange<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">with</span><span class="token punctuation">(</span><span class="token string">"YD"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>生产者</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Slf4j</span><span class="token annotation punctuation">@RestController</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/ttl"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SendMsgController</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">RabbitTemplate</span> rabbitTemplate<span class="token punctuation">;</span>    <span class="token comment">//开始发消息</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/sendMsg/{message}"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sendMsg</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"message"</span><span class="token punctuation">)</span> <span class="token class-name">String</span> message<span class="token punctuation">)</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"当前时间:{},发送一条信息给两个TTL队列：{}"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>        rabbitTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span><span class="token string">"X"</span><span class="token punctuation">,</span> <span class="token string">"XA"</span><span class="token punctuation">,</span> <span class="token string">"消息来自ttl为10s的队列:"</span> <span class="token operator">+</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>        rabbitTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span><span class="token string">"X"</span><span class="token punctuation">,</span> <span class="token string">"XB"</span><span class="token punctuation">,</span> <span class="token string">"消息来自ttl为40s的队列:"</span> <span class="token operator">+</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>消费者</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Slf4j</span><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DeadLetterQueueConsumer</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>queues <span class="token operator">=</span> <span class="token string">"QD"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">receiveD</span><span class="token punctuation">(</span><span class="token class-name">Message</span> message<span class="token punctuation">,</span> <span class="token class-name">Channel</span> channel<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>        <span class="token class-name">String</span> msg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"当前时间：{},收到死信队列信息{}"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>发起一个请求：<a href="http://localhost:8088/ttl/sendMsg/%E5%98%BB%E5%98%BB%E5%98%BB">http://localhost:8088/ttl/sendMsg/嘻嘻嘻</a></p><img src="/2022/09/27/rabbitmq-bi-ji/50.png" class=""><p>第一条消息在 10S 后变成了死信消息，然后被消费者消费掉，第二条消息在 40S 之后变成了死信消息， 然后被消费掉，这样一个延时队列就打造完成了。</p><p>不过，如果这样使用的话，岂不是每增加一个新的时间需求，就要新增一个队列，这里只有 10S 和 40S 两个时间选项，如果需要一个小时后处理，那么就需要增加 TTL 为一个小时的队列，如果是预定会议室然后提前通知这样的场景，岂不是要增加无数个队列才能满足需求？</p><h3 id="延时队列TTL优化"><a href="#延时队列TTL优化" class="headerlink" title="延时队列TTL优化"></a>延时队列TTL优化</h3><p>在这里新增了一个队列 QC，该队列不设置 TTL 时间，根据前端的请求确定 TTL 时间，绑定关系如下：</p><img src="/2022/09/27/rabbitmq-bi-ji/51.png" class=""><p><strong>配置类代码</strong></p><p>新增一个配置文件类，用于新增队列 QC，也可以放在上方的配置文件类里</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MsgTtlQueueConfig</span> <span class="token punctuation">{</span>    <span class="token comment">//普通队列的名称</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> QUEUE_C <span class="token operator">=</span> <span class="token string">"QC"</span><span class="token punctuation">;</span>    <span class="token comment">//死信交换机的名称</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> Y_DEAD_LETTER_EXCHANGE <span class="token operator">=</span> <span class="token string">"Y"</span><span class="token punctuation">;</span>    <span class="token comment">//声明QC</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span><span class="token string">"queueC"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">Queue</span> <span class="token class-name">QueueC</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> arguments <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//设置死信交换机</span>        arguments<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"x-dead-letter-exchange"</span><span class="token punctuation">,</span> Y_DEAD_LETTER_EXCHANGE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//设置死信RoutingKey</span>        arguments<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"x-dead-letter-routing-key"</span><span class="token punctuation">,</span> <span class="token string">"YD"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token class-name">QueueBuilder</span><span class="token punctuation">.</span><span class="token function">durable</span><span class="token punctuation">(</span>QUEUE_C<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">withArguments</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//声明队列 QC 绑定 X 交换机</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">Binding</span> <span class="token function">queueCBindingX</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">"queueC"</span><span class="token punctuation">)</span> <span class="token class-name">Queue</span> queueC<span class="token punctuation">,</span>                                  <span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">"xExchange"</span><span class="token punctuation">)</span> <span class="token class-name">DirectExchange</span> xExchange<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">BindingBuilder</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>queueC<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">to</span><span class="token punctuation">(</span>xExchange<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">with</span><span class="token punctuation">(</span><span class="token string">"XC"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>生产者</strong></p><p>Controller新增一个方法</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Slf4j</span><span class="token annotation punctuation">@RestController</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/ttl"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SendMsgController</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">RabbitTemplate</span> rabbitTemplate<span class="token punctuation">;</span>    <span class="token comment">//开始发消息</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/sendMsg/{message}"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sendMsg</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"message"</span><span class="token punctuation">)</span> <span class="token class-name">String</span> message<span class="token punctuation">)</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"当前时间:{},发送一条信息给两个TTL队列：{}"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>        rabbitTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span><span class="token string">"X"</span><span class="token punctuation">,</span> <span class="token string">"XA"</span><span class="token punctuation">,</span> <span class="token string">"消息来自ttl为10s的队列:"</span> <span class="token operator">+</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>        rabbitTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span><span class="token string">"X"</span><span class="token punctuation">,</span> <span class="token string">"XB"</span><span class="token punctuation">,</span> <span class="token string">"消息来自ttl为40s的队列:"</span> <span class="token operator">+</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//开始发消息 发TTL</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/sendExpirationMsg/{message}/{ttlTime}"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sendMsg</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"message"</span><span class="token punctuation">)</span> <span class="token class-name">String</span> message<span class="token punctuation">,</span>                        <span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"ttlTime"</span><span class="token punctuation">)</span> <span class="token class-name">String</span> ttlTime<span class="token punctuation">)</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"当前时间:{},发送一条时长是{}毫秒TTL信息给队列QC：{}"</span><span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ttlTime<span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>        rabbitTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span><span class="token string">"X"</span><span class="token punctuation">,</span> <span class="token string">"XC"</span><span class="token punctuation">,</span> message<span class="token punctuation">,</span> msg <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>            <span class="token comment">//发送消息的时候的延迟时长</span>            msg<span class="token punctuation">.</span><span class="token function">getMessageProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setExpiration</span><span class="token punctuation">(</span>ttlTime<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> msg<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>发送两个请求：</p><p><a href="http://localhost:8088/ttl/sendExpirationMsg/%E4%BD%A0%E5%A5%BD1/20000">http://localhost:8088/ttl/sendExpirationMsg/你好1/20000</a></p><p><a href="http://localhost:8088/ttl/sendExpirationMsg/%E4%BD%A0%E5%A5%BD2/2000">http://localhost:8088/ttl/sendExpirationMsg/你好2/2000</a></p><div class="note danger no-icon"><p><strong>出现问题：</strong></p><img src="/2022/09/27/rabbitmq-bi-ji/52.png" class=""></div><p>看起来似乎没什么问题，但是在最开始的时候，就介绍过如果使用在消息属性上设置 TTL 的方式，消息可能并不会按时「死亡」</p><div class="note danger no-icon"><p>因为 RabbitMQ 只会检查第一个消息是否过期，如果过期则丢到死信队列， 如果第一个消息的延时时长很长，而第二个消息的延时时长很短，第二个消息并不会优先得到执行</p></div><h3 id="RabbitMQ插件实现延迟队列"><a href="#RabbitMQ插件实现延迟队列" class="headerlink" title="RabbitMQ插件实现延迟队列"></a>RabbitMQ插件实现延迟队列</h3><p>上文中提到的问题，确实是一个问题，如果不能实现在消息粒度上的 TTL，并使其在设置的 TTL 时间及时死亡，就无法设计成一个通用的延时队列。那如何解决呢，接下来我们就去解决该问题。</p><p><strong>安装延时队列插件</strong></p><p>可去<a href="https://www.rabbitmq.com/community-plugins.html">官网下载 </a>找到 <strong>rabbitmq_delayed_message_exchange</strong> 插件，放置到 RabbitMQ 的插件目录。</p><p>因为官网也是跳转去该插件的 GitHub 地址进行下载：<a href="https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/releases">点击跳转</a></p><p>将插件上传到 RabbitMQ 的安装目录下的 plgins 目录</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># RabbitMQ 的 plgins 所在目录</span><span class="token builtin class-name">cd</span> /usr/lib/rabbitmq/lib/rabbitmq_server-3.8.5/plugins</code></pre><p>入目录后执行下面命令让该插件生效，然后重启 RabbitMQ</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 安装</span>rabbitmq-plugins <span class="token builtin class-name">enable</span> rabbitmq_delayed_message_exchange<span class="token comment"># 重启服务</span>systemctl restart rabbitmq-server</code></pre><p>打开 Web 界面，查看交换机的新增功能列表，如果多出了如图所示，代表成功添加插件</p><img src="/2022/09/27/rabbitmq-bi-ji/53.png" class=""><p><strong>插件实战</strong></p><p>在这里新增了一个队列 delayed.queue，一个自定义交换机 delayed.exchange，绑定关系如下:</p><img src="/2022/09/27/rabbitmq-bi-ji/55.png" class=""><p><strong>配置类代码</strong></p><p>新增一个配置类 <code>DelayedQueueConfig</code>，也可以放在原来的配置文件里，代码里使用了 <code>CustomExchange</code> 类，通过参数来自定义一个类型(direct、topic等)</p><p>在我们自定义的交换机中，这是一种新的交换类型，该类型消息支持延迟投递机制消息传递后并不会立即投递到目标队列中，而是存储在 mnesia(一个分布式数据系统)表中，当达到投递时间时，才投递到目标队列中。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DelayedQueueConfig</span> <span class="token punctuation">{</span>    <span class="token comment">//交换机</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> DELAYED_EXCHANGE_NAME <span class="token operator">=</span> <span class="token string">"delayed.exchange"</span><span class="token punctuation">;</span>    <span class="token comment">//队列</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> DELAYED_QUEUE_NAME <span class="token operator">=</span> <span class="token string">"delayed.queue"</span><span class="token punctuation">;</span>    <span class="token comment">//routingKey</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> DELAYED_ROUTING_KEY <span class="token operator">=</span> <span class="token string">"delayed.routingkey"</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">Queue</span> <span class="token function">delayedQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token punctuation">(</span>DELAYED_QUEUE_NAME<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//声明交换机,基于插件的交换机</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">CustomExchange</span> <span class="token function">delayedExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> arguments <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        arguments<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"x-delayed-type"</span><span class="token punctuation">,</span> <span class="token string">"direct"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/**         * 1.交换机的名称         * 2.交换机的类型 x-delayed-message         * 3.是否需要持久化         * 4.是否需要自动删除         * 5.其他的参数         */</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">CustomExchange</span><span class="token punctuation">(</span>DELAYED_EXCHANGE_NAME<span class="token punctuation">,</span> <span class="token string">"x-delayed-message"</span><span class="token punctuation">,</span>                <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//绑定</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">Binding</span> <span class="token function">delayedQueueBindingDelayedExchange</span><span class="token punctuation">(</span>            <span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">"delayedQueue"</span><span class="token punctuation">)</span> <span class="token class-name">Queue</span> delayedQueue<span class="token punctuation">,</span>            <span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">"delayedExchange"</span><span class="token punctuation">)</span> <span class="token class-name">CustomExchange</span> delayedExchange<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">BindingBuilder</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>delayedQueue<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">to</span><span class="token punctuation">(</span>delayedExchange<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token keyword">with</span><span class="token punctuation">(</span>DELAYED_ROUTING_KEY<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">noargs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>生产者代码</strong></p><p>在 controller 里新增一个方法</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">//开始发消息，基于插件的 消息及 延迟的时间</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/sendDelayMsg/{message}/{delayTime}"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sendMsg</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"message"</span><span class="token punctuation">)</span> <span class="token class-name">String</span> message<span class="token punctuation">,</span>                        <span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"delayTime"</span><span class="token punctuation">)</span> <span class="token class-name">Integer</span> delayTime<span class="token punctuation">)</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"当前时间:{},发送一条时长是{}毫秒TTL信息给延迟队列delayed.queue：{}"</span><span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> delayTime<span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>        rabbitTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span><span class="token class-name">DelayedQueueConfig</span><span class="token punctuation">.</span>DELAYED_EXCHANGE_NAME<span class="token punctuation">,</span>                <span class="token class-name">DelayedQueueConfig</span><span class="token punctuation">.</span>DELAYED_ROUTING_KEY<span class="token punctuation">,</span> message<span class="token punctuation">,</span> msg <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>                    <span class="token comment">//发送消息的时候的延迟时长 单位ms</span>                    msg<span class="token punctuation">.</span><span class="token function">getMessageProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setDelay</span><span class="token punctuation">(</span>delayTime<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> msg<span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p><strong>消费者代码</strong></p><p>监听延时队列，如果有消息进入该队列，则打印到控制台</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Slf4j</span><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DelayQueueConsumer</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>queues <span class="token operator">=</span> <span class="token class-name">DelayedQueueConfig</span><span class="token punctuation">.</span>DELAYED_QUEUE_NAME<span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">receiveDelayQueue</span><span class="token punctuation">(</span><span class="token class-name">Message</span> message<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">String</span> msg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"当前时间：{},收到延时队列的消息：{}"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><a href="http://localhost:8088/ttl/sendDelayMsg/hello1/20000">http://localhost:8088/ttl/sendDelayMsg/hello1/20000</a></p><p><a href="http://localhost:8088/ttl/sendDelayMsg/hello2/2000">http://localhost:8088/ttl/sendDelayMsg/hello2/2000</a></p><img src="/2022/09/27/rabbitmq-bi-ji/55.png" class=""><p>可以看到哪怕 hello1 需要20秒再进入延时队列，hello2 2 秒后直接进入延时队列，无需等待 hello1</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>延时队列在需要延时处理的场景下非常有用，使用 RabbitMQ 来实现延时队列可以很好的利用 RabbitMQ 的特性，如：消息可靠发送、消息可靠投递、死信队列来保障消息至少被消费一次以及未被正确处理的消息不会被丢弃。另外，通过 RabbitMQ 集群的特性，可以很好的解决单点故障问题，不会因为单个节点挂掉导致延时队列不可用或者消息丢失。</p><p>当然，延时队列还有很多其它选择，比如利用 Java 的 DelayQueue，利用 Redis 的 zset，利用 Quartz 或者利用 kafka 的时间轮，这些方式各有特点,看需要适用的场景。</p><h2 id="发布确认高级"><a href="#发布确认高级" class="headerlink" title="发布确认高级"></a>发布确认高级</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>首先发布消息后进行备份在缓存里，如果消息成功发布确认到交换机，则从缓存里删除该消息，如果没有成功发布，则设置一个定时任务，重新从缓存里获取消息发布到交换机，直到成功发布到交换机。</p><p>确认机制图例：</p><img src="/2022/09/27/rabbitmq-bi-ji/56.png" class=""><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>一个交换机：confirm.exchange，一个队列：confirm.queue，一个消费者：confirm.consumer</p><p>其中交换机类型时 direct，与队列关联的 routingKey 是 key1</p><p>代码架构图：</p><img src="/2022/09/27/rabbitmq-bi-ji/57.png" class=""><p>在配置文件当中需要添加：<code>publisher-confirm-type: correlated</code></p><pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">server</span><span class="token punctuation">:</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8088</span><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">rabbitmq</span><span class="token punctuation">:</span>    <span class="token key atrule">host</span><span class="token punctuation">:</span> 192.168.42.53    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">5672</span>    <span class="token key atrule">username</span><span class="token punctuation">:</span> admin    <span class="token key atrule">password</span><span class="token punctuation">:</span> woniu123    <span class="token key atrule">publisher-confirm-type</span><span class="token punctuation">:</span> correlated</code></pre><ul><li><code>NONE</code> 值是禁用发布确认模式，是默认值</li><li><code>CORRELATED</code> 值是发布消息成功到交换器后会触发回调方法</li><li><code>SIMPLE</code> 值经测试有两种效果，其一效果和 CORRELATED 值一样会触发回调方法，其二在发布消息成功后使用 rabbitTemplate 调用 waitForConfirms 或 waitForConfirmsOrDie 方法等待 broker 节点返回发送结果，根据返回结果来判定下一步的逻辑，要注意的点是 waitForConfirmsOrDie 方法如果返回 false 则会关闭 channel，则接下来无法发送消息到 broker;</li></ul><h3 id="添加配置类"><a href="#添加配置类" class="headerlink" title="添加配置类"></a>添加配置类</h3><p>声明交换机和队列，并且将交换机和队列进行绑定</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConfirmConfig</span> <span class="token punctuation">{</span>    <span class="token comment">//交换机</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> CONFIRM_EXCHANGE_NAME <span class="token operator">=</span> <span class="token string">"confirm_exchange"</span><span class="token punctuation">;</span>    <span class="token comment">//队列</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> CONFIRM_QUEUE_NAME <span class="token operator">=</span> <span class="token string">"confirm_queue"</span><span class="token punctuation">;</span>    <span class="token comment">//routingKey</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> CONFIRM_ROUTING_KEY <span class="token operator">=</span> <span class="token string">"key1"</span><span class="token punctuation">;</span>    <span class="token comment">//声明交换机</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span><span class="token string">"confirmExchange"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">DirectExchange</span> <span class="token function">confirmExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">DirectExchange</span><span class="token punctuation">(</span>CONFIRM_EXCHANGE_NAME<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//声明队列</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span><span class="token string">"confirmQueue"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">Queue</span> <span class="token function">confirmQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">QueueBuilder</span><span class="token punctuation">.</span><span class="token function">durable</span><span class="token punctuation">(</span>CONFIRM_QUEUE_NAME<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//绑定</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">Binding</span> <span class="token function">queueBindingExchange</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">"confirmQueue"</span><span class="token punctuation">)</span> <span class="token class-name">Queue</span> confirmQueue<span class="token punctuation">,</span>                                        <span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">"confirmExchange"</span><span class="token punctuation">)</span> <span class="token class-name">DirectExchange</span> confirmExchange<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">BindingBuilder</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>confirmQueue<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">to</span><span class="token punctuation">(</span>confirmExchange<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">with</span><span class="token punctuation">(</span>CONFIRM_ROUTING_KEY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="消息生产者-1"><a href="#消息生产者-1" class="headerlink" title="消息生产者"></a>消息生产者</h3><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Slf4j</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/confirm"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@RestController</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProductController</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">RabbitTemplate</span> rabbitTemplate<span class="token punctuation">;</span>    <span class="token comment">//开始发消息,测试确认</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/sendMessage/{message}"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sendMessage</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"message"</span><span class="token punctuation">)</span> <span class="token class-name">String</span> message<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//指定消息 id 为 1</span>        <span class="token class-name">CorrelationData</span> correlationData1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CorrelationData</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        rabbitTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span><span class="token class-name">ConfirmConfig</span><span class="token punctuation">.</span>CONFIRM_EXCHANGE_NAME<span class="token punctuation">,</span>                <span class="token class-name">ConfirmConfig</span><span class="token punctuation">.</span>CONFIRM_ROUTING_KEY<span class="token punctuation">,</span> message <span class="token operator">+</span> <span class="token string">"key1"</span><span class="token punctuation">,</span> correlationData1<span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"发送消息内容:{}"</span><span class="token punctuation">,</span> message <span class="token operator">+</span> <span class="token string">"key1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//指定消息 id 为 2</span>        <span class="token class-name">CorrelationData</span> correlationData2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CorrelationData</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> CONFIRM_ROUTING_KEY <span class="token operator">=</span> <span class="token string">"key2"</span><span class="token punctuation">;</span>        rabbitTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span><span class="token class-name">ConfirmConfig</span><span class="token punctuation">.</span>CONFIRM_EXCHANGE_NAME<span class="token punctuation">,</span>                CONFIRM_ROUTING_KEY<span class="token punctuation">,</span> message <span class="token operator">+</span> <span class="token string">"key2"</span><span class="token punctuation">,</span> correlationData2<span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"发送消息内容:{}"</span><span class="token punctuation">,</span> message <span class="token operator">+</span> <span class="token string">"key2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="消息消费者-1"><a href="#消息消费者-1" class="headerlink" title="消息消费者"></a>消息消费者</h3><p>监听 <code>confirm.queue</code> 队列</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Slf4j</span><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Consumer</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>queues <span class="token operator">=</span> <span class="token class-name">ConfirmConfig</span><span class="token punctuation">.</span>CONFIRM_QUEUE_NAME<span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">receiveConfirmMessage</span><span class="token punctuation">(</span><span class="token class-name">Message</span> message<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">String</span> msg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"接受到的队列confirm.queue消息:{}"</span><span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="消息生产者发布消息后的回调接口"><a href="#消息生产者发布消息后的回调接口" class="headerlink" title="消息生产者发布消息后的回调接口"></a>消息生产者发布消息后的回调接口</h3><p>只要生产者发布消息，交换机不管是否收到消息，都会调用该类的 <code>confirm</code> 方法</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Slf4j</span><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyCallBack</span> <span class="token keyword">implements</span> <span class="token class-name">RabbitTemplate<span class="token punctuation">.</span>ConfirmCallback</span> <span class="token punctuation">{</span>    <span class="token comment">//注入</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">RabbitTemplate</span> rabbitTemplate<span class="token punctuation">;</span>    <span class="token annotation punctuation">@PostConstruct</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//注入</span>        rabbitTemplate<span class="token punctuation">.</span><span class="token function">setConfirmCallback</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 交换机不管是否收到消息的一个回调方法     * 1. 发消息 交换机接收到了 回调     *     * @param correlationData 保存回调信息的Id及相关信息     * @param ack             交换机收到消息 为true     * @param cause           未收到消息的原因     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">confirm</span><span class="token punctuation">(</span><span class="token class-name">CorrelationData</span> correlationData<span class="token punctuation">,</span> <span class="token keyword">boolean</span> ack<span class="token punctuation">,</span> <span class="token class-name">String</span> cause<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">String</span> id <span class="token operator">=</span> correlationData <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">?</span> correlationData<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ack<span class="token punctuation">)</span> <span class="token punctuation">{</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"交换机已经收到了ID为:{}的消息"</span><span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"交换机还未收到ID为:{}的消息，由于原因:{}"</span><span class="token punctuation">,</span> id<span class="token punctuation">,</span> cause<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><a href="http://localhost:8088/confirm/sendMessage/%E5%A4%A7%E5%AE%B6%E5%A5%BD1">http://localhost:8088/confirm/sendMessage/大家好1</a></p><p>结果分析：</p><img src="/2022/09/27/rabbitmq-bi-ji/58.png" class=""><p>可以看到，发送了两条消息，第一条消息的 RoutingKey 为 “key1”，第二条消息的 RoutingKey 为 “key2”，两条消息都成功被交换机接收，也收到了交换机的确认回调，但消费者只收到了一条消息，因为第二条消息的 RoutingKey 与队列的 BindingKey 不一致，也没有其它队列能接收这个消息，所有第二条消息被直接丢弃了。</p><p>丢弃的消息交换机是不知道的，需要解决告诉生产者消息传送失败。</p><h3 id="回退消息"><a href="#回退消息" class="headerlink" title="回退消息"></a>回退消息</h3><p>获取回退的消息，首先在配置文件开启该功能，然后需要自定义类实现 <code>RabbitTemplate.ReturnsCallback</code> 接口，并且初始化时，使用该自定义类作为回退消息的处理类，同时开启 <code>Mandatory</code>，设置为 true</p><p>配置类文件开启：</p><pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># 新版</span><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">rabbitmq</span><span class="token punctuation">:</span>  <span class="token key atrule">template</span><span class="token punctuation">:</span>      <span class="token key atrule">mandatory</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>      <span class="token comment"># 旧版</span><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">rabbitmq</span><span class="token punctuation">:</span>    <span class="token key atrule">mandatory</span><span class="token punctuation">:</span> <span class="token boolean important">true</span></code></pre><p>代码中开启：</p><p><code>rabbitTemplate.setMandatory(true);</code></p><p>在仅开启了生产者确认机制的情况下，交换机接收到消息后，会直接给消息生产者发送确认消息，如果发现该消息不可路由，那么消息会被直接丢弃，此时生产者是不知道消息被丢弃这个事件的。</p><p>那么如何让无法被路由的消息帮我想办法处理一下？最起码通知我一声，我好自己处理啊。通过设置 mandatory 参数可以在当消息传递过程中不可达目的地时将消息返回给生产者。</p><h3 id="实战-1"><a href="#实战-1" class="headerlink" title="实战"></a>实战</h3><p><strong>修改配置文件</strong></p><pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">server</span><span class="token punctuation">:</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8088</span><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">rabbitmq</span><span class="token punctuation">:</span>    <span class="token key atrule">host</span><span class="token punctuation">:</span> 192.168.42.53    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">5672</span>    <span class="token key atrule">username</span><span class="token punctuation">:</span> admin    <span class="token key atrule">password</span><span class="token punctuation">:</span> woniu123    <span class="token key atrule">publisher-confirm-type</span><span class="token punctuation">:</span> correlated    <span class="token key atrule">publisher-returns</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>    <span class="token key atrule">template</span><span class="token punctuation">:</span>      <span class="token key atrule">mandatory</span><span class="token punctuation">:</span> <span class="token boolean important">true</span></code></pre><p><strong>修改回调接口</strong></p><p>实现 <code>RabbitTemplate.ReturnsCallback</code> 接口，并实现方法</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Slf4j</span><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyCallBack</span> <span class="token keyword">implements</span> <span class="token class-name">RabbitTemplate<span class="token punctuation">.</span>ConfirmCallback</span><span class="token punctuation">,</span> <span class="token class-name">RabbitTemplate<span class="token punctuation">.</span>ReturnsCallback</span> <span class="token punctuation">{</span>    <span class="token comment">//注入</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">RabbitTemplate</span> rabbitTemplate<span class="token punctuation">;</span>    <span class="token annotation punctuation">@PostConstruct</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//注入</span>        rabbitTemplate<span class="token punctuation">.</span><span class="token function">setConfirmCallback</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        rabbitTemplate<span class="token punctuation">.</span><span class="token function">setReturnsCallback</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 交换机不管是否收到消息的一个回调方法     * 1. 发消息 交换机接收到了 回调     *     * @param correlationData 保存回调信息的Id及相关信息     * @param ack             交换机收到消息 为true     * @param cause           未收到消息的原因     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">confirm</span><span class="token punctuation">(</span><span class="token class-name">CorrelationData</span> correlationData<span class="token punctuation">,</span> <span class="token keyword">boolean</span> ack<span class="token punctuation">,</span> <span class="token class-name">String</span> cause<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">String</span> id <span class="token operator">=</span> correlationData <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">?</span> correlationData<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ack<span class="token punctuation">)</span> <span class="token punctuation">{</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"交换机已经收到了ID为:{}的消息"</span><span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"交换机还未收到ID为:{}的消息，由于原因:{}"</span><span class="token punctuation">,</span> id<span class="token punctuation">,</span> cause<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">//可以在当消息传递过程中不可达目的地时将消息返回给生产者</span>    <span class="token comment">//只有不可达目的地的时候 才进行回退</span>    <span class="token comment">/**     * 当消息无法路由的时候的回调方法     * message      消息     * replyCode    编码     * replyText    退回原因     * exchange     从哪个交换机退回     * routingKey   通过哪个路由 key 退回     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">returnedMessage</span><span class="token punctuation">(</span><span class="token class-name">ReturnedMessage</span> returned<span class="token punctuation">)</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"消息{},被交换机{}退回，退回原因:{},路由key:{}"</span><span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>returned<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> returned<span class="token punctuation">.</span><span class="token function">getExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                returned<span class="token punctuation">.</span><span class="token function">getReplyText</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> returned<span class="token punctuation">.</span><span class="token function">getRoutingKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>再次访问：<a href="http://localhost:8088/confirm/sendMessage/%E5%A4%A7%E5%AE%B6%E5%A5%BD1">http://localhost:8088/confirm/sendMessage/大家好1</a></p><img src="/2022/09/27/rabbitmq-bi-ji/59.png" class=""><h3 id="备份交换机"><a href="#备份交换机" class="headerlink" title="备份交换机"></a>备份交换机</h3><p><strong>介绍</strong></p><p>有了 mandatory 参数和回退消息，我们获得了对无法投递消息的感知能力，有机会在生产者的消息无法被投递时发现并处理。但有时候，我们并不知道该如何处理这些无法路由的消息，最多打个日志，然后触发报警，再来手动处理。而通过日志来处理这些无法路由的消息是很不优雅的做法，特别是当生产者所在的服务有多台机器的时候，手动复制日志会更加麻烦而且容易出错。而且设置 mandatory 参数会增加生产者的复杂性，需要添加处理这些被退回的消息的逻辑。如果既不想丢失消息，又不想增加生产者的复杂性，该怎么做呢？</p><p>前面在设置死信队列的文章中，我们提到，可以为队列设置死信交换机来存储那些处理失败的消息，可是这些不可路由消息根本没有机会进入到队列，因此无法使用死信队列来保存消息。 在 RabbitMQ 中，有一种备份交换机的机制存在，可以很好的应对这个问题。</p><p>什么是备份交换机呢？备份交换机可以理解为 RabbitMQ 中交换机的“备胎”，当我们为某一个交换机声明一个对应的备份交换机时，就是为它创建一个备胎，当交换机接收到一条不可路由消息时，将会把这条消息转发到备份交换机中，由备份交换机来进行转发和处理，通常备份交换机的类型为 Fanout ，这样就能把所有消息都投递到与其绑定的队列中，然后我们在备份交换机下绑定一个队列，这样所有那些原交换机无法被路由的消息，就会都进 入这个队列了。当然，我们还可以建立一个报警队列，用独立的消费者来进行监测和报警。</p><p><strong>实战</strong></p><p>需要一个备份交换机 <code>backup.exchange</code>，类型为 <code>fanout</code>，该交换机发送消息到队列 <code>backup.queue</code> 和 <code>warning.queue</code></p><p>代码结构图：</p><img src="/2022/09/27/rabbitmq-bi-ji/60.png" class=""><p><strong>修改高级确认发布 配置类</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConfirmConfig</span> <span class="token punctuation">{</span>    <span class="token comment">//交换机</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> CONFIRM_EXCHANGE_NAME <span class="token operator">=</span> <span class="token string">"confirm_exchange"</span><span class="token punctuation">;</span>    <span class="token comment">//队列</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> CONFIRM_QUEUE_NAME <span class="token operator">=</span> <span class="token string">"confirm_queue"</span><span class="token punctuation">;</span>    <span class="token comment">//routingKey</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> CONFIRM_ROUTING_KEY <span class="token operator">=</span> <span class="token string">"key1"</span><span class="token punctuation">;</span>    <span class="token comment">//关于备份的</span>    <span class="token comment">//交换机</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> BACKUP_EXCHANGE_NAME <span class="token operator">=</span> <span class="token string">"backup_exchange"</span><span class="token punctuation">;</span>    <span class="token comment">//队列</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> BACKUP_QUEUE_NAME <span class="token operator">=</span> <span class="token string">"backup_queue"</span><span class="token punctuation">;</span>    <span class="token comment">//报警队列</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> WARNING_QUEUE_NAME <span class="token operator">=</span> <span class="token string">"warning_queue"</span><span class="token punctuation">;</span>    <span class="token comment">//声明交换机,设置该交换机的备份交换机</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span><span class="token string">"confirmExchange"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">DirectExchange</span> <span class="token function">confirmExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">ExchangeBuilder</span><span class="token punctuation">.</span><span class="token function">directExchange</span><span class="token punctuation">(</span>CONFIRM_EXCHANGE_NAME<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">durable</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">withArgument</span><span class="token punctuation">(</span><span class="token string">"alternate-exchange"</span><span class="token punctuation">,</span> BACKUP_EXCHANGE_NAME<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//声明队列</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span><span class="token string">"confirmQueue"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">Queue</span> <span class="token function">confirmQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">QueueBuilder</span><span class="token punctuation">.</span><span class="token function">durable</span><span class="token punctuation">(</span>CONFIRM_QUEUE_NAME<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//绑定</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">Binding</span> <span class="token function">queueBindingExchange</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">"confirmQueue"</span><span class="token punctuation">)</span> <span class="token class-name">Queue</span> confirmQueue<span class="token punctuation">,</span>                                        <span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">"confirmExchange"</span><span class="token punctuation">)</span> <span class="token class-name">DirectExchange</span> confirmExchange<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">BindingBuilder</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>confirmQueue<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">to</span><span class="token punctuation">(</span>confirmExchange<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">with</span><span class="token punctuation">(</span>CONFIRM_ROUTING_KEY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//备份交换机的创建</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span><span class="token string">"backupExchange"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">FanoutExchange</span> <span class="token function">backupExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FanoutExchange</span><span class="token punctuation">(</span>BACKUP_EXCHANGE_NAME<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//声明备份队列</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span><span class="token string">"backupQueue"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">Queue</span> <span class="token function">backupQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">QueueBuilder</span><span class="token punctuation">.</span><span class="token function">durable</span><span class="token punctuation">(</span>BACKUP_QUEUE_NAME<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//声明报警队列</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span><span class="token string">"warningQueue"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">Queue</span> <span class="token function">warningQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">QueueBuilder</span><span class="token punctuation">.</span><span class="token function">durable</span><span class="token punctuation">(</span>WARNING_QUEUE_NAME<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//绑定 备份队列绑定备份交换机</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">Binding</span> <span class="token function">backupQueueBindingBackupExchange</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">"backupQueue"</span><span class="token punctuation">)</span> <span class="token class-name">Queue</span> backupQueue<span class="token punctuation">,</span>                                                    <span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">"backupExchange"</span><span class="token punctuation">)</span> <span class="token class-name">FanoutExchange</span> backupExchange<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">BindingBuilder</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>backupQueue<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">to</span><span class="token punctuation">(</span>backupExchange<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//绑定 报警队列绑定备份交换机</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">Binding</span> <span class="token function">warningQueueBindingBackupExchange</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">"warningQueue"</span><span class="token punctuation">)</span> <span class="token class-name">Queue</span> warningQueue<span class="token punctuation">,</span>                                                     <span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">"backupExchange"</span><span class="token punctuation">)</span> <span class="token class-name">FanoutExchange</span> backupExchange<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">BindingBuilder</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>warningQueue<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">to</span><span class="token punctuation">(</span>backupExchange<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>报警消费者</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Slf4j</span><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WarningConsumer</span> <span class="token punctuation">{</span>    <span class="token comment">//接收报警信息</span>    <span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>queues <span class="token operator">=</span> <span class="token class-name">ConfirmConfig</span><span class="token punctuation">.</span>WARNING_QUEUE_NAME<span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">receiveWarningMsg</span><span class="token punctuation">(</span><span class="token class-name">Message</span> message<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">String</span> msg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"报警发现不可路由消息:{}"</span><span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>由于之前写过 <code>confirm.exchange</code> 交换机，当更改配置了，需要删掉，不然会报错。</p><p>再次访问：<a href="http://localhost:8088/confirm/sendMessage/%E5%A4%A7%E5%AE%B6%E5%A5%BD1">http://localhost:8088/confirm/sendMessage/大家好1</a></p><img src="/2022/09/27/rabbitmq-bi-ji/61.png" class=""><p>Mandatory 参数与备份交换机可以一起使用的时候，如果两者同时开启，消息究竟何去何从？谁优先级高，经过上面结果显示答案是<strong>备份交换机优先级高</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker学习笔记</title>
      <link href="/2022/09/19/docker-xue-xi-bi-ji/"/>
      <url>/2022/09/19/docker-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><h2 id="1-Docker基本组成"><a href="#1-Docker基本组成" class="headerlink" title="1. Docker基本组成"></a>1. Docker基本组成</h2><ul><li>镜像(image)</li></ul><p>Docker镜像是一个只读的模板，镜像可以用来创建Docker容器，一个镜像可以创建多个容器。</p><ul><li>容器(container)</li></ul><p>Docker容器独立运行一个或者一组应用，应用程序或服务运行在容器里面，容器就类似于一个虚拟化的运行环境。(可以把容器看做是一个简易版的Linux环境)</p><ul><li>仓库(repository)</li></ul><p>仓库是集中存放镜像文件的场所。类似于Maven仓库存放各种jar包的地方。</p><img src="/2022/09/19/docker-xue-xi-bi-ji/01.jpg" class><h2 id="2-CentOS-7安装Docker"><a href="#2-CentOS-7安装Docker" class="headerlink" title="2. CentOS 7安装Docker"></a>2. CentOS 7安装Docker</h2><p><a href="https://docs.docker.com/engine/install/centos/">Install Docker Engine on CentOS | Docker Documentation</a></p><h3 id="2-1-卸载旧版本"><a href="#2-1-卸载旧版本" class="headerlink" title="2.1 卸载旧版本"></a>2.1 卸载旧版本</h3><img src="/2022/09/19/docker-xue-xi-bi-ji/02.png" class><h3 id="2-2-yum安装gcc相关"><a href="#2-2-yum安装gcc相关" class="headerlink" title="2.2 yum安装gcc相关"></a>2.2 yum安装gcc相关</h3><pre class="language-none"><code class="language-none">yum -y install gccyum -y install gcc-c++</code></pre><img src="/2022/09/19/docker-xue-xi-bi-ji/03.png" class><h3 id="2-3-安装官网要求的包"><a href="#2-3-安装官网要求的包" class="headerlink" title="2.3 安装官网要求的包"></a>2.3 安装官网要求的包</h3><img src="/2022/09/19/docker-xue-xi-bi-ji/04.png" class><p><code>yum install -y yum-utils</code></p><h3 id="2-4-设置stable镜像仓库"><a href="#2-4-设置stable镜像仓库" class="headerlink" title="2.4 设置stable镜像仓库"></a>2.4 设置stable镜像仓库</h3><p>使用官网方式下载速度慢，经常出错，改用阿里云镜像</p><p><code>yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</code></p><h3 id="2-5-更新软件包索引"><a href="#2-5-更新软件包索引" class="headerlink" title="2.5 更新软件包索引"></a>2.5 更新软件包索引</h3><p><code>yum makecache fast</code></p><h3 id="2-6-安装Docker引擎"><a href="#2-6-安装Docker引擎" class="headerlink" title="2.6 安装Docker引擎"></a>2.6 安装Docker引擎</h3><p><code>yum install docker-ce docker-ce-cli containerd.io</code></p><img src="/2022/09/19/docker-xue-xi-bi-ji/05.png" class><h3 id="2-7-启动Docker"><a href="#2-7-启动Docker" class="headerlink" title="2.7 启动Docker"></a>2.7 启动Docker</h3><p><code>systemctl start docker</code></p><h3 id="2-8-测试"><a href="#2-8-测试" class="headerlink" title="2.8 测试"></a>2.8 测试</h3><p><code>docker version</code></p><img src="/2022/09/19/docker-xue-xi-bi-ji/06.png" class><p><code>docker run hello-world</code></p><img src="/2022/09/19/docker-xue-xi-bi-ji/07.png" class><h2 id="3-卸载Docker"><a href="#3-卸载Docker" class="headerlink" title="3. 卸载Docker"></a>3. 卸载Docker</h2><img src="/2022/09/19/docker-xue-xi-bi-ji/08.png" class><pre class="language-none"><code class="language-none">systemctl stop dockeryum remove docker-ce docker-ce-cli containerd.io docker-compose-pluginrm -rf /var/lib/dockerrm -rf /var/lib/containerd</code></pre><h2 id="4-阿里云镜像加速（个人版）"><a href="#4-阿里云镜像加速（个人版）" class="headerlink" title="4. 阿里云镜像加速（个人版）"></a>4. 阿里云镜像加速（个人版）</h2><img src="/2022/09/19/docker-xue-xi-bi-ji/09.png" class><ul><li>直接粘贴</li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/10.png" class><pre class="language-none"><code class="language-none">mkdir -p /etc/dockertee /etc/docker/daemon.json &lt;&lt;-'EOF'{  "registry-mirrors": ["https://hzey81li.mirror.aliyuncs.com"]}EOF</code></pre><ul><li>重启服务</li></ul><pre class="language-none"><code class="language-none">systemctl daemon-reloadsystemctl restart docker</code></pre><h2 id="5-run-hello-world简单分析"><a href="#5-run-hello-world简单分析" class="headerlink" title="5. run hello-world简单分析"></a>5. run hello-world简单分析</h2><ul><li>docker run hello-world</li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/12.png" class><p>输出这段提示后，hello-world就会停止运行，容器自动终止。</p><ul><li>run干了什么</li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/11.jpg" class><h2 id="6-为什么Docker会比VM虚拟机快"><a href="#6-为什么Docker会比VM虚拟机快" class="headerlink" title="6. 为什么Docker会比VM虚拟机快"></a>6. 为什么Docker会比VM虚拟机快</h2><p><strong>(1)docker有着比虚拟机更少的抽象层</strong></p><p>​由于docker不需要Hypervisor(虚拟机)实现硬件资源虚拟化,运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker将会在效率上有明显优势。</p><p><strong>(2)docker利用的是宿主机的内核,而不需要加载操作系统OS内核</strong></p><p>​当新建一个容器时,docker不需要和虚拟机一样重新加载一个操作系统内核。进而避免引寻、加载操作系统内核返回等比较费时费资源的过程,当新建一个虚拟机时,虚拟机软件需要加载OS,返回新建过程是分钟级别的。而docker由于直接利用宿主机的操作系统,则省略了返回过程,因此新建一个docker容器只需要几秒钟。</p><img src="/2022/09/19/docker-xue-xi-bi-ji/13.jpg" class><img src="/2022/09/19/docker-xue-xi-bi-ji/14.png" class><h2 id="7-Docker常用命令"><a href="#7-Docker常用命令" class="headerlink" title="7. Docker常用命令"></a>7. Docker常用命令</h2><h3 id="7-1-帮助启动类命令"><a href="#7-1-帮助启动类命令" class="headerlink" title="7.1 帮助启动类命令"></a>7.1 帮助启动类命令</h3><ul><li><p>启动docker： systemctl start docker</p></li><li><p>停止docker： systemctl stop docker</p></li><li><p>重启docker： systemctl restart docker</p></li><li><p>查看docker状态： systemctl status docker</p></li><li><p>开机启动： systemctl enable docker</p></li><li><p>查看docker概要信息： docker info</p></li><li><p>查看docker总体帮助文档： docker –help</p></li><li><p>查看docker命令帮助文档： docker 具体命令 –help</p></li></ul><h3 id="7-2-镜像命令"><a href="#7-2-镜像命令" class="headerlink" title="7.2 镜像命令"></a>7.2 镜像命令</h3><p>（1）列出本地主机上的镜像：docker images [OPTIONS]</p><p>OPTIONS说明：</p><ul><li>-a：列出本地所有的镜像（含历史映像层）</li><li>-q：只显示镜像ID</li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/15.jpg" class><p>各个选项说明：</p><pre class="language-none"><code class="language-none">REPOSITORY：表示镜像的仓库源TAG：镜像的标签版本号IMAGE ID：镜像IDCREATED：镜像创建时间SIZE：镜像大小同一仓库源可以有多个 TAG版本，代表这个仓库源的不同个版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。（mysql:5.7）如果你不指定一个镜像的版本标签，例如你只使用 ubuntu，docker 将默认使用 ubuntu:latest 镜像</code></pre><p>（2）搜索某个镜像：docker search [OPTIONS] 镜像名字</p><p>OPTIONS说明：</p><ul><li>–limit：只列出N个镜像，默认25个</li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/16.png" class><img src="/2022/09/19/docker-xue-xi-bi-ji/17.jpg" class><p>（3）下载镜像：docker pull 镜像名字[:TAG]</p><p>（4）查看镜像/容器/数据卷所占的空间：docker system df</p><img src="/2022/09/19/docker-xue-xi-bi-ji/18.jpg" class><p>（5）删除单个镜像：docker rmi -f 镜像ID</p><p>（6）删除多个镜像：docker rmi -f 镜像名1:TAG 镜像名2:TAG</p><p>（7）删除全部镜像：docker rmi -f $(docker image -qa)</p><h3 id="7-3-容器命令"><a href="#7-3-容器命令" class="headerlink" title="7.3 容器命令"></a>7.3 容器命令</h3><p>（1）新建+启动容器：docker run [OPTIONS] IMAGE [COMMAND] [ARG…]</p><p>OPTIONS说明：</p><ul><li><p>–name=”容器新名字”：为容器指定一个名称</p></li><li><p>-d：后台运行容器并返回容器ID，即启动守护式容器(后台运行)</p></li><li><p>-i：以交互模式运行容器，通常与-t同时使用 -it</p></li><li><p>-t：为容器重新分配一个伪输入终端，通常与-i同时使用</p></li><li><p>-P：随机端口映射，大写P</p></li><li><p>-p：指定端口映射，小写p</p></li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/19.jpg" class><p>启动交互式容器(前台命令行)：</p><img src="/2022/09/19/docker-xue-xi-bi-ji/20.jpg" class><p>-i：交互式操作。</p><p>-t：终端。</p><p>centos：centos 镜像。</p><p>/bin/bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash</p><p>（2）列出当前所有正在运行的容器：docker ps [OPTIONS]</p><p>OPTIONS说明：</p><ul><li>-a：列出当前所有正在运行的容器+历史上运行过的</li><li>-l：显示最近创建的容器</li><li>-n：显示最近n个创建的容器</li><li>-q：静默模式，只显示容器编号</li></ul><p>（3）退出容器：</p><ul><li>run进去容器，exit退出，容器停止</li><li>run进去容器，ctrl+p+q退出，容器不停止</li></ul><p>（4）启动已停止运行的容器：docker start 容器ID或容器名</p><p>（5）重启容器：docker restart 容器ID或容器名</p><p>（6）停止容器：docker stop 容器ID或容器名</p><p>（7）强制停止容器：docker kill 容器ID或容器名</p><p>（8）删除已停止的容器：docker rm 容器ID</p><p>（9）一次删除多个容器：docker rm -f $(docker ps -a -q)</p><p>（10）查看容器内运行的进程：docker top 容器ID</p><p>（11）重新进入容器：</p><ul><li>docker exec -it 容器ID /bin/bash（推荐使用）</li><li>docker attach 容器ID</li></ul><p>两者区别：</p><ol><li>attach直接进入容器启动命令的终端，不会启动新的进程 用exit退出，会导致容器的停止。</li><li>exec 是在容器中打开新的终端，并且可以启动新的进程 用exit退出，不会导致容器的停止。</li></ol><h2 id="8-Docker镜像commit操作案例"><a href="#8-Docker镜像commit操作案例" class="headerlink" title="8. Docker镜像commit操作案例"></a>8. Docker镜像commit操作案例</h2><ul><li>docker commit 提交容器副本使之成为一个新的镜像</li></ul><p>命令：docker commit -m=”提交的描述信息” -a=”作者” 容器ID 要创建的目标镜像名:[标签名]</p><h3 id="案例演示ubuntu安装vim"><a href="#案例演示ubuntu安装vim" class="headerlink" title="案例演示ubuntu安装vim"></a>案例演示ubuntu安装vim</h3><p><strong>原始默认的Ubuntu镜像是不带有vim命令的</strong></p><img src="/2022/09/19/docker-xue-xi-bi-ji/21.png" class><ul><li>外网连通的情况下，安装vim</li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/22.jpg" class><p>docker容器内执行上述两条命令：</p><p><code>apt-get update</code></p><p><code>apt-get -y install vim</code></p><img src="/2022/09/19/docker-xue-xi-bi-ji/23.png" class><img src="/2022/09/19/docker-xue-xi-bi-ji/24.png" class><img src="/2022/09/19/docker-xue-xi-bi-ji/242.png" class><ul><li>安装完成后，commit新的镜像</li></ul><p><code>docker commit -m="提交的描述信息" -a="作者" 容器ID 要创建的目标镜像名:[标签名]</code></p><img src="/2022/09/19/docker-xue-xi-bi-ji/25.png" class><ul><li>启动我们的新镜像并和原来的对比</li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/26.png" class><ul><li>小总结</li></ul><p>Docker中的镜像分层，支持通过扩展现有镜像，创建新的镜像。类似Java继承于一个Base基础类，自己再按需扩展。</p><p>新镜像是从 base 镜像一层一层叠加生成的。每安装一个软件，就在现有镜像的基础上增加一层</p><img src="/2022/09/19/docker-xue-xi-bi-ji/27.jpg" class><h2 id="9-本地镜像发布到阿里云"><a href="#9-本地镜像发布到阿里云" class="headerlink" title="9. 本地镜像发布到阿里云"></a>9. 本地镜像发布到阿里云</h2><img src="/2022/09/19/docker-xue-xi-bi-ji/28.jpg" class><ol><li>本地镜像素材原型</li></ol><img src="/2022/09/19/docker-xue-xi-bi-ji/29.png" class><ol start="2"><li>选择控制台，进入容器镜像服务</li></ol><img src="/2022/09/19/docker-xue-xi-bi-ji/30.png" class><ol start="3"><li>择个人实例</li></ol><img src="/2022/09/19/docker-xue-xi-bi-ji/31.png" class><ol start="4"><li>创建命名空间</li></ol><img src="/2022/09/19/docker-xue-xi-bi-ji/32.png" class><ol start="5"><li>创建镜像仓库</li></ol><img src="/2022/09/19/docker-xue-xi-bi-ji/33.png" class><img src="/2022/09/19/docker-xue-xi-bi-ji/34.png" class><ol start="6"><li>进入仓库管理界面</li></ol><img src="/2022/09/19/docker-xue-xi-bi-ji/35.png" class><ol start="7"><li>将镜像推送到阿里云仓库</li></ol><img src="/2022/09/19/docker-xue-xi-bi-ji/36.png" class><ol start="8"><li>将阿里云上的镜像下载到本地</li></ol><img src="/2022/09/19/docker-xue-xi-bi-ji/38.png" class><img src="/2022/09/19/docker-xue-xi-bi-ji/37.png" class><h2 id="10-本地镜像发布到私有库"><a href="#10-本地镜像发布到私有库" class="headerlink" title="10. 本地镜像发布到私有库"></a>10. 本地镜像发布到私有库</h2><h3 id="10-1-下载镜像Docker-Registry"><a href="#10-1-下载镜像Docker-Registry" class="headerlink" title="10.1 下载镜像Docker Registry"></a>10.1 下载镜像Docker Registry</h3><p><code>docker pull registry</code></p><img src="/2022/09/19/docker-xue-xi-bi-ji/39.jpg" class><img src="/2022/09/19/docker-xue-xi-bi-ji/40.jpg" class><h3 id="10-2-运行私有库Registry，相当于本地有个私有Docker-hub"><a href="#10-2-运行私有库Registry，相当于本地有个私有Docker-hub" class="headerlink" title="10.2 运行私有库Registry，相当于本地有个私有Docker hub"></a>10.2 运行私有库Registry，相当于本地有个私有Docker hub</h3><p><code>docker run -d -p 5000:5000 -v /zzyyuse/myregistry/:/tmp/registry --privileged=true registry</code></p><p>默认情况，仓库被创建在容器的/var/lib/registry目录下，建议自行用容器卷映射，方便于宿主机联调</p><img src="/2022/09/19/docker-xue-xi-bi-ji/41.jpg" class><h3 id="10-3-案例演示创建一个新镜像，ubuntu安装ifconfig命令"><a href="#10-3-案例演示创建一个新镜像，ubuntu安装ifconfig命令" class="headerlink" title="10.3 案例演示创建一个新镜像，ubuntu安装ifconfig命令"></a>10.3 案例演示创建一个新镜像，ubuntu安装ifconfig命令</h3><img src="/2022/09/19/docker-xue-xi-bi-ji/42.jpg" class><img src="/2022/09/19/docker-xue-xi-bi-ji/43.jpg" class><img src="/2022/09/19/docker-xue-xi-bi-ji/44.jpg" class><h3 id="10-4-提交新镜像"><a href="#10-4-提交新镜像" class="headerlink" title="10.4 提交新镜像"></a>10.4 提交新镜像</h3><p><code>docker commit -m="提交的描述信息" -a="作者" 容器ID 要创建的目标镜像名:[标签名]</code></p><img src="/2022/09/19/docker-xue-xi-bi-ji/45.jpg" class><h3 id="10-5-curl验证私服库上有什么镜像"><a href="#10-5-curl验证私服库上有什么镜像" class="headerlink" title="10.5 curl验证私服库上有什么镜像"></a>10.5 curl验证私服库上有什么镜像</h3><p><code>curl -XGET http://192.168.111.162:5000/v2/_catalog</code></p><p>可以看到，目前私服库没有任何镜像上传过</p><img src="/2022/09/19/docker-xue-xi-bi-ji/46.jpg" class><h3 id="10-6-将新镜像的Tag修改成符合规定的Tag"><a href="#10-6-将新镜像的Tag修改成符合规定的Tag" class="headerlink" title="10.6 将新镜像的Tag修改成符合规定的Tag"></a>10.6 将新镜像的Tag修改成符合规定的Tag</h3><p><code>docker tag zzyyubuntu:1.2 192.168.111.162:5000/zzyyubuntu:1.2</code></p><img src="/2022/09/19/docker-xue-xi-bi-ji/47.jpg" class><h3 id="10-7-修改配置文件使之支持http"><a href="#10-7-修改配置文件使之支持http" class="headerlink" title="10.7 修改配置文件使之支持http"></a>10.7 修改配置文件使之支持http</h3><img src="/2022/09/19/docker-xue-xi-bi-ji/48.jpg" class><p>registry-mirrors 配置的是国内阿里提供的镜像加速地址，不用加速的话访问官网的会很慢。</p><p><strong>2个配置中间有个逗号 ‘,’ 别漏了</strong>，这个配置是json格式的。</p><p>上述理由：docker默认不允许http方式推送镜像，通过配置选项来取消这个限制。====&gt; 修改完后如果不生效，建议重启docker</p><h3 id="10-8-push推送到私服库"><a href="#10-8-push推送到私服库" class="headerlink" title="10.8 push推送到私服库"></a>10.8 push推送到私服库</h3><p><code>docker push 192.168.111.162:5000/zzyyubuntu:1.2</code></p><img src="/2022/09/19/docker-xue-xi-bi-ji/49.jpg" class><h3 id="10-9-curl再次验证私服库上有什么镜像"><a href="#10-9-curl再次验证私服库上有什么镜像" class="headerlink" title="10.9 curl再次验证私服库上有什么镜像"></a>10.9 curl再次验证私服库上有什么镜像</h3><p><code>curl -XGET http://192.168.111.162:5000/v2/_catalog</code></p><img src="/2022/09/19/docker-xue-xi-bi-ji/50.jpg" class><h3 id="10-10-pull到本地并运行"><a href="#10-10-pull到本地并运行" class="headerlink" title="10.10 pull到本地并运行"></a>10.10 pull到本地并运行</h3><p><code>docker pull 192.168.111.162:5000/zzyyubuntu:1.2</code></p><img src="/2022/09/19/docker-xue-xi-bi-ji/51.jpg" class><p><code>docker run -it 镜像ID /bin/bash</code></p><img src="/2022/09/19/docker-xue-xi-bi-ji/52.jpg" class><h2 id="11-Docker容器数据卷"><a href="#11-Docker容器数据卷" class="headerlink" title="11. Docker容器数据卷"></a>11. Docker容器数据卷</h2><h3 id="11-1-why"><a href="#11-1-why" class="headerlink" title="11.1 why"></a>11.1 why</h3><p>Docker挂载主机目录访问如果出现cannot open directory .: Permission denied</p><p>解决办法：在挂载目录后多加一个–privileged=true参数即可</p><p>如果是CentOS7安全模块会比之前系统版本加强，不安全的会先禁止，所以目录挂载的情况被默认为不安全的行为，在SELinux里面挂载目录被禁止掉了额，如果要开启，我们一般使用–privileged=true命令，扩大容器的权限解决挂载目录没有权限的问题，也即</p><p>使用该参数，container内的root拥有真正的root权限，否则，container内的root只是外部的一个普通用户权限。</p><h3 id="11-2-是什么"><a href="#11-2-是什么" class="headerlink" title="11.2 是什么"></a>11.2 是什么</h3><p>卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过Union File System提供一些用于持续存储或共享数据的特性：</p><p>卷的设计目的就是<strong>数据的持久化</strong>，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷。</p><ul><li><p>有点类似我们Redis里面的rdb和aof文件</p></li><li><p>将docker容器内的数据保存进宿主机的磁盘中</p></li><li><p>运行一个带有容器卷存储功能的容器实例</p><p><code>docker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录   镜像名</code></p></li></ul><h3 id="11-3-能干嘛"><a href="#11-3-能干嘛" class="headerlink" title="11.3 能干嘛"></a>11.3 能干嘛</h3><ul><li>将运用与运行的环境打包镜像，run后形成容器实例运行 ，但是我们对数据的要求希望是<strong>持久化的</strong></li></ul><p>Docker容器产生的数据，如果不备份，那么当容器实例删除后，容器内的数据自然也就没有了。为了能保存数据在docker中我们使用卷。</p><p>特点：</p><ol><li><p>数据卷可在容器之间共享或重用数据</p></li><li><p>卷中的更改可以直接实时生效</p></li><li><p>数据卷中的更改不会包含在镜像的更新中</p></li><li><p>数据卷的生命周期一直持续到没有容器使用它为止</p></li></ol><h3 id="11-4-数据卷案例"><a href="#11-4-数据卷案例" class="headerlink" title="11.4 数据卷案例"></a>11.4 数据卷案例</h3><ul><li>宿主vs容器之间映射添加容器卷</li></ul><p>命令：<code>docker run -it -v /宿主机目录:/容器内目录 ubuntu /bin/bash</code></p><p><code>docker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录   镜像名</code></p><img src="/2022/09/19/docker-xue-xi-bi-ji/53.jpg" class><ul><li>查看数据卷是否挂载成功</li></ul><p><code>docker inspect 容器ID</code></p><img src="/2022/09/19/docker-xue-xi-bi-ji/54.jpg" class><ul><li>容器和宿主机之间数据共享<ol><li>docker修改，主机同步获得</li><li>主机修改，docker同步获得</li><li>docker容器stop，主机修改，docker容器重启数据同步</li></ol></li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/55.jpg" class><ul><li>读写规则映射添加说明</li></ul><p>（1）默认读写：</p><p><code>docker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录:rw   镜像名</code></p><img src="/2022/09/19/docker-xue-xi-bi-ji/56.jpg" class><img src="/2022/09/19/docker-xue-xi-bi-ji/57.jpg" class><p>（2）只读</p><p>容器实例内部被限制，只能读取不能写</p><p><code>docker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录:ro   镜像名</code></p><img src="/2022/09/19/docker-xue-xi-bi-ji/58.jpg" class><ul><li>卷的继承和共享</li></ul><p>（1）容器1完成和宿主机的映射</p><p><code>docker run -it --privileged=true -v /mydocker/u:/tmp --name u1 ubuntu</code></p><img src="/2022/09/19/docker-xue-xi-bi-ji/59.jpg" class><img src="/2022/09/19/docker-xue-xi-bi-ji/60.jpg" class><p>（2）容器2继承容器1的卷规则</p><p><code>docker run -it --privileged=true --volumes-from 父类 --name u2 ubuntu</code></p><img src="/2022/09/19/docker-xue-xi-bi-ji/61.jpg" class><h2 id="12-Docker安装常用软件"><a href="#12-Docker安装常用软件" class="headerlink" title="12. Docker安装常用软件"></a>12. Docker安装常用软件</h2><p>总体步骤：搜索镜像、拉取镜像、查看镜像、启动镜像、停止容器、移除容器</p><h3 id="12-1-安装tomcat"><a href="#12-1-安装tomcat" class="headerlink" title="12.1 安装tomcat"></a>12.1 安装tomcat</h3><p>（1）docker hub上面查找tomcat镜像</p><p><code>docker search tomcat</code></p><img src="/2022/09/19/docker-xue-xi-bi-ji/62.jpg" class><p>（2）从docker hub上拉取tomcat镜像到本地</p><p><code>docker pull tomcat</code></p><img src="/2022/09/19/docker-xue-xi-bi-ji/63.jpg" class><p>（3）查看是否有拉取到的tomcat</p><img src="/2022/09/19/docker-xue-xi-bi-ji/64.jpg" class><p>（4）使用镜像创建容器实例（运行镜像）</p><ul><li><p>docker run -it -p 8080:8080 tomcat</p></li><li><p>-p 小写，主机端口:docker容器端口</p></li><li><p>-P 大写，随机分配端口</p></li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/65.jpg" class><ul><li><p>-i:交互</p></li><li><p>-t:终端</p></li><li><p>-d:后台</p></li></ul><p>（5）访问猫首页</p><p>问题：</p><img src="/2022/09/19/docker-xue-xi-bi-ji/66.jpg" class><p>解决：</p><ul><li>可能没有映射端口或者没有关闭防火墙</li><li>把webapps.dist目录换成webapps</li><li>先成功启动tomcat</li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/67.jpg" class><ul><li>查看webapps文件夹为空</li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/68.jpg" class><p>（6）免修改版说明</p><ul><li><p>docker pull billygoo/tomcat8-jdk8</p></li><li><p>docker run -d -p 8080:8080 –name mytomcat8 billygoo/tomcat8-jdk8</p></li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/69.jpg" class><h3 id="12-2-安装mysql"><a href="#12-2-安装mysql" class="headerlink" title="12.2 安装mysql"></a>12.2 安装mysql</h3><ul><li>新建mysql容器实例</li></ul><pre class="language-none"><code class="language-none">docker run -d -p 3306:3306 --privileged=true -v /zzyyuse/mysql/log:/var/log/mysql -v /zzyyuse/mysql/data:/var/lib/mysql -v /zzyyuse/mysql/conf:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=123456  --name mysql mysql:5.7</code></pre><p>挂载容器数据卷，防止删容器数据也丢失。</p><ul><li>新建my.cnf，通过容器卷同步给mysql容器实例</li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/70.png" class><ul><li>重新启动mysql容器实例再重新进入并查看字符编码</li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/71.png" class><ul><li>新建库新建表插入中文测试</li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/72.png" class><img src="/2022/09/19/docker-xue-xi-bi-ji/73.png" class><ul><li>强制删除容器后，再次运行容器，数据依然存在</li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/74.png" class><h3 id="12-3-安装redis"><a href="#12-3-安装redis" class="headerlink" title="12.3 安装redis"></a>12.3 安装redis</h3><ul><li>从docker hub上(阿里云加速器)拉取redis镜像到本地标签为6.0.8，创建容器</li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/75.jpg" class><img src="/2022/09/19/docker-xue-xi-bi-ji/76.jpg" class><ul><li><strong>命令提醒：容器卷记得加入</strong>–privileged=true</li></ul><p>Docker挂载主机目录Docker访问出现cannot open directory .: Permission denied</p><p>解决办法：在挂载目录后多加一个–privileged=true参数即可</p><ul><li>在CentOS宿主机下新建目录/app/redis</li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/77.jpg" class><ul><li>将一个redis.conf文件模板拷贝进/app/redis目录下</li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/78.jpg" class><ul><li>/app/redis目录下修改redis.conf文件</li></ul><p>（1）开启redis验证  可选</p><p>  requirepass 123</p><p>（2）允许redis外地连接 <strong>必须</strong></p><p>   注释掉 # bind 127.0.0.1</p><img src="/2022/09/19/docker-xue-xi-bi-ji/79.jpg" class><p>（3） daemonize no</p><p>   将daemonize yes注释起来或者 daemonize no设置，因为该配置和docker run中-d参数冲突，会导致容器一直启动失败</p><img src="/2022/09/19/docker-xue-xi-bi-ji/80.jpg" class><p>（4）开启redis数据持久化 appendonly yes 可选</p><ul><li>使用redis6.0.8镜像创建容器(也叫运行镜像)</li></ul><pre class="language-none"><code class="language-none">docker run  -p 6379:6379 --name myr3 --privileged=true -v /app/redis/redis.conf:/etc/redis/redis.conf -v /app/redis/data:/data -d redis:6.0.8 redis-server /etc/redis/redis.conf</code></pre><img src="/2022/09/19/docker-xue-xi-bi-ji/81.jpg" class><ul><li>测试redis-cli连接上来</li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/82.jpg" class><p><code> docker exec -it 运行着Rediis服务的容器ID</code></p><p><code> redis-cli</code></p><h1 id="高级篇"><a href="#高级篇" class="headerlink" title="高级篇"></a>高级篇</h1><h2 id="13-Docker-复杂安装详说"><a href="#13-Docker-复杂安装详说" class="headerlink" title="13. Docker 复杂安装详说"></a>13. Docker 复杂安装详说</h2><h3 id="13-1-安装mysql主从复制"><a href="#13-1-安装mysql主从复制" class="headerlink" title="13.1 安装mysql主从复制"></a>13.1 安装mysql主从复制</h3><ul><li>新建主服务器容器实例 3307</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -p <span class="token number">3307</span>:3306 --name mysql-master <span class="token punctuation">\</span>-v /mydata/mysql-master/log:/var/log/mysql <span class="token punctuation">\</span>-v /mydata/mysql-master/data:/var/lib/mysql <span class="token punctuation">\</span>-v /mydata/mysql-master/conf:/etc/mysql <span class="token punctuation">\</span>-e <span class="token assign-left variable">MYSQL_ROOT_PASSWORD</span><span class="token operator">=</span>root  <span class="token punctuation">\</span>-d mysql:5.7</code></pre><ul><li>进入/mydata/mysql-master/conf目录下新建my.cnf，vim my.cnf</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>mysqld<span class="token punctuation">]</span><span class="token comment">## 设置server_id，同一局域网中需要唯一</span><span class="token assign-left variable">server_id</span><span class="token operator">=</span><span class="token number">101</span> <span class="token comment">## 指定不需要同步的数据库名称</span>binlog-ignore-db<span class="token operator">=</span>mysql  <span class="token comment">## 开启二进制日志功能</span>log-bin<span class="token operator">=</span>mall-mysql-bin  <span class="token comment">## 设置二进制日志使用内存大小（事务）</span><span class="token assign-left variable">binlog_cache_size</span><span class="token operator">=</span>1M  <span class="token comment">## 设置使用的二进制日志格式（mixed,statement,row）</span><span class="token assign-left variable">binlog_format</span><span class="token operator">=</span>mixed  <span class="token comment">## 二进制日志过期清理时间。默认值为0，表示不自动清理。</span><span class="token assign-left variable">expire_logs_days</span><span class="token operator">=</span><span class="token number">7</span>  <span class="token comment">## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。</span><span class="token comment">## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致</span><span class="token assign-left variable">slave_skip_errors</span><span class="token operator">=</span><span class="token number">1062</span></code></pre><ul><li>修改完配置后重启master实例</li></ul><p><code>docker restart mysql-master</code></p><ul><li>进入mysql-master容器，登录mysql</li></ul><p><code>docker exec -it mysql-master /bin/bash</code></p><p><code>mysql -uroot -proot</code></p><ul><li>master容器实例内创建数据同步用户</li></ul><pre class="language-mysql" data-language="mysql"><code class="language-mysql">CREATE USER 'slave'@'%' IDENTIFIED BY '123456';GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO 'slave'@'%';</code></pre><ul><li>新建从服务器容器实例 3308</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -p <span class="token number">3308</span>:3306 --name mysql-slave <span class="token punctuation">\</span>-v /mydata/mysql-slave/log:/var/log/mysql <span class="token punctuation">\</span>-v /mydata/mysql-slave/data:/var/lib/mysql <span class="token punctuation">\</span>-v /mydata/mysql-slave/conf:/etc/mysql <span class="token punctuation">\</span>-e <span class="token assign-left variable">MYSQL_ROOT_PASSWORD</span><span class="token operator">=</span>root  <span class="token punctuation">\</span>-d mysql:5.7</code></pre><ul><li>进入/mydata/mysql-slave/conf目录下新建my.cnf，vim my.cnf</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>mysqld<span class="token punctuation">]</span><span class="token comment">## 设置server_id，同一局域网中需要唯一</span><span class="token assign-left variable">server_id</span><span class="token operator">=</span><span class="token number">102</span><span class="token comment">## 指定不需要同步的数据库名称</span>binlog-ignore-db<span class="token operator">=</span>mysql  <span class="token comment">## 开启二进制日志功能，以备Slave作为其它数据库实例的Master时使用</span>log-bin<span class="token operator">=</span>mall-mysql-slave1-bin  <span class="token comment">## 设置二进制日志使用内存大小（事务）</span><span class="token assign-left variable">binlog_cache_size</span><span class="token operator">=</span>1M  <span class="token comment">## 设置使用的二进制日志格式（mixed,statement,row）</span><span class="token assign-left variable">binlog_format</span><span class="token operator">=</span>mixed  <span class="token comment">## 二进制日志过期清理时间。默认值为0，表示不自动清理。</span><span class="token assign-left variable">expire_logs_days</span><span class="token operator">=</span><span class="token number">7</span>  <span class="token comment">## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。</span><span class="token comment">## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致</span><span class="token assign-left variable">slave_skip_errors</span><span class="token operator">=</span><span class="token number">1062</span>  <span class="token comment">## relay_log配置中继日志</span><span class="token assign-left variable">relay_log</span><span class="token operator">=</span>mall-mysql-relay-bin  <span class="token comment">## log_slave_updates表示slave将复制事件写进自己的二进制日志</span><span class="token assign-left variable">log_slave_updates</span><span class="token operator">=</span><span class="token number">1</span>  <span class="token comment">## slave设置为只读（具有super权限的用户除外）</span><span class="token assign-left variable">read_only</span><span class="token operator">=</span><span class="token number">1</span></code></pre><ul><li>修改完配置后重启slave实例</li></ul><p><code>docker restart mysql-slave</code></p><ul><li>在<strong>主数据库</strong>中查看主从同步状态</li></ul><p><code>show master status;</code></p><ul><li>进入mysql-slave容器，登录mysql</li></ul><p><code>docker exec -it mysql-slave /bin/bash</code></p><p><code>mysql -uroot -proot</code></p><ul><li>在<strong>从数据库</strong>中配置主从复制</li></ul><pre class="language-mysql" data-language="mysql"><code class="language-mysql">change master to master_host='宿主机ip', master_user='slave', master_password='123456', master_port=3307, master_log_file='mall-mysql-bin.000001', master_log_pos=617, master_connect_retry=30;</code></pre><ul><li>主从复制命令参数说明：</li></ul><p>master_host：主数据库的IP地址；</p><p>master_port：主数据库的运行端口；</p><p>master_user：在主数据库创建的用于同步数据的用户账号；</p><p>master_password：在主数据库创建的用于同步数据的用户密码；</p><p>master_log_file：指定从数据库要复制数据的日志文件，通过查看主数据的状态，获取File参数；</p><p>master_log_pos：指定从数据库从哪个位置开始复制数据，通过查看主数据的状态，获取Position参数；</p><p>master_connect_retry：连接失败重试的时间间隔，单位为秒。</p><ul><li>在<strong>从数据库</strong>中查看主从同步状态</li></ul><p><code>show slave status \G;</code></p><img src="/2022/09/19/docker-xue-xi-bi-ji/83.png" class><ul><li>在<strong>从数据库</strong>中开启主从同步</li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/84.png" class><ul><li>再次查看<strong>从数据库</strong>同步状态</li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/85.png" class><ul><li>主从复制测试</li></ul><p>主机新建库，使用库，新建表，插入数据；从机使用库，查看记录。</p><img src="/2022/09/19/docker-xue-xi-bi-ji/86.png" class><img src="/2022/09/19/docker-xue-xi-bi-ji/87.png" class><h3 id="13-2-安装redis集群"><a href="#13-2-安装redis集群" class="headerlink" title="13.2 安装redis集群"></a>13.2 安装redis集群</h3><p>哈希槽分区</p><img src="/2022/09/19/docker-xue-xi-bi-ji/88.jpg" class><h4 id="13-2-1-3主3从redis集群配置"><a href="#13-2-1-3主3从redis集群配置" class="headerlink" title="13.2.1 3主3从redis集群配置"></a>13.2.1 3主3从redis集群配置</h4><ul><li>新建6个docker容器redis实例</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -d --name redis-node-1 --net <span class="token function">host</span> --privileged<span class="token operator">=</span>true -v /data/redis/share/redis-node-1:/data redis:6.0.8 --cluster-enabled <span class="token function">yes</span> --appendonly <span class="token function">yes</span> --port <span class="token number">6381</span> <span class="token function">docker</span> run -d --name redis-node-2 --net <span class="token function">host</span> --privileged<span class="token operator">=</span>true -v /data/redis/share/redis-node-2:/data redis:6.0.8 --cluster-enabled <span class="token function">yes</span> --appendonly <span class="token function">yes</span> --port <span class="token number">6382</span> <span class="token function">docker</span> run -d --name redis-node-3 --net <span class="token function">host</span> --privileged<span class="token operator">=</span>true -v /data/redis/share/redis-node-3:/data redis:6.0.8 --cluster-enabled <span class="token function">yes</span> --appendonly <span class="token function">yes</span> --port <span class="token number">6383</span> <span class="token function">docker</span> run -d --name redis-node-4 --net <span class="token function">host</span> --privileged<span class="token operator">=</span>true -v /data/redis/share/redis-node-4:/data redis:6.0.8 --cluster-enabled <span class="token function">yes</span> --appendonly <span class="token function">yes</span> --port <span class="token number">6384</span> <span class="token function">docker</span> run -d --name redis-node-5 --net <span class="token function">host</span> --privileged<span class="token operator">=</span>true -v /data/redis/share/redis-node-5:/data redis:6.0.8 --cluster-enabled <span class="token function">yes</span> --appendonly <span class="token function">yes</span> --port <span class="token number">6385</span> <span class="token function">docker</span> run -d --name redis-node-6 --net <span class="token function">host</span> --privileged<span class="token operator">=</span>true -v /data/redis/share/redis-node-6:/data redis:6.0.8 --cluster-enabled <span class="token function">yes</span> --appendonly <span class="token function">yes</span> --port <span class="token number">6386</span></code></pre><p>运行成功，效果如下：</p><img src="/2022/09/19/docker-xue-xi-bi-ji/89.png" class><p>命令说明：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run<span class="token comment">#创建并运行docker容器实例</span>--name redis-node-6<span class="token comment">#容器名字</span>--net <span class="token function">host</span><span class="token comment">#使用宿主机的IP和端口，默认</span>--privileged<span class="token operator">=</span>true<span class="token comment">#获取宿主机root用户权限</span>-v /data/redis/share/redis-node-6:/data<span class="token comment">#容器卷，宿主机地址:docker内部地址</span>redis:6.0.8<span class="token comment">#redis镜像和版本号</span>--cluster-enabled <span class="token function">yes</span><span class="token comment">#开启redis集群</span>--appendonly <span class="token function">yes</span><span class="token comment">#开启持久化</span>--port <span class="token number">6386</span><span class="token comment">#redis端口号</span></code></pre><ul><li>进入其中一个容器</li></ul><p><code>docker exec -it redis-node-1 /bin/bash</code></p><ul><li>构建主从关系</li></ul><p><strong>注意自己的真实IP地址</strong></p><pre class="language-bash" data-language="bash"><code class="language-bash">redis-cli --cluster create <span class="token number">192.168</span>.42.53:6381 <span class="token number">192.168</span>.42.53:6382 <span class="token number">192.168</span>.42.53:6383 <span class="token number">192.168</span>.42.53:6384 <span class="token number">192.168</span>.42.53:6385 <span class="token number">192.168</span>.42.53:6386 --cluster-replicas <span class="token number">1</span></code></pre><p>–cluster-replicas 1 表示为每个master创建一个slave节点</p><img src="/2022/09/19/docker-xue-xi-bi-ji/90.png" class><img src="/2022/09/19/docker-xue-xi-bi-ji/91.png" class><ul><li>链接进入6381作为切点，查看集群、节点状态</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash">redis-cli -p <span class="token number">6381</span>cluster infocluster nodes</code></pre><img src="/2022/09/19/docker-xue-xi-bi-ji/92.png" class><h4 id="13-2-2-主从容错切换迁移案例"><a href="#13-2-2-主从容错切换迁移案例" class="headerlink" title="13.2.2 主从容错切换迁移案例"></a>13.2.2 主从容错切换迁移案例</h4><ul><li>防止路由失效加参数-c ，并对6381新增两个key</li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/93.png" class><ul><li>查看集群信息</li></ul><p><code> redis-cli  --cluster check 192.168.42.53:6381 </code></p><img src="/2022/09/19/docker-xue-xi-bi-ji/94.png" class><ul><li>容错切换迁移</li></ul><p>主6381和从机切换，先停止主机6381；6381主机停了，对应的真实从机上位；6381作为1号主机分配的从机以实际情况为准，具体几号机器就是几号。</p><ul><li>再次查看集群信息</li></ul><p><code>docker stop redis-node-1</code></p><p>6381宕机了，对应从机6385上位成为了新的master</p><img src="/2022/09/19/docker-xue-xi-bi-ji/95.png" class><p><strong>再次启动6381后，6381变成6385的从机</strong></p><ul><li>还原之前的3主3从</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#先启动6381，再停6385，再启6385，</span><span class="token comment">#命令执行中间需要等待一会，docker集群重新响应</span><span class="token function">docker</span> start redis-node-1<span class="token function">docker</span> stop redis-node-5<span class="token function">docker</span> start redis-node-5</code></pre><img src="/2022/09/19/docker-xue-xi-bi-ji/96.png" class><h4 id="13-2-3-主从扩容案例"><a href="#13-2-3-主从扩容案例" class="headerlink" title="13.2.3 主从扩容案例"></a>13.2.3 主从扩容案例</h4><ul><li>新建6387、6388两个节点 + 新建后启动 + 查看是否8节点</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -d --name redis-node-7 --net <span class="token function">host</span> --privileged<span class="token operator">=</span>true -v /data/redis/share/redis-node-7:/data redis:6.0.8 --cluster-enabled <span class="token function">yes</span> --appendonly <span class="token function">yes</span> --port <span class="token number">6387</span><span class="token function">docker</span> run -d --name redis-node-8 --net <span class="token function">host</span> --privileged<span class="token operator">=</span>true -v /data/redis/share/redis-node-8:/data redis:6.0.8 --cluster-enabled <span class="token function">yes</span> --appendonly <span class="token function">yes</span> --port <span class="token number">6388</span></code></pre><ul><li>进入6387容器实例内部</li></ul><p><code>docker exec -it redis-node-7 /bin/bash</code></p><ul><li>将新增的6387节点(空槽号)作为master节点加入原集群</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash">redis-cli --cluster add-node 自己实际IP地址:6387 自己实际IP地址:6381<span class="token comment">#6387 就是将要作为master新增节点</span><span class="token comment">#6381 就是原来集群节点里面的领路人，相当于6387拜拜6381的码头从而找到组织加入集群</span></code></pre><img src="/2022/09/19/docker-xue-xi-bi-ji/97.jpg" class><img src="/2022/09/19/docker-xue-xi-bi-ji/98.jpg" class><ul><li>第1次检查集群情况</li></ul><p><code> redis-cli  --cluster check 真实ip地址:6381 </code></p><img src="/2022/09/19/docker-xue-xi-bi-ji/99.jpg" class><img src="/2022/09/19/docker-xue-xi-bi-ji/100.jpg" class><ul><li>重新分派槽号</li></ul><p><code>redis-cli --cluster reshard IP地址:端口号</code></p><img src="/2022/09/19/docker-xue-xi-bi-ji/101.jpg" class><img src="/2022/09/19/docker-xue-xi-bi-ji/102.jpg" class><ul><li>第2次检查集群情况</li></ul><p><code> redis-cli  --cluster check 真实ip地址:6381 </code></p><img src="/2022/09/19/docker-xue-xi-bi-ji/103.jpg" class><img src="/2022/09/19/docker-xue-xi-bi-ji/104.jpg" class><ul><li>槽号分派说明</li></ul><p>为什么6387是3个新的区间，以前的还是连续？</p><p>重新分配成本太高，所以前3家各自匀出来一部分，从6381/6382/6383三个旧节点分别匀出1364个坑位给新节点6387</p><img src="/2022/09/19/docker-xue-xi-bi-ji/105.jpg" class><ul><li>为主节点6387分配从节点6388</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#命令：redis-cli --cluster add-node ip:新slave端口 ip:新master端口 --cluster-slave --cluster-master-id 新主机节点ID</span> redis-cli --cluster add-node <span class="token number">192.168</span>.111.147:6388 <span class="token number">192.168</span>.111.147:6387 --cluster-slave --cluster-master-id e4781f644d4a4e4d4b4d107157b9ba8144631451 <span class="token comment">#---这个是6387的编号，按照自己实际情况</span></code></pre><img src="/2022/09/19/docker-xue-xi-bi-ji/106.jpg" class><img src="/2022/09/19/docker-xue-xi-bi-ji/107.jpg" class><ul><li>第3次检查集群情况</li></ul><p><code>redis-cli --cluster check 192.168.111.147:6382</code></p><img src="/2022/09/19/docker-xue-xi-bi-ji/108.jpg" class><img src="/2022/09/19/docker-xue-xi-bi-ji/109.jpg" class><h4 id="13-2-4-主从缩容案例"><a href="#13-2-4-主从缩容案例" class="headerlink" title="13.2.4 主从缩容案例"></a>13.2.4 主从缩容案例</h4><ul><li>6387和6388下线；第1次检查集群情况，获得6388的节点ID</li></ul><p><code> redis-cli  --cluster check 192.168.111.147:6382 </code></p><img src="/2022/09/19/docker-xue-xi-bi-ji/110.jpg" class><ul><li>将6388删除， 从集群中将4号 从节点6388删除</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash">命令：redis-cli --cluster del-node ip:从机端口 从机6388节点ID redis-cli --cluster del-node <span class="token number">192.168</span>.111.147:6388 5d149074b7e57b802287d1797a874ed7a1a284a8</code></pre><img src="/2022/09/19/docker-xue-xi-bi-ji/111.jpg" class><ul><li>检查6388是否被删除，只剩下7台机器</li></ul><p><code> redis-cli  --cluster check 192.168.111.147:6382 </code></p><img src="/2022/09/19/docker-xue-xi-bi-ji/112.jpg" class><ul><li>将6387的槽号清空，重新分配。本例将清出来的槽号都给6381</li></ul><p><code>redis-cli --cluster reshard 192.168.111.147:6381</code></p><img src="/2022/09/19/docker-xue-xi-bi-ji/113.jpg" class><img src="/2022/09/19/docker-xue-xi-bi-ji/114.jpg" class><ul><li>第2次检查集群情况</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash">redis-cli --cluster check <span class="token number">192.168</span>.111.147:6381<span class="token comment">#4096个槽位都指给6381，它变成了8192个槽位，相当于全部都给6381了，不然要输入3次，一锅端</span></code></pre><img src="/2022/09/19/docker-xue-xi-bi-ji/115.jpg" class><ul><li>将6387删除</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash">命令：redis-cli --cluster del-node ip:端口 <span class="token number">6387</span>节点ID redis-cli --cluster del-node <span class="token number">192.168</span>.111.147:6387 e4781f644d4a4e4d4b4d107157b9ba8144631451</code></pre><img src="/2022/09/19/docker-xue-xi-bi-ji/116.jpg" class><ul><li>第3次检查集群情况</li></ul><p><code> redis-cli  --cluster check 192.168.111.147:6381 </code></p><img src="/2022/09/19/docker-xue-xi-bi-ji/117.jpg" class><h2 id="14-DockerFile解析"><a href="#14-DockerFile解析" class="headerlink" title="14. DockerFile解析"></a>14. DockerFile解析</h2><h3 id="14-1-是什么"><a href="#14-1-是什么" class="headerlink" title="14.1 是什么"></a>14.1 是什么</h3><ul><li>Dockerfile是用来构建Docker镜像的文本，是由一条条构建镜像所需的指令和参数构成的脚本。</li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/118.jpg" class><ul><li>官网</li></ul><p><a href="https://docs.docker.com/engine/reference/builder/">Dockerfile reference | Docker Documentation</a></p><ul><li>构建三步骤</li></ul><p>（1）编写Dockerfile文件</p><p>（2）docker build 命令构建镜像</p><p>（3）docker run 依镜像运行容器实例</p><h3 id="14-2-Dockerfile构建过程解析"><a href="#14-2-Dockerfile构建过程解析" class="headerlink" title="14.2 Dockerfile构建过程解析"></a>14.2 Dockerfile构建过程解析</h3><ul><li>Dockerfile内容基础知识</li></ul><p>（1）每条保留字指令都必须为大写字母且后面要跟随至少一个参数；</p><p>（2）指令按照从上到下，顺序执行；</p><p>（3）#表示注释；</p><p>（4）每条指令都会创建一个新的镜像层并对镜像进行提交</p><ul><li>Docker执行Dockerfile的大致流程</li></ul><p>（1）docker从基础镜像运行一个容器；</p><p>（2）执行一条指令并对容器作出修改</p><p>（3）执行类似docker commit 的操作提交一个新的镜像层</p><p>（4）docker再基于刚提交的镜像运行一个新容器</p><p>（5）执行Dockerfile中的下一条指令直到所有指令都执行完成</p><h3 id="14-3-Dockerfile常用保留字指令"><a href="#14-3-Dockerfile常用保留字指令" class="headerlink" title="14.3 Dockerfile常用保留字指令"></a>14.3 Dockerfile常用保留字指令</h3><ul><li>参考tomcat8的Dockerfile入门</li></ul><p><a href="https://github.com/docker-library/tomcat">https://github.com/docker-library/tomcat</a></p><ul><li>FROM</li></ul><p>基础镜像，当前新镜像是基于哪个镜像的，指定一个已经存在的镜像作为模板，第一条必须是from</p><ul><li>MAINTAINER</li></ul><p>镜像维护者的姓名和邮箱地址</p><ul><li>RUN</li></ul><p>容器构建时需要运行的命令，RUN是在docker build时运行，RUN有两种格式</p><p>shell格式</p><img src="/2022/09/19/docker-xue-xi-bi-ji/119.jpg" class><p><code>RUN yum -y install vim</code></p><p>exec格式</p><img src="/2022/09/19/docker-xue-xi-bi-ji/120.jpg" class><ul><li>EXPOSE</li></ul><p>当前容器对外暴露出的端口</p><ul><li>WORKDIR</li></ul><p>指定在创建容器后，终端默认登录进来的工作目录，一个落脚点</p><ul><li>USER</li></ul><p>指定该镜像以什么样的用户去执行，如果都不指定，默认是root</p><ul><li>ENV</li></ul><p>用来构建镜像过程中设置环境变量</p><p>ENV MY_PATH /usr/mytest</p><p>这个环境变量可以在后续的任何RUN指令中使用，这就如同在命令前面指定了环境变量前缀一样；也可以在其它指令中直接使用这些环境变量，</p><p>比如：WORKDIR $MY_PATH</p><ul><li>ADD</li></ul><p>将宿主机目录下的文件拷贝进镜像且会自动处理URL和解压tar压缩包</p><ul><li>COPY</li></ul><p>类似ADD，拷贝文件和目录到镜像中。将从构建上下文目录中&lt;源路径&gt;的文件/目录复制到新的一层的镜像内的&lt;目标路径&gt;位置</p><p>COPY src dest、COPY [“src”, “dest”]；</p><p>&lt;src源路径&gt;：源文件或者源目录</p><p>&lt;dest目标路径&gt;：容器内的指定路径，该路径不用事先建好，路径不存在的话，会自动创建。</p><ul><li>VOLUME</li></ul><p>容器数据卷，用于数据保存和持久化工作</p><ul><li>CMD</li></ul><p>指定容器启动后要干的事情</p><p><strong>注意：</strong>Dockerfile 中可以有多个 CMD 指令，但只有最后一个生效，CMD 会被 docker run 之后的参数替换</p><p>用/bin/bash覆盖原有的CMD，访问tomcat不出现猫首页</p><ul><li>ENTRYPOINT</li></ul><p>类似于 CMD 指令，但是ENTRYPOINT不会被docker run后面的命令覆盖， 而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序</p><p>命令格式：ENTRYPOINT [“<executeable>“, “<param1>“, “<param2>“, …]</param2></param1></executeable></p><p>ENTRYPOINT可以和C MD一起用，一般是变参才会使用 CMD ，这里的 CMD 等于是在给 ENTRYPOINT 传参。</p><p>当指定了ENTRYPOINT后，CMD的含义就发生了变化，不再是直接运行其命令而是将CMD的内容作为参数传递给ENTRYPOINT指令，他两个组合会变成：<entrypoint>“<cmd>“</cmd></entrypoint></p><img src="/2022/09/19/docker-xue-xi-bi-ji/124.jpg" class><table><thead><tr><th>是否传参</th><th>按照dockerfile编写执行</th><th>传参运行</th></tr></thead><tbody><tr><td>Docker命令</td><td>docker run   nginx:test</td><td>docker run   nginx:test -c /etc/nginx/<strong>new.conf</strong></td></tr><tr><td>衍生出的实际命令</td><td>nginx -c  /etc/nginx/nginx.conf</td><td>nginx -c  /etc/nginx/<strong>new.conf</strong></td></tr></tbody></table><h3 id="14-4-案例"><a href="#14-4-案例" class="headerlink" title="14.4 案例"></a>14.4 案例</h3><ul><li>自定义镜像ymcentosjava8</li></ul><p>要求：CentOS7 镜像具备vim+ifconfig+jdk8</p><ul><li>准备JDK gz压缩包，编写Dockerfile文件</li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/125.png" class><pre class="language-bash" data-language="bash"><code class="language-bash">FROM centos:7MAINTAINER zzyy<span class="token operator">&lt;</span>zzyybs@126.com<span class="token operator">&gt;</span> ENV MYPATH /usr/localWORKDIR <span class="token variable">$MYPATH</span> <span class="token comment">#安装vim编辑器</span>RUN yum -y <span class="token function">install</span> <span class="token function">vim</span><span class="token comment">#安装ifconfig命令查看网络IP</span>RUN yum -y <span class="token function">install</span> net-tools<span class="token comment">#安装java8及lib库</span>RUN yum -y <span class="token function">install</span> glibc.i686RUN <span class="token function">mkdir</span> /usr/local/java<span class="token comment">#ADD 是相对路径jar,把jdk-8u171-linux-x64.tar.gz添加到容器中,安装包必须要和Dockerfile文件在同一位置</span>ADD jdk-8u171-linux-x64.tar.gz /usr/local/java/<span class="token comment">#配置java环境变量</span>ENV JAVA_HOME /usr/local/java/jdk1.8.0_171ENV JRE_HOME <span class="token variable">$JAVA_HOME</span>/jreENV CLASSPATH <span class="token variable">$JAVA_HOME</span>/lib/dt.jar:<span class="token variable">$JAVA_HOME</span>/lib/tools.jar:<span class="token variable">$JRE_HOME</span>/lib:<span class="token variable">$CLASSPATH</span>ENV <span class="token environment constant">PATH</span> <span class="token variable">$JAVA_HOME</span>/bin:<span class="token environment constant">$PATH</span> EXPOSE <span class="token number">80</span> CMD <span class="token builtin class-name">echo</span> <span class="token variable">$MYPATH</span>CMD <span class="token builtin class-name">echo</span> <span class="token string">"success--------------ok"</span>CMD /bin/bash</code></pre><ul><li>构建</li></ul><p><code>docker build -t 新镜像名字:TAG</code></p><p>docker build -t centosjava8:1.5 .</p><img src="/2022/09/19/docker-xue-xi-bi-ji/126.png" class><p><strong>注意：</strong>上面TAG后面有个空格，有个点</p><ul><li>运行</li></ul><p><code>docker run -it 新镜像名字:TAG</code></p><p>docker run -it centosjava8:1.5 /bin/bash</p><img src="/2022/09/19/docker-xue-xi-bi-ji/127.png" class><h3 id="14-5-虚悬镜像"><a href="#14-5-虚悬镜像" class="headerlink" title="14.5 虚悬镜像"></a>14.5 虚悬镜像</h3><p>虚悬镜像：仓库名、标签都是<none>的镜像，俗称dangling image</none></p><ul><li>Dockerfile编写一个虚悬镜像</li></ul><ol><li>vim Dockerfile</li></ol><pre class="language-none"><code class="language-none">from ubuntuCMD echo 'action is success'</code></pre><ol start="2"><li>docker build</li></ol><ul><li>查看</li></ul><p><code>docker image ls -f dangling=true</code></p><ul><li>删除</li></ul><p><code>docker image prune</code></p><p>虚悬镜像已经失去存在价值，可以删除</p><h2 id="15-Docker微服务实战"><a href="#15-Docker微服务实战" class="headerlink" title="15. Docker微服务实战"></a>15. Docker微服务实战</h2><h3 id="15-1-通过IDEA新建一个普通微服务模块"><a href="#15-1-通过IDEA新建一个普通微服务模块" class="headerlink" title="15.1 通过IDEA新建一个普通微服务模块"></a>15.1 通过IDEA新建一个普通微服务模块</h3><ul><li>建Module<ul><li>docker-boot</li></ul></li><li>改POM</li></ul><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>cloud2020<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.woniu<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.0-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modelVersion</span><span class="token punctuation">&gt;</span></span>4.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modelVersion</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>docker-boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project.build.sourceEncoding</span><span class="token punctuation">&gt;</span></span>UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project.build.sourceEncoding</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>maven.compiler.source</span><span class="token punctuation">&gt;</span></span>1.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>maven.compiler.source</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>maven.compiler.target</span><span class="token punctuation">&gt;</span></span>1.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>maven.compiler.target</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!--SpringBoot通用依赖模块--&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-actuator<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!--test--&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">&gt;</span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">&gt;</span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-maven-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>executions</span><span class="token punctuation">&gt;</span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>execution</span><span class="token punctuation">&gt;</span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>goals</span><span class="token punctuation">&gt;</span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>goal</span><span class="token punctuation">&gt;</span></span>repackage<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>goal</span><span class="token punctuation">&gt;</span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>goal</span><span class="token punctuation">&gt;</span></span>build-info<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>goal</span><span class="token punctuation">&gt;</span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>goals</span><span class="token punctuation">&gt;</span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>execution</span><span class="token punctuation">&gt;</span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>executions</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">&gt;</span></span></code></pre><ul><li>写YML</li></ul><pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">server</span><span class="token punctuation">:</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">6001</span></code></pre><ul><li>主启动</li></ul><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>woniu</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span></span><span class="token class-name">SpringApplication</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span></span><span class="token class-name">SpringBootApplication</span></span><span class="token punctuation">;</span><span class="token annotation punctuation">@SpringBootApplication</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DockerBootApplication</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">DockerBootApplication</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>业务类</li></ul><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>woniu<span class="token punctuation">.</span>controller</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Value</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">RequestMapping</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">RequestMethod</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">RestController</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">UUID</span></span><span class="token punctuation">;</span><span class="token annotation punctuation">@RestController</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OrderController</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${server.port}"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> port<span class="token punctuation">;</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/order/docker"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">helloDocker</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"hello docker"</span> <span class="token operator">+</span> <span class="token string">"\t"</span> <span class="token operator">+</span> port <span class="token operator">+</span> <span class="token string">"\t"</span> <span class="token operator">+</span> UUID<span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/order/index"</span><span class="token punctuation">,</span> method <span class="token operator">=</span> <span class="token class-name">RequestMethod</span><span class="token punctuation">.</span>GET<span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">index</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"服务端口号: "</span> <span class="token operator">+</span> <span class="token string">"\t"</span> <span class="token operator">+</span> port <span class="token operator">+</span> <span class="token string">"\t"</span> <span class="token operator">+</span> UUID<span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="15-2-通过Dockerfile发布微服务部署"><a href="#15-2-通过Dockerfile发布微服务部署" class="headerlink" title="15.2 通过Dockerfile发布微服务部署"></a>15.2 通过Dockerfile发布微服务部署</h3><ul><li>IDEA工具里面搞定微服务jar包</li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/128.png" class><ul><li>编写Dockerfile</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 基础镜像使用java</span>FROM java:8<span class="token comment"># 作者</span>MAINTAINER woniu<span class="token comment"># VOLUME 指定临时文件目录为/tmp，在主机/var/lib/docker目录下创建了一个临时文件并链接到容器的/tmp</span>VOLUME /tmp<span class="token comment"># 将jar包添加到容器中并更名为zzyy_docker.jar</span>ADD docker-boot-1.0-SNAPSHOT.jar zzyy_docker.jar<span class="token comment"># 运行jar包</span>RUN <span class="token function">bash</span> -c <span class="token string">'touch /zzyy_docker.jar'</span>ENTRYPOINT <span class="token punctuation">[</span><span class="token string">"java"</span>,<span class="token string">"-jar"</span>,<span class="token string">"/zzyy_docker.jar"</span><span class="token punctuation">]</span><span class="token comment">#暴露6001端口作为微服务</span>EXPOSE <span class="token number">6001</span></code></pre><img src="/2022/09/19/docker-xue-xi-bi-ji/129.png" class><ul><li>构建镜像</li></ul><p><code>docker build -t zzyy_docker:1.6 .</code></p><img src="/2022/09/19/docker-xue-xi-bi-ji/130.png" class><ul><li>运行容器</li></ul><p><code>docker run -d -p 6001:6001 zzyy_docker:1.6</code></p><img src="/2022/09/19/docker-xue-xi-bi-ji/131.png" class><ul><li>访问测试</li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/132.png" class><h2 id="16-Docker网络"><a href="#16-Docker网络" class="headerlink" title="16. Docker网络"></a>16. Docker网络</h2><ul><li>docker启动后，会产生一个名为docker0的虚拟网桥</li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/133.jpg" class><ul><li>查看docker网络模式命令，默认创建3大网络模式</li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/134.jpg" class><ul><li>常用基本命令</li></ul><pre class="language-none"><code class="language-none">查看网络：docker network ls查看网络源数据：docker network inspect xxx网络名字删除网络：docker network rm xxx网络名字</code></pre><img src="/2022/09/19/docker-xue-xi-bi-ji/135.jpg" class><h3 id="16-1-网络模式"><a href="#16-1-网络模式" class="headerlink" title="16.1 网络模式"></a>16.1 网络模式</h3><ul><li>总体介绍</li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/136.jpg" class><pre class="language-none"><code class="language-none">bridge模式：使用--network  bridge指定，默认使用docker0host模式：使用--network host指定none模式：使用--network none指定container模式：使用--network container:NAME或者容器ID指定</code></pre><p>docker 容器内部的ip是有可能会发生改变的</p><h4 id="16-1-1-bridge"><a href="#16-1-1-bridge" class="headerlink" title="16.1.1 bridge"></a>16.1.1 bridge</h4><p>Docker 服务默认会创建一个 docker0 网桥（其上有一个 docker0 内部接口），该桥接网络的名称为docker0，它在内核层连通了其他的物理或虚拟网卡，这就将所有容器和本地主机都放到同一个物理网络。Docker 默认指定了 docker0 接口 的 IP 地址和子网掩码，让主机和容器之间可以通过网桥相互通信。</p><ol><li><p>Docker使用Linux桥接，在宿主机虚拟一个Docker容器网桥(docker0)，Docker启动一个容器时会根据Docker网桥的网段分配给容器一个IP地址，称为Container-IP，同时Docker网桥是每个容器的默认网关。因为在同一宿主机内的容器都接入同一个网桥，这样容器之间就能够通过容器的Container-IP直接通信。</p></li><li><p>docker run 的时候，没有指定network的话默认使用的网桥模式就是bridge，使用的就是docker0。在宿主机ifconfig,就可以看到docker0和自己create的network(后面讲)eth0，eth1，eth2……代表网卡一，网卡二，网卡三……，lo代表127.0.0.1，即localhost，inet addr用来表示网卡的IP地址</p></li><li><p>网桥docker0创建一对对等虚拟设备接口一个叫veth，另一个叫eth0，成对匹配。</p></li></ol><p>  3.1 整个宿主机的网桥模式都是docker0，类似一个交换机有一堆接口，每个接口叫veth，在本地主机和容器内分别创建一个虚拟接口，并让他们彼此联通（这样一对接口叫veth pair）；</p><p>  3.2 每个容器实例内部也有一块网卡，每个接口叫eth0；</p><p>  3.3 docker0上面的每个veth匹配某个容器实例内部的eth0，两两配对，一一匹配。</p><p> 通过上述，将宿主机上的所有容器都连接到这个内部网络上，两个容器在同一个网络下,会从这个网关下各自拿到分配的ip，此时两个容器的网络是互通的。</p><img src="/2022/09/19/docker-xue-xi-bi-ji/137.jpg" class><ul><li>两两匹配验证</li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/138.jpg" class><h4 id="16-1-2-host"><a href="#16-1-2-host" class="headerlink" title="16.1.2 host"></a>16.1.2 host</h4><p>直接使用宿主机的 IP 地址与外界进行通信，不再需要额外进行NAT 转换。</p><p>容器将不会获得一个独立的Network Namespace， 而是和宿主机共用一个Network Namespace。容器将不会虚拟出自己的网卡而是使用宿主机的IP和端口。</p><img src="/2022/09/19/docker-xue-xi-bi-ji/139.jpg" class><p><code>docker run -d -p 8083:8080 --network host --name tomcat83 billygoo/tomcat8-jdk8</code></p><img src="/2022/09/19/docker-xue-xi-bi-ji/140.jpg" class><ul><li><p>问题：</p><p> docke启动时总是遇见标题中的警告</p></li><li><p>原因：</p><p>docker启动时指定–network=host或-net=host，如果还指定了-p映射端口，那这个时候就会有此警告，</p></li></ul><p>并且通过-p设置的参数将不会起到任何作用，端口号会以主机端口号为主，重复时则递增。</p><ul><li><p>解决:</p><p>解决的办法就是使用docker的其他网络模式，例如–network=bridge，这样就可以解决问题，或者直接无视</p></li></ul><p><code>docker run -d --network host --name tomcat83 billygoo/tomcat8-jdk8</code></p><img src="/2022/09/19/docker-xue-xi-bi-ji/141.jpg" class><ul><li>没有设置-p的端口映射了，如何访问启动的tomcat83？</li></ul><p><code>http://宿主机IP:8080/</code></p><p>在CentOS里面用默认的火狐浏览器访问容器内的tomcat83看到访问成功，因为此时容器的IP借用主机的，</p><p>所以容器共享宿主机网络IP，这样的好处是外部主机与容器可以直接通信。</p><h4 id="16-1-3-none"><a href="#16-1-3-none" class="headerlink" title="16.1.3 none"></a>16.1.3 none</h4><p>在none模式下，并不为Docker容器进行任何网络配置。 也就是说，这个Docker容器没有网卡、IP、路由等信息，只有一个lo，需要我们自己为Docker容器添加网卡、配置IP等。</p><p><code>docker run -d -p 8084:8080 --network none --name tomcat84 billygoo/tomcat8-jdk8</code></p><ul><li>进入容器内部查看</li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/142.jpg" class><ul><li>在容器外部查看</li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/143.jpg" class><h4 id="16-1-4-container"><a href="#16-1-4-container" class="headerlink" title="16.1.4 container"></a>16.1.4 container</h4><p>container⽹络模式 </p><p>新建的容器和已经存在的一个容器共享一个网络ip配置而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。</p><img src="/2022/09/19/docker-xue-xi-bi-ji/144.jpg" class><h4 id="16-1-5-自定义网络"><a href="#16-1-5-自定义网络" class="headerlink" title="16.1.5 自定义网络"></a>16.1.5 自定义网络</h4><ul><li>新建自定义网络</li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/145.jpg" class><ul><li>新建容器加入上一步新建的自定义网络</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -d -p <span class="token number">8081</span>:8080 --network zzyy_network  --name tomcat81 billygoo/tomcat8-jdk8<span class="token function">docker</span> run -d -p <span class="token number">8082</span>:8080 --network zzyy_network  --name tomcat82 billygoo/tomcat8-jdk8</code></pre><ul><li>相互ping测试</li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/146.jpg" class><img src="/2022/09/19/docker-xue-xi-bi-ji/147.jpg" class><ul><li>问题结论</li></ul><p>自定义网络本身就维护好了主机名和ip的对应关系（ip和域名都能通）</p><h2 id="17-Docker-conpose-容器编排"><a href="#17-Docker-conpose-容器编排" class="headerlink" title="17. Docker-conpose 容器编排"></a>17. Docker-conpose 容器编排</h2><h3 id="17-1-是什么"><a href="#17-1-是什么" class="headerlink" title="17.1 是什么"></a>17.1 是什么</h3><p>Compose 是 Docker 公司推出的一个工具软件，可以管理多个 Docker 容器组成一个应用。你需要定义一个 YAML 格式的配置文件docker-compose.yml，写好多个容器之间的调用关系。然后，只要一个命令，就能同时启动/关闭这些容器</p><ul><li>Docker-Compose是Docker官方的开源项目， 负责实现对Docker容器集群的快速编排</li></ul><h3 id="17-2-能干什么"><a href="#17-2-能干什么" class="headerlink" title="17.2 能干什么"></a>17.2 能干什么</h3><p>docker建议我们每一个容器中只运行一个服务,因为docker容器本身占用资源极少,所以最好是将每个服务单独的分割开来但是这样我们又面临了一个问题？</p><p>如果我需要同时部署好多个服务,难道要每个服务单独写Dockerfile然后在构建镜像,构建容器,这样累都累死了,所以docker官方给我们提供了docker-compose多服务部署的工具</p><p>例如要实现一个Web微服务项目，除了Web服务容器本身，往往还需要再加上后端的数据库mysql服务容器，redis服务器，注册中心eureka，甚至还包括负载均衡容器等等。。。。。。</p><p>Compose允许用户通过一个单独的docker-compose.yml模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。</p><p>可以很容易地用一个配置文件定义一个多容器的应用，然后使用一条指令安装这个应用的所有依赖，完成构建。Docker-Compose 解决了容器与容器之间如何管理编排的问题。</p><h3 id="17-3-下载"><a href="#17-3-下载" class="headerlink" title="17.3 下载"></a>17.3 下载</h3><p><code>https://docs.docker.com/compose/compose-file/compose-file-v3/</code></p><p><code>https://docs.docker.com/compose/install/</code></p><ul><li>安装步骤</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">curl</span> -L <span class="token string">"https://github.com/docker/compose/releases/download/1.29.2/docker-compose-<span class="token variable"><span class="token variable">$(</span><span class="token function">uname</span> -s<span class="token variable">)</span></span>-<span class="token variable"><span class="token variable">$(</span><span class="token function">uname</span> -m<span class="token variable">)</span></span>"</span> -o /usr/local/bin/docker-compose<span class="token function">chmod</span> +x /usr/local/bin/docker-compose<span class="token function">docker-compose</span> --version</code></pre><img src="/2022/09/19/docker-xue-xi-bi-ji/148.jpg" class><ul><li>卸载</li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/149.jpg" class><h3 id="17-4-Compose-核心概念"><a href="#17-4-Compose-核心概念" class="headerlink" title="17.4 Compose 核心概念"></a>17.4 Compose 核心概念</h3><ul><li>一文件</li></ul><p>docker-compose.yml</p><ul><li>两要素</li></ul><p>服务：一个个应用容器实例，比如订单微服务、库存微服务、mysql容器、nginx容器或者redis容器</p><p>工程：由一组关联的应用容器组成的一个完整业务单元，在 docker-compose.yml 文件中定义</p><h3 id="17-5-Compose-使用三步骤"><a href="#17-5-Compose-使用三步骤" class="headerlink" title="17.5 Compose 使用三步骤"></a>17.5 Compose 使用三步骤</h3><ol><li>编写Dockerfile定义各个微服务应用并构建出对应的镜像文件</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 基础镜像使用java</span>FROM java:8<span class="token comment"># 作者</span>MAINTAINER zzyy<span class="token comment"># VOLUME 指定临时文件目录为/tmp，在主机/var/lib/docker目录下创建了一个临时文件并链接到容器的/tmp</span>VOLUME /tmp<span class="token comment"># 将jar包添加到容器中并更名为zzyy_docker.jar</span>ADD docker_boot-0.0.1-SNAPSHOT.jar zzyy_docker.jar<span class="token comment"># 运行jar包</span>RUN <span class="token function">bash</span> -c <span class="token string">'touch /zzyy_docker.jar'</span>ENTRYPOINT <span class="token punctuation">[</span><span class="token string">"java"</span>,<span class="token string">"-jar"</span>,<span class="token string">"/zzyy_docker.jar"</span><span class="token punctuation">]</span><span class="token comment">#暴露6001端口作为微服务</span>EXPOSE <span class="token number">6001</span></code></pre><p>构建进行：<code>docker build -t zzyy_docker:1.6 .</code></p><ol start="2"><li>使用 docker-compose.yml 定义一个完整业务单元，安排好整体应用中的各个容器服务。</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash">version: <span class="token string">"3"</span> services:  microService:    image: zzyy_docker:1.6    container_name: ms01    ports:      - <span class="token string">"6001:6001"</span>    volumes:      - /app/microService:/data    networks:       - atguigu_net     depends_on:       - redis      - mysql   redis:    image: redis:6.0.8    ports:      - <span class="token string">"6379:6379"</span>    volumes:      - /app/redis/redis.conf:/etc/redis/redis.conf      - /app/redis/data:/data    networks:       - atguigu_net    command: redis-server /etc/redis/redis.conf   mysql:    image: mysql:5.7    environment:      MYSQL_ROOT_PASSWORD: <span class="token string">'123456'</span>      MYSQL_ALLOW_EMPTY_PASSWORD: <span class="token string">'no'</span>      MYSQL_DATABASE: <span class="token string">'db2021'</span>      MYSQL_USER: <span class="token string">'zzyy'</span>      MYSQL_PASSWORD: <span class="token string">'zzyy123'</span>    ports:       - <span class="token string">"3306:3306"</span>    volumes:       - /app/mysql/db:/var/lib/mysql       - /app/mysql/conf/my.cnf:/etc/my.cnf       - /app/mysql/init:/docker-entrypoint-initdb.d    networks:      - atguigu_net    command: --default-authentication-plugin<span class="token operator">=</span>mysql_native_password <span class="token comment">#解决外部无法访问</span> networks:    atguigu_net: </code></pre><ol start="3"><li>最后，执行docker-compose up命令 来启动并运行整个应用程序，完成一键部署上线</li></ol><img src="/2022/09/19/docker-xue-xi-bi-ji/150.jpg" class><img src="/2022/09/19/docker-xue-xi-bi-ji/151.jpg" class><h3 id="17-6-Compose-常用命令"><a href="#17-6-Compose-常用命令" class="headerlink" title="17.6 Compose 常用命令"></a>17.6 Compose 常用命令</h3><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker-compose</span> -h                           <span class="token comment"># 查看帮助</span><span class="token function">docker-compose</span> up                           <span class="token comment"># 启动所有docker-compose服务</span><span class="token function">docker-compose</span> up -d                        <span class="token comment"># 启动所有docker-compose服务并后台运行</span><span class="token function">docker-compose</span> down                         <span class="token comment"># 停止并删除容器、网络、卷、镜像。</span><span class="token function">docker-compose</span> <span class="token builtin class-name">exec</span>  yml里面的服务id                 <span class="token comment"># 进入容器实例内部  docker-compose exec docker-compose.yml文件中写的服务id /bin/bash</span><span class="token function">docker-compose</span> <span class="token function">ps</span>                      <span class="token comment"># 展示当前docker-compose编排过的运行的所有容器</span><span class="token function">docker-compose</span> <span class="token function">top</span>                     <span class="token comment"># 展示当前docker-compose编排过的容器进程</span> <span class="token function">docker-compose</span> logs  yml里面的服务id     <span class="token comment"># 查看容器输出日志</span><span class="token function">docker-compose</span> config     <span class="token comment"># 检查配置</span><span class="token function">docker-compose</span> config -q  <span class="token comment"># 检查配置，有问题才有输出</span><span class="token function">docker-compose</span> restart   <span class="token comment"># 重启服务</span><span class="token function">docker-compose</span> start     <span class="token comment"># 启动服务</span><span class="token function">docker-compose</span> stop      <span class="token comment"># 停止服务</span></code></pre><h2 id="18-Docker轻量级可视化工具Portainer"><a href="#18-Docker轻量级可视化工具Portainer" class="headerlink" title="18. Docker轻量级可视化工具Portainer"></a>18. Docker轻量级可视化工具Portainer</h2><p><code>https://www.portainer.io/</code></p><p><code>https://docs.portainer.io/v/ce-2.9/start/install/server/docker/linux</code></p><h2 id="19-Docekr容器监控之-CAdvisor-InfluxDB-Granfana"><a href="#19-Docekr容器监控之-CAdvisor-InfluxDB-Granfana" class="headerlink" title="19. Docekr容器监控之 CAdvisor+InfluxDB+Granfana"></a>19. Docekr容器监控之 CAdvisor+InfluxDB+Granfana</h2>]]></content>
      
      
      <categories>
          
          <category> 容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux笔记</title>
      <link href="/2022/09/09/linux-bi-ji/"/>
      <url>/2022/09/09/linux-bi-ji/</url>
      
        <content type="html"><![CDATA[<div class="note success no-icon"><p>Linux入门</p></div><h2 id="1-Linux目录结构"><a href="#1-Linux目录结构" class="headerlink" title="1. Linux目录结构"></a>1. Linux目录结构</h2><ol><li><p>linux的文件系统是采用级层式的树状目录结构，在此结构中的最上层是根目录“/”，然后在此目录下再创建其他的目录。</p></li><li><p><strong>在Linux世界里，一切皆文件</strong></p></li></ol><img src="/2022/09/09/linux-bi-ji/01.png" class><ul><li><p><strong>/bin</strong>：<br>bin 是 Binaries (二进制文件) 的缩写, 这个目录存放着最经常使用的命令。</p></li><li><p><strong>/sbin</strong>：<br>s 就是 Super User 的意思，是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的系统管理程序。</p></li><li><p><strong>/root</strong>：<br>该目录为系统管理员，也称作超级权限者的用户主目录。</p></li><li><p><strong>/lib</strong>：<br>lib 是 Library(库) 的缩写这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。</p></li><li><p><strong>/lost+found</strong>：<br>这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</p></li><li><p><strong>/etc：</strong><br>etc 是 Etcetera(等等) 的缩写,这个目录用来存放所有的系统管理所需要的配置文件和子目录。</p></li><li><p><strong>/usr</strong>：<br> usr 是 unix shared resources(共享资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。</p></li><li><p><strong>/boot：</strong><br>这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。</p></li></ul><ul><li><p><strong>/proc</strong>：<br>proc 是 Processes(进程) 的缩写，/proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。<br>这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器：</p><pre class="language-none"><code class="language-none">echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all</code></pre></li></ul><ul><li><p><strong>/srv</strong>：<br> 该目录存放一些服务启动之后需要提取的数据。</p></li><li><p><strong>/sys</strong>：</p><p>这是 Linux2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs 。</p><p>sysfs 文件系统集成了下面3种文件系统的信息：针对进程信息的 proc 文件系统、针对设备的 devfs 文件系统以及针对伪终端的 devpts 文件系统。</p><p>该文件系统是内核设备树的一个直观反映。</p><p>当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。</p></li><li><p><strong>/tmp</strong>：<br>tmp 是 temporary(临时) 的缩写这个目录是用来存放一些临时文件的。</p></li><li><p><strong>/dev ：</strong><br>dev 是 Device(设备) 的缩写, 该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。</p></li><li><p><strong>/media</strong>：<br>linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。</p></li><li><p><strong>/mnt</strong>：<br>系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 /mnt/ 上，然后进入该目录就可以查看光驱里的内容了。</p></li><li><p><strong>/opt</strong>：<br>opt 是 optional(可选) 的缩写，这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。</p></li><li><p><strong>/var</strong>：<br>var 是 variable(变量) 的缩写，这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</p></li></ul><h2 id="2-vi和vim的基本介绍"><a href="#2-vi和vim的基本介绍" class="headerlink" title="2. vi和vim的基本介绍"></a>2. vi和vim的基本介绍</h2><ul><li><p>Linux系统会内置vi文本编辑器</p></li><li><p>vim具有程序编辑的能力，可以看做是vi的增强版本，可以主动的以字体颜色辨别语法的正确性，方便程序设计。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。</p></li></ul><h3 id="2-1-vi和vim常用的三种模式"><a href="#2-1-vi和vim常用的三种模式" class="headerlink" title="2.1 vi和vim常用的三种模式"></a>2.1 vi和vim常用的三种模式</h3><h4 id="2-1-1-正常模式"><a href="#2-1-1-正常模式" class="headerlink" title="2.1.1 正常模式"></a>2.1.1 正常模式</h4><p>​以<code>vim</code> 打开一个档案就直接进入一般模式了(<strong>这是默认的模式</strong>)。在这个模式中，你可以使用『上下左右』按键来移动光标，你可以使用『删除字符』或『删除整行』来处理档案内容，也可以使用『复制、粘贴』来处理你的文件数据。</p><h4 id="2-1-2-插入模式"><a href="#2-1-2-插入模式" class="headerlink" title="2.1.2 插入模式"></a>2.1.2 插入模式</h4><p>​按下<code>i，I，o，O，a，A，r，R</code>等任何一个字母之后才会进入编辑模式，一般来说按<code>i</code>即可.</p><h4 id="2-1-3-命令行模式"><a href="#2-1-3-命令行模式" class="headerlink" title="2.1.3 命令行模式"></a>2.1.3 命令行模式</h4><p>​按下<code>esc</code>键 再输入<code>:</code>，在这个模式当中，可以提供你相关指令，完成读取、存盘、替换、离开<code>vim</code> 、显示行号等的动作则是在此模式中达成的！</p><h3 id="2-2-各种模式的相互切换"><a href="#2-2-各种模式的相互切换" class="headerlink" title="2.2 各种模式的相互切换"></a>2.2 各种模式的相互切换</h3><img src="/2022/09/09/linux-bi-ji/02.png" class><h3 id="2-3-vi和vim快捷键"><a href="#2-3-vi和vim快捷键" class="headerlink" title="2.3 vi和vim快捷键"></a>2.3 vi和vim快捷键</h3><ol><li><p>拷贝当前行yy ，拷贝当前行向下的5行5yy，并粘贴（输入p)。</p></li><li><p>删除当前行dd,删除当前行向下的5行5dd</p></li><li><p>在文件中查找某个单词【 <strong>命令行下</strong>/关键字，回车查找，输入 n就是查找下一个】</p></li><li><p>设置文件的行号，取消文件的行号 [ <strong>命令行下</strong>: set nu和:set nonu ]</p></li><li><p>编辑/etc/profile 文件，<strong>在一般模式下</strong>，使用快捷键到该文档的最末行[G]和最首行[gg]</p></li><li><p>在一个文件中输入”hello” ,<strong>在一般模式下</strong>，然后又撤销这个动作u</p></li><li><p>编辑/etc/profile文件，把光标快速定位到20行，<strong>在一般模式下</strong>，输入20，再输入shift+g</p></li></ol><img src="/2022/09/09/linux-bi-ji/03.png" class><p>更多常用快捷键：<a href="http://www.baidu.com/">www.baidu.com</a></p><h2 id="3-关机和重启命令"><a href="#3-关机和重启命令" class="headerlink" title="3. 关机和重启命令"></a>3. 关机和重启命令</h2><ul><li><p>基本介绍</p><p>shutdown -h now立刻进行关机</p><p>shutdown -h  11分钟后会关机</p><p>shutdown -r now现在重新启动计算机</p><p>halt关机，作用和上面一样</p><p>reboot现在重新启动计算机</p><p>sync把内存的数据同步到磁盘</p></li><li><p>注意细节</p></li></ul><ol><li>不管是重启系统还是关闭系统，首先要运行sync命令，把内存中的数据写到磁盘中</li><li>目前的 shutdown/reboot/halt 等命令均已经在关机前进行了sync。</li></ol><h2 id="4-用户登录和注销"><a href="#4-用户登录和注销" class="headerlink" title="4. 用户登录和注销"></a>4. 用户登录和注销</h2><ul><li>基本介绍</li></ul><ol><li>登录时尽量少用root账号登录，因为它是管理员，最大的权限，避免操作失误。可以利用普通用户登录，登录后再用“su - 用户名” 命令来切换成系统管理员身份；</li><li>在提示符下输入logout即可注销用户</li></ol><ul><li>使用细节</li></ul><ol><li>logout注销指令在图形运行级别无效，在运行级别3下有效</li></ol><h2 id="5-用户管理"><a href="#5-用户管理" class="headerlink" title="5. 用户管理"></a>5. 用户管理</h2><h3 id="5-1-添加用户"><a href="#5-1-添加用户" class="headerlink" title="5.1 添加用户"></a>5.1 添加用户</h3><p>语法：useradd    用户名</p><p>细节：</p><ol><li>当创建用户成功后，会自动的创建和用户同名的家目录 /home/xxx</li><li>也可以通过useradd -d 指定目录 新的用户名，给新创建的用户指定家目录（useradd -d home/myfile woniu）</li></ol><h3 id="5-2-修改密码"><a href="#5-2-修改密码" class="headerlink" title="5.2 修改密码"></a>5.2 修改密码</h3><p>语法：password    用户名</p><h3 id="5-3-删除用户"><a href="#5-3-删除用户" class="headerlink" title="5.3 删除用户"></a>5.3 删除用户</h3><p>语法： userdel用户名（保留家目录）    userdel -r 用户名（家目录一并删除）</p><h3 id="5-4-查询用户信息"><a href="#5-4-查询用户信息" class="headerlink" title="5.4 查询用户信息"></a>5.4 查询用户信息</h3><p>语法：id  用户名</p><h3 id="5-5-切换用户"><a href="#5-5-切换用户" class="headerlink" title="5.5 切换用户"></a>5.5 切换用户</h3><p>语法：su  - 用户名</p><p>细节说明：</p><ol><li>从权限高的用户切换到权限低的用户，不需要输入密码，反之需要</li><li>当需要返回到原来用户时，使用exit/logout指令</li></ol><h3 id="5-6-用户组"><a href="#5-6-用户组" class="headerlink" title="5.6 用户组"></a>5.6 用户组</h3><p>介绍：类似于角色，系统可以对有共同权限的多个用户进行统一管理</p><p>新增组：groupadd  组名</p><p>删除组：groupdel  组名</p><p>增加用户时直接加上组：useradd -g 用户组 用户名</p><p>修改用户组：usermod -g 用户组 用户名</p><h2 id="6-运行级别"><a href="#6-运行级别" class="headerlink" title="6. 运行级别"></a>6. 运行级别</h2><ul><li>基本介绍：</li></ul><p>0：关机</p><p>1： 单用户【找回丢失密码】</p><p>2：多用户状态没有网络服务</p><p>3：多用户状态有网络服务</p><p>4：系统未使用保留给用户</p><p>5：图形界面</p><p>6：系统重启</p><p>常用运行级别是3和5，也可以指定默认运行级别（切换运行级别：init 3）</p><h2 id="7-文件目录"><a href="#7-文件目录" class="headerlink" title="7. 文件目录"></a>7. 文件目录</h2><ul><li><p>pwd 指令：显示当前工作目录的绝对路径</p></li><li><p>cd 指令：切换到指定目录（cd ..回到当前目录的上一级目录，cd ~或cd 回到当前用户的家目录）</p></li><li><p>mkdir 指令：创建目录（一级目录：mkdir /home/woniu   多级目录：mkdir <strong>-p</strong> /home/woniu/file）</p></li><li><p>rmdir 指令：删除空目录（rm <strong>-rf</strong> /home/ 强制删除）</p></li><li><p>cp指令：拷贝文件到指定目录</p><ul><li>语法：cp [选项] source dest；</li><li>常用选项 -r：递归复制整个文件夹；</li><li>强制覆盖不提示的方法： \cp -r /home/woniu</li></ul></li><li><p>rm指令：移除文件或目录</p><ul><li>语法：rm [选项] 要删除的文件或目录</li><li>常用选项： -r 递归删除整个文件夹  -f 强制删除不提示</li></ul></li><li><p>mv指令：移动文件或目录或重命名</p><ul><li>语法：mv oldFile newFile(重命名)、mv file /home/xxx</li></ul></li><li><p>cat指令：查看文件内容</p><ul><li>语法：cat [选项] 要查看的文件    选项： -n显示行号</li></ul></li><li><p>more指令：基于VI编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件的内容</p><ul><li>语法：more 要查看的文件</li><li>操作：空格（下翻一页）、Enter（下翻一行）、 q（离开more）、Ctrl+F（下滚一屏）、Ctrl + B（返回上一层）、=（输出当前行的行号）、:f输出文件名和当前行的</li></ul></li><li><p>less指令：用来分屏查看文件内容，它的功能与more指令类似，但是比more指令更强大，支持各种终端；less指令显示内容时。一个将整个文件加载之后显示，而是根据，对于显示大型具有较高的销较高文件具体较高的效率。</p><ul><li>语法：空白键（向反动解冻下）、pagedown（向下翻动一页）pageup（向上翻动一页）、/字串（向下搜寻[字典]，n:向下 N（向下））、？字串（向上搜寻）、q（离开less）</li></ul></li><li><p>echo指令：输出内容到控制台显示</p><ul><li>echo “hello”</li></ul></li><li><p>head指令：head用于显示文件的开头部分内容，默认情况下head指令显示文件的前10行内容</p><ul><li>语法：head -n 5 文件（查看文件前5行内容）</li></ul></li><li><p>tail指令：用于输出文件中尾部的内容，默认情况下tail指令显示的文件的前10行</p><ul><li>语法：tail 文件、 tail -n 5 文件、tail -f 实时追踪该文档的所有内容</li></ul></li></ul><h2 id="8-搜索查找"><a href="#8-搜索查找" class="headerlink" title="8. 搜索查找"></a>8. 搜索查找</h2><ul><li><p>find指令：从指定目录向下递归地遍历其各个子目录，将满足条件的文件或者目录显示在终端</p><ul><li>语法：find [搜索范围] [选项]   </li><li>选项：<ul><li>-name&lt;查询方式&gt; 按照指定的文件名查询模式查找文件</li><li>-user&lt;用户名&gt;查找属于用户名所有文件</li><li>-size&lt;文件大小&gt;按照指定的文件大小查找文件（+n大于、-n小于、n等于，+200M大于200M）</li></ul></li></ul></li><li><p>locate指令：可以快速定位文件路径</p><p><strong>注意：</strong>由于locate指令基于数据库进行查询，所有第一次运行前，必须使用updatedb指令创建locate数据库</p></li><li><p>which指令：可以查看某个指令在哪个目录下</p></li></ul><h2 id="9-压缩和解压"><a href="#9-压缩和解压" class="headerlink" title="9. 压缩和解压"></a>9. 压缩和解压</h2><ul><li><p>gzip/gunzip指令：gzip用于压缩文件/文件夹，gunzip用于解压</p><ul><li>语法：<ul><li>gzip  文件（只能将文件压缩为*.gz文件）</li><li>gunzip  文件.gz （添加-d&lt;目录&gt; 指定解压后文件的存放路径）</li></ul></li></ul></li><li><p>tar指令：</p><ul><li>选项：<ul><li>-c 产生.tar打包文件</li><li>-v 显示详细信息</li><li>-f 指定压缩后的文件名</li><li>-z 打包同时压缩</li><li>-x 解包.tar文件</li></ul></li><li>打包文件常用tar -zcvf xxx.tar.gz 打包的内容</li><li>解包文件常用tar -xcvf  xxx.tar.gz -C 解压到指定的目录</li></ul></li></ul><h2 id="10-权限的基本介绍"><a href="#10-权限的基本介绍" class="headerlink" title="10. 权限的基本介绍"></a>10. 权限的基本介绍</h2><h3 id="10-1-rwx权限详解"><a href="#10-1-rwx权限详解" class="headerlink" title="10.1 rwx权限详解"></a>10.1 rwx权限详解</h3><ul><li><p>rwx作用到文件</p><ol><li>r 代表可读(read):可以读取，查看</li><li>w 代表可写(write):可以修改，但是不代表可以删除该文件，删除一个文件的前提条件是对该文件所在的目录有写的权限，才能删除该文件</li><li>x 代表可执行(execute):可以被执行</li></ol></li><li><p>rwx作用到目录</p><ol><li>r 代表可读(read):可以读取，ls查看目录内容</li><li>w 代表可写(write):可以修改，对目录内创建+删除+重命名目录</li><li>x 代表可执行(execute):可以进入该目录</li></ol></li></ul><p>ls -l中显示的内容如下：</p><p>-<font color="#dd0000">rwx</font><font color="#00dd00">rw-</font><font color="#0000dd">r–</font> 1 root root 1213 Feb 2 09:39 abc</p><p>0-9位说明：</p><ul><li>第0位确定文件类型（d, -, l, c, b）<ul><li>－是普通文件</li><li>l 是链接，相当于windows的快捷方式</li><li>d 是目录，相当于windows的文件夹</li><li>c 是字符设备文件，鼠标、键盘</li><li>b 是块设备，如硬盘</li></ul></li><li>第1-3位确定所有者（该文件的所有者）拥有该文件的权限。</li><li>第4-6位确定所属组（同用户组的）拥有该文件的权限。</li><li>第7-9位确定其他用户拥有该文件的权限。</li></ul><p>可用数字表示为：r=4, w=2, x=1 因此rwx=4+2+1=7</p><p>其他说明：</p><p>1文件：硬连接数或目录：子目录数</p><p>root用户</p><p>root组</p><p>1213文件大小(字节)，如果是文件夹，显示4096字节</p><p>Feb 2 09:39最后修改日期</p><p>abc文件名</p><h3 id="10-2-修改权限-chmod"><a href="#10-2-修改权限-chmod" class="headerlink" title="10.2 修改权限 -chmod"></a>10.2 修改权限 -chmod</h3><p>通过chmod指令，可以修改文件或者目录的权限</p><p>方式一：+、-、= 变更权限</p><p>​u:所有者g:所有者o:其他人a:所有人(u、g、o的总和)</p><ol><li>chmodu=rwx,g=rx,o=x文件/目录名</li><li>chmod    o+w    文件/目录名</li><li>chmod    a-x    文件/目录名</li></ol><p>方式二：通过数字变更权限</p><p>​r=4, w=2, x=1rwx=4+2+1=7</p><p>​chmodu=rwx,g=rx,o=x文件/目录名</p><p>相当于 chmod751文件/目录名</p><h2 id="11-定时任务调度"><a href="#11-定时任务调度" class="headerlink" title="11. 定时任务调度"></a>11. 定时任务调度</h2><h3 id="11-1-crond任务调度"><a href="#11-1-crond任务调度" class="headerlink" title="11.1 crond任务调度"></a>11.1 crond任务调度</h3><img src="/2022/09/09/linux-bi-ji/04.png" class><img src="/2022/09/09/linux-bi-ji/05.png" class><img src="/2022/09/09/linux-bi-ji/06.png" class><p>crond 相关指令：</p><ul><li>crontab -r：终止任务调度</li><li>crontab -l：列出当前有哪些任务调度</li><li>service crond restart  重启任务调度</li></ul><h3 id="11-2-at任务调度"><a href="#11-2-at任务调度" class="headerlink" title="11.2 at任务调度"></a>11.2 at任务调度</h3><h2 id="12-主机名和hosts映射"><a href="#12-主机名和hosts映射" class="headerlink" title="12. 主机名和hosts映射"></a>12. 主机名和hosts映射</h2><h3 id="12-1-设置主机名和hosts映射"><a href="#12-1-设置主机名和hosts映射" class="headerlink" title="12.1 设置主机名和hosts映射"></a>12.1 设置主机名和hosts映射</h3><img src="/2022/09/09/linux-bi-ji/07.png" class><h3 id="12-2-主机名解析机制分析"><a href="#12-2-主机名解析机制分析" class="headerlink" title="12.2 主机名解析机制分析"></a>12.2 主机名解析机制分析</h3><p>用户在浏览器输入<a href="http://www.baidu.com：">www.baidu.com：</a></p><ol><li>检查本地解析器缓存（浏览器缓存、DNS解析器缓存）</li><li>检查系统中hosts文件是否配置对应的域名IP映射</li><li>到域名服务DNS进行解析域</li></ol><p>浏览器缓存 –&gt; DNS缓存 –&gt; hosts –&gt; DNS</p><h2 id="13-进程管理"><a href="#13-进程管理" class="headerlink" title="13. 进程管理"></a>13. 进程管理</h2><img src="/2022/09/09/linux-bi-ji/08.png" class><h3 id="终止进行kill和killall"><a href="#终止进行kill和killall" class="headerlink" title="终止进行kill和killall"></a>终止进行kill和killall</h3><ul><li>基本语法：<ul><li>kill [选项] 进程号（通过进程号杀死/终止进程）</li><li>killall 进程名称（通过进程名称杀死进程）</li></ul></li><li>常用选项<ul><li>-9 ：表示强迫进程立即停止</li></ul></li></ul><h2 id="14-服务管理"><a href="#14-服务管理" class="headerlink" title="14. 服务管理"></a>14. 服务管理</h2><img src="/2022/09/09/linux-bi-ji/09.png" class><img src="/2022/09/09/linux-bi-ji/10.png" class><h2 id="15-RPM与YUM"><a href="#15-RPM与YUM" class="headerlink" title="15. RPM与YUM"></a>15. RPM与YUM</h2><h3 id="15-1-RPM"><a href="#15-1-RPM" class="headerlink" title="15.1 RPM"></a>15.1 RPM</h3><p>rpm用于互联网下载包的打包及安装工具。</p><p>rpm包的简单查询指令：rpm -qa | grep xxx</p><img src="/2022/09/09/linux-bi-ji/11.png" class><p>卸载rpm包：</p><img src="/2022/09/09/linux-bi-ji/12.png" class><p>安装rpm包：</p><img src="/2022/09/09/linux-bi-ji/13.png" class><h3 id="15-2-YUM"><a href="#15-2-YUM" class="headerlink" title="15.2 YUM"></a>15.2 YUM</h3><img src="/2022/09/09/linux-bi-ji/14.png" class><h2 id="16-Shell脚本"><a href="#16-Shell脚本" class="headerlink" title="16. Shell脚本"></a>16. Shell脚本</h2><h3 id="16-1-Shell的变量"><a href="#16-1-Shell的变量" class="headerlink" title="16.1 Shell的变量"></a>16.1 Shell的变量</h3><p>变量介绍：</p><ol><li>Linux Shell中的变量分为系统变量和用户自定义变量；</li><li>系统变量：$HOME、$PWD、$USER等等</li><li>显示当前shell中所有变量：set</li></ol><p>自定义变量：</p><ol><li>定义变量：变量=值（中间没有空格）</li><li>撤销变量：unset 变量</li><li>声明静态变量：readonly变量，注意不能unset</li></ol><img src="/2022/09/09/linux-bi-ji/15.png" class><p>定义变量规则：</p><ol><li>变量名称可以由字母、数字和下划线组成，但是不能以数字开头</li><li>等号两侧不能有空格</li><li>变量名称一般习惯为大写，这是一个规范；</li></ol><p>将命令的返回值赋给变量：</p><ol><li>A=<code>`date`</code>反引号，运行里面的命令，并把结构返回给变量A</li><li>A=$(date) 等价于反引号</li></ol><h3 id="16-2-设置环境变量"><a href="#16-2-设置环境变量" class="headerlink" title="16.2 设置环境变量"></a>16.2 设置环境变量</h3><p>基本语法：</p><ol><li>export 变量名=变量值（将shell变量输出为环境变量/全局变量）</li><li>source 配置文件（让修改后的配置信息立即生效）</li><li>echo $变量名（查询环境变量的值）</li></ol><img src="/2022/09/09/linux-bi-ji/16.png" class><p>使用环境变量：</p><img src="/2022/09/09/linux-bi-ji/17.png" class><h3 id="16-3-位置参数变量"><a href="#16-3-位置参数变量" class="headerlink" title="16.3 位置参数变量"></a>16.3 位置参数变量</h3><p>介绍：</p><p>​当我们执行一个shell脚本时，如果希望获取到命令行的参数信息，就可以使用到位置参数变量比如：./myshell.sh 100 200，这个就是一个执行shell的命令行，可以在myshell脚本中获取到参数信息</p><p>基本语法：</p><p>$n（n为数字，$0代表命令本身，$1-$9代表第一到第九个参数，十以上的参数需要用大括号包含，如${10}）</p><p>$*（这个变量代表命令行中所有的参数，把所有的参数看成一个整体）</p><p>$@（这个变量也代表命令行中所有参数，把每个参数区分对待）</p><p>$#（这个变量代表命令行中所有参数的个数）</p><img src="/2022/09/09/linux-bi-ji/18.png" class><img src="/2022/09/09/linux-bi-ji/19.png" class><h3 id="16-4-Shell基本语法"><a href="#16-4-Shell基本语法" class="headerlink" title="16.4 Shell基本语法"></a>16.4 Shell基本语法</h3><p><a href="http://www.baidu.com/">www.baidu.com</a></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx入门</title>
      <link href="/2022/09/08/nginx-ru-men/"/>
      <url>/2022/09/08/nginx-ru-men/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Nginx简介"><a href="#1-Nginx简介" class="headerlink" title="1. Nginx简介"></a>1. Nginx简介</h2><ul><li><p>Nginx (engine x) 是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务。Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点（俄文：Рамблер）开发的，第一个公开版本0.1.0发布于2004年10月4日。2011年6月1日，nginx 1.0.4发布。</p></li><li><p>其特点是占有内存少，并发能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。在全球活跃的网站中有12.18%的使用比率，大约为2220万个网站。</p></li><li><p>Nginx 是一个安装非常的简单、配置文件非常简洁（还能够支持perl语法）、Bug非常少的服务。Nginx 启动特别容易，并且几乎可以做到7*24不间断运行，即使运行数个月也不需要重新启动。你还能够不间断服务的情况下进行软件版本的升级。</p></li><li><p>Nginx代码完全用C语言从头写成。官方数据测试表明能够支持高达 50,000 个并发连接数的响应。</p></li></ul><h2 id="2-Nginx作用"><a href="#2-Nginx作用" class="headerlink" title="2. Nginx作用"></a>2. Nginx作用</h2><div class="note success no-icon"><p>Http代理，反向代理：作为web服务器最常用的功能之一，尤其是反向代理。</p></div><ul><li>正向代理：代理客户端</li></ul><img src="/2022/09/08/nginx-ru-men/01.png" class><ul><li>反向代理：代理服务器</li></ul><img src="/2022/09/08/nginx-ru-men/02.png" class><div class="note success no-icon"><p>Nginx提供的负载均衡策略有2种：内置策略和扩展策略。内置策略为轮询，加权轮询，Ip hash。扩展策略，就天马行空，只有你想不到的没有他做不到的。</p></div><ul><li>轮询</li></ul><img src="/2022/09/08/nginx-ru-men/03.png" class><ul><li>加权轮询（可根据服务器性能设置权重，处理更多请求）</li></ul><img src="/2022/09/08/nginx-ru-men/04.png" class><ul><li>iphash对客户端请求的ip进行hash操作，然后根据hash结果将同一个客户端ip的请求分发给同一台服务器进行处理，可以解决session不共享的问题。</li></ul><img src="/2022/09/08/nginx-ru-men/05.png" class><div class="note success no-icon"><p>动静分离，在我们的软件开发中，有些请求是需要后台处理的，有些请求是不需要经过后台处理的（如：css、html、jpg、js等等文件），这些不需要经过后台处理的文件称为静态文件。让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后，我们就可以根据静态资源的特点将其做缓存操作。提高资源响应的速度。</p></div><img src="/2022/09/08/nginx-ru-men/06.png" class><h2 id="3-Nginx安装"><a href="#3-Nginx安装" class="headerlink" title="3. Nginx安装"></a>3. Nginx安装</h2><h3 id="3-1-windows下安装"><a href="#3-1-windows下安装" class="headerlink" title="3.1 windows下安装"></a>3.1 windows下安装</h3><h4 id="3-1-1-下载nginx"><a href="#3-1-1-下载nginx" class="headerlink" title="3.1.1 下载nginx"></a>3.1.1 下载nginx</h4><p><a href="http://nginx.org/en/download.html">http://nginx.org/en/download.html</a> 下载稳定版本。<br>以nginx/Windows-1.16.1为例，直接下载 nginx-1.16.1.zip。<br>下载后解压，解压后如下：</p><img src="/2022/09/08/nginx-ru-men/07.png" class><h4 id="3-1-2-启动nginx"><a href="#3-1-2-启动nginx" class="headerlink" title="3.1.2 启动nginx"></a>3.1.2 启动nginx</h4><ol><li>直接双击nginx.exe，双击后一个黑色的弹窗一闪而过</li><li>打开cmd命令窗口，切换到nginx解压目录下，输入命令 <code>nginx.exe</code> ，回车即可</li></ol><h4 id="3-1-3-检查nginx是否启动成功"><a href="#3-1-3-检查nginx是否启动成功" class="headerlink" title="3.1.3 检查nginx是否启动成功"></a>3.1.3 检查nginx是否启动成功</h4><p>直接在浏览器地址栏输入网址 <a href="http://localhost/">http://localhost:80</a> 回车，出现以下页面说明启动成功！</p><img src="/2022/09/08/nginx-ru-men/08.png" class><h4 id="3-1-4-配置监听"><a href="#3-1-4-配置监听" class="headerlink" title="3.1.4 配置监听"></a>3.1.4 配置监听</h4><p>nginx的配置文件是conf目录下的nginx.conf，默认配置的nginx监听的端口为80，如果80端口被占用可以修改为未被占用的端口即可。</p><img src="/2022/09/08/nginx-ru-men/09.png" class><p>当我们修改了nginx的配置文件nginx.conf 时，不需要关闭nginx后重新启动nginx，只需要执行命令 <code>nginx -s reload</code> 即可让改动生效</p><h4 id="3-1-5-关闭nginx"><a href="#3-1-5-关闭nginx" class="headerlink" title="3.1.5 关闭nginx"></a>3.1.5 关闭nginx</h4><p>如果使用cmd命令窗口启动nginx， 关闭cmd窗口是不能结束nginx进程的，可使用两种方法关闭nginx</p><p>(1)输入nginx命令 <code>nginx -s stop</code>(快速停止nginx) 或 <code>nginx -s quit</code>(完整有序的停止nginx)</p><p>(2)使用taskkill <code>taskkill /f /t /im nginx.exe</code></p><pre class="language-none"><code class="language-none">taskkill是用来终止进程的，/f是强制终止 ./t终止指定的进程和任何由此启动的子进程。/im示指定的进程名称 .</code></pre><h3 id="3-2-linux下安装"><a href="#3-2-linux下安装" class="headerlink" title="3.2 linux下安装"></a>3.2 linux下安装</h3><h4 id="3-2-1-安装gcc"><a href="#3-2-1-安装gcc" class="headerlink" title="3.2.1 安装gcc"></a>3.2.1 安装gcc</h4><p>安装 nginx 需要先将官网下载的源码进行编译，编译依赖 gcc 环境，如果没有 gcc 环境，则需要安装：</p><pre class="language-none"><code class="language-none">yum install gcc-c++</code></pre><h4 id="3-2-2-PCRE-pcre-devel-安装"><a href="#3-2-2-PCRE-pcre-devel-安装" class="headerlink" title="3.2.2 PCRE pcre-devel 安装"></a>3.2.2 PCRE pcre-devel 安装</h4><p>PCRE(Perl Compatible Regular Expressions) 是一个Perl库，包括 perl 兼容的正则表达式库。nginx 的 http 模块使用 pcre 来解析正则表达式，所以需要在 linux 上安装 pcre 库，pcre-devel 是使用 pcre 开发的一个二次开发库。nginx也需要此库。命令：</p><pre class="language-none"><code class="language-none">yum install -y pcre pcre-devel</code></pre><h4 id="3-2-3-zlib-安装"><a href="#3-2-3-zlib-安装" class="headerlink" title="3.2.3 zlib 安装"></a>3.2.3 zlib 安装</h4><p>zlib 库提供了很多种压缩和解压缩的方式， nginx 使用 zlib 对 http 包的内容进行 gzip ，所以需要在 Centos 上安装 zlib 库。</p><pre class="language-none"><code class="language-none">yum install -y zlib zlib-devel</code></pre><h4 id="3-2-4-OpenSSL-安装"><a href="#3-2-4-OpenSSL-安装" class="headerlink" title="3.2.4 OpenSSL 安装"></a>3.2.4 OpenSSL 安装</h4><p>OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及 SSL 协议，并提供丰富的应用程序供测试或其它目的使用。<br>nginx 不仅支持 http 协议，还支持 https（即在ssl协议上传输http），所以需要在 Centos 安装 OpenSSL 库。</p><pre class="language-none"><code class="language-none">yum install -y openssl openssl-devel</code></pre><h4 id="3-2-5-下载安装包"><a href="#3-2-5-下载安装包" class="headerlink" title="3.2.5 下载安装包"></a>3.2.5 下载安装包</h4><p>手动下载.tar.gz安装包，地址：<a href="https://nginx.org/en/download.html">https://nginx.org/en/download.html</a></p><img src="/2022/09/08/nginx-ru-men/10.png" class><p>下载完毕上传到服务器</p><h4 id="3-2-6-解压"><a href="#3-2-6-解压" class="headerlink" title="3.2.6 解压"></a>3.2.6 解压</h4><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">tar</span> -zxvf nginx-1.18.0.tar.gz<span class="token builtin class-name">cd</span> nginx-1.18.0</code></pre><h4 id="3-2-7-配置"><a href="#3-2-7-配置" class="headerlink" title="3.2.7 配置"></a>3.2.7 配置</h4><p>使用默认配置，在nginx根目录下执行</p><pre class="language-bash" data-language="bash"><code class="language-bash">./configure<span class="token function">make</span><span class="token function">make</span> <span class="token function">install</span></code></pre><p>查找安装路径： <code>whereis nginx</code></p><h4 id="3-2-8-Nginx常用命令"><a href="#3-2-8-Nginx常用命令" class="headerlink" title="3.2.8 Nginx常用命令"></a>3.2.8 Nginx常用命令</h4><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /usr/local/nginx/sbin/./nginx  启动./nginx -s stop  停止./nginx -s quit  安全退出./nginx -s reload  重新加载配置文件<span class="token function">ps</span> aux<span class="token operator">|</span><span class="token function">grep</span> nginx  查看nginx进程</code></pre><p>启动成功访问 服务器ip:80</p><img src="/2022/09/08/nginx-ru-men/11.png" class><p>注意：如何连接不上，检查阿里云安全组是否开放端口，或者服务器防火墙是否开放端口！<br>相关命令：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 开启</span><span class="token function">service</span> firewalld start<span class="token comment"># 重启</span><span class="token function">service</span> firewalld restart<span class="token comment"># 关闭</span><span class="token function">service</span> firewalld stop<span class="token comment"># 查看防火墙规则</span>firewall-cmd --list-all<span class="token comment"># 查询端口是否开放</span>firewall-cmd --query-port<span class="token operator">=</span><span class="token number">8080</span>/tcp<span class="token comment"># 开放80端口</span>firewall-cmd --permanent --add-port<span class="token operator">=</span><span class="token number">80</span>/tcp<span class="token comment"># 移除端口</span>firewall-cmd --permanent --remove-port<span class="token operator">=</span><span class="token number">8080</span>/tcp<span class="token comment">#重启防火墙(修改配置后要重启防火墙)</span>firewall-cmd --reload<span class="token comment"># 参数解释</span><span class="token number">1</span>、firwall-cmd：是Linux提供的操作firewall的一个工具；<span class="token number">2</span>、--permanent：表示设置为持久；<span class="token number">3</span>、--add-port：标识添加的端口；</code></pre><h2 id="4-Nginx配置详解"><a href="#4-Nginx配置详解" class="headerlink" title="4. Nginx配置详解"></a>4. Nginx配置详解</h2><p>文件结构：</p><pre class="language-none"><code class="language-none">...              #全局配置events {         #events配置   ...}http {     #http配置    upstream edustudy {# 负载均衡配置，默认是轮询        server 127.0.0.1:8080 weight=1;# weight是权重        server 127.0.0.1:8081 weight=1;    }    server {        #server代理        listen       9001;        server_name  localhost;# 监听到之后转发到localhost                location / {  # 9001端口下的所有请求都会被匹配到这里proxy_pass http://edustudy;# 转发至负载均衡里        }                # www.edustudy.com/admin        location /admin {                    }                # 当地址中包含"eduService"时，请求会转发至 http://localhost:8085        location ~ /eduService/ {             proxy_pass http://localhost:8085;        }    }        server {      listen       9002;        server_name  localhost;    }}</code></pre><ul><li><strong>全局块</strong>：配置影响nginx全局的指令。一般有运行nginx服务器的用户组，nginx进程pid存放路径，日志存放路径，配置文件引入，允许生成worker process数等。</li></ul><ul><li><strong>events块</strong>：配置影响nginx服务器或与用户的网络连接。有每个进程的最大连接数，选取哪种事件驱动模型处理连接请求，是否允许同时接受多个网路连接，开启多个网络连接序列化等。</li><li><strong>http块</strong>：可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。如文件引入，mime-type定义，日志自定义，是否使用sendfile传输文件，连接超时时间，单连接请求数等。</li><li><strong>server块</strong>：配置虚拟主机的相关参数，一个http中可以有多个server。</li><li><strong>location块</strong>：配置请求的路由，以及各种页面的处理情况。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis基础知识</title>
      <link href="/2022/09/05/redis-ji-chu-zhi-shi/"/>
      <url>/2022/09/05/redis-ji-chu-zhi-shi/</url>
      
        <content type="html"><![CDATA[<div class="note success no-icon"><p>尚硅谷Redis 6笔记</p></div><h3 id="1-NoSQL-数据库"><a href="#1-NoSQL-数据库" class="headerlink" title="1. NoSQL 数据库"></a>1. NoSQL 数据库</h3><h4 id="1-1-NoSQL-数据库简介"><a href="#1-1-NoSQL-数据库简介" class="headerlink" title="1.1 NoSQL 数据库简介"></a>1.1 NoSQL 数据库简介</h4><p>NoSQL( <strong>Not Only SQL</strong> )，意即“不仅仅是SQL”，泛指<strong>非关系型的数据库</strong>（Redis、MongoDB ……）。 </p><p>NoSQL 不依赖业务逻辑方式存储，而以简单的key-value模式存储。因此大大的增加了数据库的扩展能力。</p><ul><li>不遵循SQL标准</li><li>不支持ACID</li><li>远超于SQL的性能</li></ul><h4 id="1-2-NoSQL-适用场景"><a href="#1-2-NoSQL-适用场景" class="headerlink" title="1.2 NoSQL 适用场景"></a>1.2 NoSQL 适用场景</h4><ul><li>对数据高并发的读写</li><li>海量数据的读写</li><li>对数据高扩展性的</li></ul><h4 id="1-3-NoSQL-不适用场景"><a href="#1-3-NoSQL-不适用场景" class="headerlink" title="1.3 NoSQL 不适用场景"></a>1.3 NoSQL 不适用场景</h4><ul><li>需要事务支持</li><li>基于sql的结构化查询存储，处理复杂的关系</li></ul><h3 id="2-Redis-介绍"><a href="#2-Redis-介绍" class="headerlink" title="2. Redis 介绍"></a>2. Redis 介绍</h3><p>Redis 是完全开源的，遵守 BSD 协议，是一个高性能的 key-value 数据库。</p><p>默认16个数据库，类似数组下标从0开始，默认使用0号库，使用命令select <dbid>来切换数据库。如：select 15</dbid></p><p>Redis 与其他 key - value 缓存产品有以下三个特点：</p><ul><li>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</li><li>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。</li><li>Redis支持数据的备份，即master-slave模式的数据备份。</li></ul><p>Redis是单线程 + 多路IO复用技术：</p><ul><li>Redis 内部使用文件事件处理器 file event handler，这个文件事件处理器是单线程的，所以 Redis 才叫做单线程的模型。</li><li>它采用 IO 多路复用机制同时监听多个 Socket，并把所有产生事件的socket压入一个队列中，然后有序地每次仅一个socket的方式传送给文件事件分派器，文件事件分派器接收到socket之后会根据socket产生的事件类型调用对应的事件处理器进行处理。</li></ul><img src="/2022/09/05/redis-ji-chu-zhi-shi/01.png" class><h3 id="3-常用五大数据类型"><a href="#3-常用五大数据类型" class="headerlink" title="3. 常用五大数据类型"></a>3. 常用五大数据类型</h3><p>String(字符串 最多长度512M)、Hash(哈希)、List(列表)、Set(集合)、ZSet(有序集合)</p><p>相关操作命令：<a href="http://www.redis.cn/commands.html">http://www.redis.cn/commands.html</a></p><h3 id="4-Redis的发布和订阅"><a href="#4-Redis的发布和订阅" class="headerlink" title="4. Redis的发布和订阅"></a>4. Redis的发布和订阅</h3><ol><li><p>客户端可以订阅频道如下图：</p><img src="/2022/09/05/redis-ji-chu-zhi-shi/02.png" class></li><li><p>当给这个频道发布消息后，消息就会发送给订阅的客户端</p><img src="/2022/09/05/redis-ji-chu-zhi-shi/03.png" class></li></ol><p><strong>注：</strong>发布的消息没有持久化，这就会导致新订阅的客户端将不会收到历史消息。（使用专业MQ）</p><h3 id="5-Redis新数据类型"><a href="#5-Redis新数据类型" class="headerlink" title="5. Redis新数据类型"></a>5. Redis新数据类型</h3><p> Bitmaps、HyperLogLog、Geospatial</p><h3 id="6-Redis与SpringBoot整合"><a href="#6-Redis与SpringBoot整合" class="headerlink" title="6. Redis与SpringBoot整合"></a>6. Redis与SpringBoot整合</h3><h4 id="1-在pom-xml文件中引入redis相关依赖"><a href="#1-在pom-xml文件中引入redis相关依赖" class="headerlink" title="1. 在pom.xml文件中引入redis相关依赖"></a>1. 在pom.xml文件中引入redis相关依赖</h4><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- redis --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-data-redis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!-- springboot2.x之后，操作redis的底层使用的Lettuce,而不是jedis --&gt;</span><span class="token comment">&lt;!-- Jedis：采用的直连，多个线程操作的话，是不安全的，如果想要避免不安全的，使用jedis pool 连接池！ --&gt;</span><span class="token comment">&lt;!-- Lettuce：采用netty,实例可以在多个线程中进行共享，不存在线程不安全的情况！可以减少线程数据了！--&gt;</span><span class="token comment">&lt;!-- spring2.X集成redis所需common-pool2--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.apache.commons<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>commons-pool2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>2.6.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span></code></pre><h4 id="2-application-yml-配置redis配置"><a href="#2-application-yml-配置redis配置" class="headerlink" title="2. application.yml 配置redis配置"></a>2. application.yml 配置redis配置</h4><pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">redis</span><span class="token punctuation">:</span>    <span class="token comment"># redis数据库索引(默认为0)，我们使用索引为3的数据库，避免和其他数据库冲突</span>    <span class="token key atrule">database</span><span class="token punctuation">:</span> <span class="token number">0</span>    <span class="token comment"># redis服务器地址（默认为loaclhost）</span>    <span class="token key atrule">host</span><span class="token punctuation">:</span> 192.168.79.150    <span class="token comment"># redis端口（默认为6379）</span>    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">6379</span>    <span class="token comment"># redis访问密码（默认为空）</span>    <span class="token key atrule">password</span><span class="token punctuation">:</span> <span class="token number">123456</span>    <span class="token comment"># redis连接超时时间（单位毫秒）</span>    <span class="token key atrule">timeout</span><span class="token punctuation">:</span> <span class="token number">0</span>    <span class="token comment"># redis连接池配置</span>    <span class="token key atrule">pool</span><span class="token punctuation">:</span>      <span class="token comment"># 最大可用连接数（默认为8，负数表示无限）</span>      <span class="token key atrule">max-active</span><span class="token punctuation">:</span> <span class="token number">8</span>      <span class="token comment"># 最大空闲连接数（默认为8，负数表示无限）</span>      <span class="token key atrule">max-idle</span><span class="token punctuation">:</span> <span class="token number">8</span>      <span class="token comment"># 最小空闲连接数（默认为0，该值只有为正数才有用）</span>      <span class="token key atrule">min-idle</span><span class="token punctuation">:</span> <span class="token number">0</span>      <span class="token comment"># 从连接池中获取连接最大等待时间（默认为-1，单位为毫秒，负数表示无限）</span>      <span class="token key atrule">max-wait</span><span class="token punctuation">:</span> <span class="token number">-1</span></code></pre><h4 id="3-添加redis配置类"><a href="#3-添加redis配置类" class="headerlink" title="3. 添加redis配置类"></a>3. 添加redis配置类</h4><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@EnableCaching</span><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedisConfig</span> <span class="token keyword">extends</span> <span class="token class-name">CachingConfigurerSupport</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> <span class="token function">redisTemplate</span><span class="token punctuation">(</span><span class="token class-name">RedisConnectionFactory</span> factory<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> template <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">RedisSerializer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> redisSerializer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringRedisSerializer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Jackson2JsonRedisSerializer</span> jackson2JsonRedisSerializer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Jackson2JsonRedisSerializer</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">ObjectMapper</span> om <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        om<span class="token punctuation">.</span><span class="token function">setVisibility</span><span class="token punctuation">(</span><span class="token class-name">PropertyAccessor</span><span class="token punctuation">.</span>ALL<span class="token punctuation">,</span> <span class="token class-name">JsonAutoDetect<span class="token punctuation">.</span>Visibility</span><span class="token punctuation">.</span>ANY<span class="token punctuation">)</span><span class="token punctuation">;</span>        om<span class="token punctuation">.</span><span class="token function">enableDefaultTyping</span><span class="token punctuation">(</span><span class="token class-name">ObjectMapper<span class="token punctuation">.</span>DefaultTyping</span><span class="token punctuation">.</span>NON_FINAL<span class="token punctuation">)</span><span class="token punctuation">;</span>        jackson2JsonRedisSerializer<span class="token punctuation">.</span><span class="token function">setObjectMapper</span><span class="token punctuation">(</span>om<span class="token punctuation">)</span><span class="token punctuation">;</span>        template<span class="token punctuation">.</span><span class="token function">setConnectionFactory</span><span class="token punctuation">(</span>factory<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//key序列化方式</span>        template<span class="token punctuation">.</span><span class="token function">setKeySerializer</span><span class="token punctuation">(</span>redisSerializer<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//value序列化</span>        template<span class="token punctuation">.</span><span class="token function">setValueSerializer</span><span class="token punctuation">(</span>jackson2JsonRedisSerializer<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//value hashmap序列化</span>        template<span class="token punctuation">.</span><span class="token function">setHashValueSerializer</span><span class="token punctuation">(</span>jackson2JsonRedisSerializer<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> template<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">CacheManager</span> <span class="token function">cacheManager</span><span class="token punctuation">(</span><span class="token class-name">RedisConnectionFactory</span> factory<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">RedisSerializer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> redisSerializer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringRedisSerializer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Jackson2JsonRedisSerializer</span> jackson2JsonRedisSerializer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Jackson2JsonRedisSerializer</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//解决查询缓存转换异常的问题</span>        <span class="token class-name">ObjectMapper</span> om <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        om<span class="token punctuation">.</span><span class="token function">setVisibility</span><span class="token punctuation">(</span><span class="token class-name">PropertyAccessor</span><span class="token punctuation">.</span>ALL<span class="token punctuation">,</span> <span class="token class-name">JsonAutoDetect<span class="token punctuation">.</span>Visibility</span><span class="token punctuation">.</span>ANY<span class="token punctuation">)</span><span class="token punctuation">;</span>        om<span class="token punctuation">.</span><span class="token function">enableDefaultTyping</span><span class="token punctuation">(</span><span class="token class-name">ObjectMapper<span class="token punctuation">.</span>DefaultTyping</span><span class="token punctuation">.</span>NON_FINAL<span class="token punctuation">)</span><span class="token punctuation">;</span>        jackson2JsonRedisSerializer<span class="token punctuation">.</span><span class="token function">setObjectMapper</span><span class="token punctuation">(</span>om<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 配置序列化（解决乱码的问题）,过期时间600秒</span>        <span class="token class-name">RedisCacheConfiguration</span> config <span class="token operator">=</span> <span class="token class-name">RedisCacheConfiguration</span><span class="token punctuation">.</span><span class="token function">defaultCacheConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">entryTtl</span><span class="token punctuation">(</span><span class="token class-name">Duration</span><span class="token punctuation">.</span><span class="token function">ofSeconds</span><span class="token punctuation">(</span><span class="token number">600</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">serializeKeysWith</span><span class="token punctuation">(</span><span class="token class-name">RedisSerializationContext<span class="token punctuation">.</span>SerializationPair</span><span class="token punctuation">.</span><span class="token function">fromSerializer</span><span class="token punctuation">(</span>redisSerializer<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">serializeValuesWith</span><span class="token punctuation">(</span><span class="token class-name">RedisSerializationContext<span class="token punctuation">.</span>SerializationPair</span><span class="token punctuation">.</span><span class="token function">fromSerializer</span><span class="token punctuation">(</span>jackson2JsonRedisSerializer<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">disableCachingNullValues</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">RedisCacheManager</span> cacheManager <span class="token operator">=</span> <span class="token class-name">RedisCacheManager</span><span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span>factory<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">cacheDefaults</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> cacheManager<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="7-Redis事务"><a href="#7-Redis事务" class="headerlink" title="7. Redis事务"></a>7. Redis事务</h3><h4 id="7-1-事务定义"><a href="#7-1-事务定义" class="headerlink" title="7.1 事务定义"></a>7.1 事务定义</h4><p>Redis事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p><p>Redis事务的主要作用就是串联多个命令防止别的命令插队。</p><h4 id="7-2-Multi、Exec、discard"><a href="#7-2-Multi、Exec、discard" class="headerlink" title="7.2 Multi、Exec、discard"></a>7.2 Multi、Exec、discard</h4><p>从输入Multi命令开始，输入的命令都会依次进入命令队列中，但不会执行，直到输入Exec后，Redis会将之前的命令队列中的命令依次执行。</p><p>组队的过程中可以通过discard来放弃组队。 </p><h4 id="7-3-事务的错误处理"><a href="#7-3-事务的错误处理" class="headerlink" title="7.3 事务的错误处理"></a>7.3 事务的错误处理</h4><ul><li><p>组队中某个命令出现了报告错误，执行时整个的所有队列都会被取消。</p></li><li><p>执行阶段某个命令报出了错误，则只有报错的命令不会被执行，而其他的命令都会执行，不会回滚。</p></li></ul><h4 id="7-4-事务冲突问题"><a href="#7-4-事务冲突问题" class="headerlink" title="7.4 事务冲突问题"></a>7.4 事务冲突问题</h4><img src="/2022/09/05/redis-ji-chu-zhi-shi/04.jpg" class><h5 id="7-4-1-悲观锁"><a href="#7-4-1-悲观锁" class="headerlink" title="7.4.1 悲观锁"></a>7.4.1 悲观锁</h5><p><strong>悲观锁(Pessimistic Lock)<strong>，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。</strong>传统的关系型数据库里边就用到了很多这种锁机制</strong>，比如<strong>行锁</strong>，<strong>表锁</strong>等，<strong>读锁</strong>，<strong>写锁</strong>等，都是在做操作之前先上锁。</p><img src="/2022/09/05/redis-ji-chu-zhi-shi/05.jpg" class><h5 id="7-4-2-乐观锁"><a href="#7-4-2-乐观锁" class="headerlink" title="7.4.2 乐观锁"></a>7.4.2 乐观锁</h5><p><strong>乐观锁(Optimistic Lock)<strong>，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。</strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量</strong>。Redis就是利用这种check-and-set机制实现事务的。</p><img src="/2022/09/05/redis-ji-chu-zhi-shi/06.jpg" class><h5 id="7-4-3-watch-key-key-…"><a href="#7-4-3-watch-key-key-…" class="headerlink" title="7.4.3 watch key [key …]"></a>7.4.3 watch key [key …]</h5><p>在执行multi之前，先执行watch key1 [key2],可以监视一个(或多个) key ，如果在事务<strong>执行之前这个(或这些) key被其他命令所改动，那么事务将被打断。</strong></p><h5 id="7-4-4-unwatch"><a href="#7-4-4-unwatch" class="headerlink" title="7.4.4 unwatch"></a>7.4.4 unwatch</h5><p>取消 watch命令对所有 key 的监视。</p><p>如果在执行 watch 命令之后，exec命令或discard命令先被执行了的话，那么就不需要再执行unwatch了。</p><h5 id="7-4-5-Redis事务三特性"><a href="#7-4-5-Redis事务三特性" class="headerlink" title="7.4.5 Redis事务三特性"></a>7.4.5 Redis事务三特性</h5><p>单独的隔离操作：</p><ul><li>事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断</li></ul><p>没有隔离级别的概念：</p><ul><li>队列中的命令没有提交之前都不会实际被执行，因为事务提交前任何指令都不会被实际执行</li></ul><p>不保证原子性：</p><ul><li>事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚</li></ul><h3 id="8-Redis持久化之RDB"><a href="#8-Redis持久化之RDB" class="headerlink" title="8. Redis持久化之RDB"></a>8. Redis持久化之RDB</h3><p>RDB(Redis DataBase)：</p><p>​在指定的时间间隔内将内存中的数据集快照写入磁盘， 也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里</p><h4 id="8-1-备份是如何执行的"><a href="#8-1-备份是如何执行的" class="headerlink" title="8.1 备份是如何执行的"></a>8.1 备份是如何执行的</h4><p>​Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到 一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。 整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能 如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。<strong>RDB的缺点是最后一次持久化后的数据可能丢失</strong>。</p><h4 id="8-2-Fork"><a href="#8-2-Fork" class="headerlink" title="8.2 Fork"></a>8.2 Fork</h4><ul><li>Fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等） 数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程</li><li>在Linux程序中，fork()会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，Linux中引入了“<strong>写时复制技术</strong>”</li><li><strong>一般情况父进程和子进程会共用同一段物理内存</strong>，只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。</li></ul><h4 id="8-3-dump-rdb文件"><a href="#8-3-dump-rdb文件" class="headerlink" title="8.3 dump.rdb文件"></a>8.3 dump.rdb文件</h4><p>在redis.conf中配置文件名称，默认为dump.rdb         </p><img src="/2022/09/05/redis-ji-chu-zhi-shi/07.png" class>                     <h4 id="8-4-配置位置"><a href="#8-4-配置位置" class="headerlink" title="8.4 配置位置"></a>8.4 配置位置</h4><p>rdb文件的保存路径，也可以修改。默认为Redis启动时命令行所在的目录下</p><p>dir “/myredis/“</p> <img src="/2022/09/05/redis-ji-chu-zhi-shi/08.png" class>         <h4 id="8-5-如何触发RDB快照；保持策略"><a href="#8-5-如何触发RDB快照；保持策略" class="headerlink" title="8.5 如何触发RDB快照；保持策略"></a>8.5 如何触发RDB快照；保持策略</h4><h5 id="8-5-1-配置文件中默认的快照配置"><a href="#8-5-1-配置文件中默认的快照配置" class="headerlink" title="8.5.1 配置文件中默认的快照配置"></a>8.5.1 配置文件中默认的快照配置</h5> <img src="/2022/09/05/redis-ji-chu-zhi-shi/09.png" class>         <h5 id="8-5-2-命令save-VS-bgsave"><a href="#8-5-2-命令save-VS-bgsave" class="headerlink" title="8.5.2 命令save VS bgsave"></a>8.5.2 命令save VS bgsave</h5><p>save ：save时只管保存，其它不管，全部阻塞。手动保存。不建议。</p><p><strong>bgsave：Redis会在后台异步进行快照操作，快照同时还可以响应客户端请求。</strong></p><p>可以通过lastsave 命令获取最后一次成功执行快照的时间</p><h5 id="8-5-3-flushall命令"><a href="#8-5-3-flushall命令" class="headerlink" title="8.5.3  flushall命令"></a>8.5.3  flushall命令</h5><p>执行flushall命令，也会产生dump.rdb文件，但里面是空的，无意义</p><h5 id="8-5-4-Save"><a href="#8-5-4-Save" class="headerlink" title="8.5.4 Save"></a>8.5.4 Save</h5><p>格式：save 秒钟 写操作次数</p><p>RDB是整个内存的压缩过的Snapshot，RDB的数据结构，可以配置复合的快照触发条件，</p><p><strong>默认是1分钟内改了万次，或5分钟内改了10次，或15分钟内改了1次。</strong></p><p>禁用</p><p>不设置save指令，或者给save传入空字符串</p><h5 id="8-5-5-stop-writes-on-bgsave-error"><a href="#8-5-5-stop-writes-on-bgsave-error" class="headerlink" title="8.5.5 stop-writes-on-bgsave-error"></a>8.5.5 <strong>stop-writes-on-bgsave-error</strong></h5><img src="/2022/09/05/redis-ji-chu-zhi-shi/10.png" class>      <p>当Redis无法写入磁盘的话，直接关掉Redis的写操作。推荐yes.</p><h5 id="8-5-6-rdbcompression压缩文件"><a href="#8-5-6-rdbcompression压缩文件" class="headerlink" title="8.5.6 rdbcompression压缩文件"></a>8.5.6 rdbcompression压缩文件</h5><img src="/2022/09/05/redis-ji-chu-zhi-shi/11.png" class>     <p>对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用LZF算法进行压缩。</p><p>如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能。推荐yes.</p><h5 id="8-5-7-rdbchecksum-检查完整性"><a href="#8-5-7-rdbchecksum-检查完整性" class="headerlink" title="8.5.7 rdbchecksum 检查完整性"></a>8.5.7 rdbchecksum 检查完整性</h5><img src="/2022/09/05/redis-ji-chu-zhi-shi/12.png" class>     <p>在存储快照后，还可以让redis使用CRC64算法来进行数据校验，</p><p>但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能</p><p>推荐yes.</p><h5 id="8-5-8-rdb的备份"><a href="#8-5-8-rdb的备份" class="headerlink" title="8.5.8 rdb的备份"></a>8.5.8 rdb的备份</h5><p>先通过config get dir 查询rdb文件的目录 </p><p>将*.rdb的文件拷贝到别的地方</p><p>rdb的恢复</p><ul><li><p>关闭Redis</p></li><li><p>先把备份的文件拷贝到工作目录下 cp dump2.rdb dump.rdb</p></li><li><p>启动Redis, 备份数据会直接加载</p></li></ul><h4 id="8-6-优势"><a href="#8-6-优势" class="headerlink" title="8.6 优势"></a>8.6 优势</h4><ul><li>适合大规模的数据恢复</li><li>对数据完整性和一致性要求不高更适合使用</li><li>节省磁盘空间</li><li>恢复速度快</li></ul> <img src="/2022/09/05/redis-ji-chu-zhi-shi/13.jpg" class>   <h4 id="8-7劣势"><a href="#8-7劣势" class="headerlink" title="8.7劣势"></a>8.7劣势</h4><ul><li>Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑</li><li>虽然Redis在fork时使用了<strong>写时拷贝技术</strong>,但是如果数据庞大时还是比较消耗性能。</li><li>在备份周期在一定间隔时间做一次备份，所以如果Redis意外down掉的话，就会丢失最后一次快照后的所有修改。</li></ul><h4 id="8-8-如何停止"><a href="#8-8-如何停止" class="headerlink" title="8.8 如何停止"></a>8.8 如何停止</h4><p>动态停止RDB：redis-cli config set save “”#save后给空值，表示禁用保存策略</p><h4 id="8-9-小总结"><a href="#8-9-小总结" class="headerlink" title="8.9 小总结"></a>8.9 小总结</h4>  <img src="/2022/09/05/redis-ji-chu-zhi-shi/14.jpg" class>   <h3 id="9-Redis持久化之AOF"><a href="#9-Redis持久化之AOF" class="headerlink" title="9. Redis持久化之AOF"></a>9. Redis持久化之AOF</h3><p>AOF(Append Only File)：</p><p>​以<strong>日志</strong>的形式来记录每个写操作（增量保存），将Redis执行过的所有写指令记录下来(<strong>读操作不记录</strong>)， <strong>只许追加文件但不可以改写文件</strong>，redis启动之初会读取该文件重新构建数据，换言之，redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作</p><h4 id="9-1-AOF持久化流程"><a href="#9-1-AOF持久化流程" class="headerlink" title="9.1 AOF持久化流程"></a>9.1 AOF持久化流程</h4><p>（1）客户端的请求写命令会被append追加到AOF缓冲区内；</p><p>（2）AOF缓冲区根据AOF持久化策略[always,everysec,no]将操作sync同步到磁盘的AOF文件中；</p><p>（3）AOF文件大小超过重写策略或手动重写时，会对AOF文件rewrite重写，压缩AOF文件容量；</p><p>（4）Redis服务重启时，会重新load加载AOF文件中的写操作达到数据恢复的目的；</p>  <img src="/2022/09/05/redis-ji-chu-zhi-shi/15.png" class>   <h4 id="9-2-AOF默认不开启"><a href="#9-2-AOF默认不开启" class="headerlink" title="9.2 AOF默认不开启"></a>9.2 AOF默认不开启</h4><p>​可以在redis.conf中配置文件名称，默认为 appendonly.aof</p><p>​AOF文件的保存路径，同RDB的路径一致。</p><h4 id="9-3-AOF和RDB同时开启，redis听谁的？"><a href="#9-3-AOF和RDB同时开启，redis听谁的？" class="headerlink" title="9.3 AOF和RDB同时开启，redis听谁的？"></a>9.3 AOF和RDB同时开启，redis听谁的？</h4><p>AOF和RDB同时开启，系统默认取AOF的数据（数据不会存在丢失）</p><h4 id="9-4-AOF启动-x2F-修复-x2F-恢复"><a href="#9-4-AOF启动-x2F-修复-x2F-恢复" class="headerlink" title="9.4 AOF启动/修复/恢复"></a>9.4 AOF启动/修复/恢复</h4><p>​AOF的备份机制和性能虽然和RDB不同, 但是备份和恢复的操作同RDB一样，都是拷贝备份文件，需要恢复时再拷贝到Redis工作目录下，启动系统即加载。</p><p>​正常恢复</p><ul><li>修改默认的appendonly no，改为yes</li><li>将有数据的aof文件复制一份保存到对应目录(查看目录：config get dir)</li><li>恢复：重启redis然后重新加载</li></ul><p>​异常恢复</p><ul><li>修改默认的appendonly no，改为yes</li><li>如遇到<strong>AOF文件损坏</strong>，通过/usr/local/bin/<strong>redis-check-aof–fix appendonly.aof</strong>进行恢复</li><li>备份被写坏的AOF文件</li><li>恢复：重启redis，然后重新加载</li></ul><h4 id="9-5-AOF同步频率设置"><a href="#9-5-AOF同步频率设置" class="headerlink" title="9.5 AOF同步频率设置"></a>9.5 AOF同步频率设置</h4><p>​appendfsync always</p><p>​始终同步，每次Redis的写入都会立刻记入日志；性能较差但数据完整性比较好</p><p>​appendfsync everysec</p><p>​每秒同步，每秒记入日志一次，如果宕机，本秒的数据可能丢失。</p><p>​appendfsync no</p><p>​redis不主动进行同步，把同步时机交给操作系统。</p><h4 id="9-6-Rewrite压缩"><a href="#9-6-Rewrite压缩" class="headerlink" title="9.6 Rewrite压缩"></a>9.6 Rewrite压缩</h4><h5 id="9-6-1-是什么："><a href="#9-6-1-是什么：" class="headerlink" title="9.6.1 是什么："></a>9.6.1 是什么：</h5><p>AOF采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制, 当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩， 只保留可以恢复数据的最小指令集.可以使用命令bgrewriteaof</p><h5 id="9-6-2-重写原理，如何实现重写"><a href="#9-6-2-重写原理，如何实现重写" class="headerlink" title="9.6.2 重写原理，如何实现重写"></a>9.6.2 重写原理，如何实现重写</h5><p>AOF文件持续增长而过大时，会fork出一条新进程来将文件重写(也是先写临时文件最后再rename)，redis4.0版本后的重写，是指上就是把rdb 的快照，以二级制的形式附在新的aof头部，作为已有的历史数据，替换掉原来的流水账操作。</p><p>no-appendfsync-on-rewrite：</p><p>如果 no-appendfsync-on-rewrite=yes ,不写入aof文件只写入缓存，用户请求不会阻塞，但是在这段时间如果宕机会丢失这段时间的缓存数据。（降低数据安全性，提高性能）</p><p>   如果 no-appendfsync-on-rewrite=no, 还是会把数据往磁盘里刷，但是遇到重写操作，可能会发生阻塞。（数据安全，但是性能降低）</p><p>触发机制，何时重写</p><p>Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发</p><p>重写虽然可以节约大量磁盘空间，减少恢复时间。但是每次重写还是有一定的负担的，因此设定Redis要满足一定条件才会进行重写。 </p><p>auto-aof-rewrite-percentage：设置重写的基准值，文件达到100%时开始重写（文件是原来重写后文件的2倍时触发）</p><p>auto-aof-rewrite-min-size：设置重写的基准值，最小文件64MB。达到这个值开始重写。</p><p>例如：文件达到70MB开始重写，降到50MB，下次什么时候开始重写？100MB</p><p>系统载入时或者上次重写完毕时，Redis会记录此时AOF大小，设为base_size,</p><p>如果Redis的AOF当前大小&gt;= base_size +base_size*100% (默认)且当前大小&gt;=64mb(默认)的情况下，Redis会对AOF进行重写。 </p><h5 id="9-6-3-重写流程"><a href="#9-6-3-重写流程" class="headerlink" title="9.6.3 重写流程"></a>9.6.3 重写流程</h5><p>（1）bgrewriteaof触发重写，判断是否当前有bgsave或bgrewriteaof在运行，如果有，则等待该命令结束后再继续执行。</p><p>（2）主进程fork出子进程执行重写操作，保证主进程不会阻塞。</p><p>（3）子进程遍历redis内存中数据到临时文件，客户端的写请求同时写入aof_buf缓冲区和aof_rewrite_buf重写缓冲区保证原AOF文件完整以及新AOF文件生成期间的新的数据修改动作不会丢失。</p><p>（4）1).子进程写完新的AOF文件后，向主进程发信号，父进程更新统计信息。2).主进程把aof_rewrite_buf中的数据写入到新的AOF文件。</p><p>（5）使用新的AOF文件覆盖旧的AOF文件，完成AOF重写。</p>  <img src="/2022/09/05/redis-ji-chu-zhi-shi/16.png" class>                      <h4 id="9-7-优势"><a href="#9-7-优势" class="headerlink" title="9.7 优势"></a>9.7 优势</h4>   <img src="/2022/09/05/redis-ji-chu-zhi-shi/17.jpg" class>       <ul><li><p>备份机制更稳健，丢失数据概率更低。</p></li><li><p>可读的日志文本，通过操作AOF稳健，可以处理误操作。</p></li></ul><h4 id="9-8-劣势"><a href="#9-8-劣势" class="headerlink" title="9.8 劣势"></a>9.8 劣势</h4><ul><li><p>比起RDB占用更多的磁盘空间。</p></li><li><p>恢复备份速度要慢。</p></li><li><p>每次读写都同步的话，有一定的性能压力。</p></li><li><p>存在个别Bug，造成恢复不能。</p></li></ul><h4 id="9-9-小总结"><a href="#9-9-小总结" class="headerlink" title="9.9 小总结"></a>9.9 小总结</h4><p>​    <img src="/2022/09/05/redis-ji-chu-zhi-shi/18.jpg" class>    </p><h4 id="9-10-总结-Which-one"><a href="#9-10-总结-Which-one" class="headerlink" title="9.10 总结(Which one)"></a>9.10 总结(Which one)</h4><h5 id="9-10-1-用哪个好"><a href="#9-10-1-用哪个好" class="headerlink" title="9.10.1 用哪个好"></a>9.10.1 用哪个好</h5><p>官方推荐两个都启用。</p><p>如果对数据不敏感，可以选单独用RDB。</p><p>不建议单独用 AOF，因为可能会出现Bug。</p><p>如果只是做纯内存缓存，可以都不用。</p><h5 id="9-10-2-官网建议"><a href="#9-10-2-官网建议" class="headerlink" title="9.10.2 官网建议"></a>9.10.2 官网建议</h5><ul><li><p>RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储</p></li><li><p>AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据,AOF命令以redis协议追加保存每次写的操作到文件末尾. </p></li><li><p>Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大</p></li><li><p>只做缓存：如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式.</p></li><li><p>同时开启两种持久化方式</p></li><li><p>在这种情况下,当redis重启的时候会优先载入AOF文件来恢复原始的数据, 因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整.</p></li><li><p>RDB的数据不实时，同时使用两者时服务器重启也只会找AOF文件。那要不要只使用AOF呢？ </p></li><li><p>建议不要，因为RDB更适合用于备份数据库(AOF在不断变化不好备份)， 快速重启，而且不会有AOF可能潜在的bug，留着作为一个万一的手段。</p></li><li><p>性能建议</p><pre class="language-none"><code class="language-none">因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留save 900 1这条规则。如果使用AOF，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了。代价,一是带来了持续的IO，二是AOF rewrite的最后将rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上。默认超过原大小100%大小时重写可以改到适当的数值。</code></pre></li></ul><h3 id="10-Redis主从复制"><a href="#10-Redis主从复制" class="headerlink" title="10 Redis主从复制"></a>10 Redis主从复制</h3><h4 id="10-1-是什么"><a href="#10-1-是什么" class="headerlink" title="10.1 是什么"></a>10.1 是什么</h4><p>主机数据更新后根据配置和策略， 自动同步到备机的master/slaver机制，<strong>Master以写为主，Slave以读为主</strong></p><h4 id="10-2-能干嘛"><a href="#10-2-能干嘛" class="headerlink" title="10.2 能干嘛"></a>10.2 能干嘛</h4><ul><li>读写分离，性能扩展</li><li>容灾快速恢复</li></ul><p>​     <img src="/2022/09/05/redis-ji-chu-zhi-shi/19.jpg" class>          </p><h4 id="10-3-怎么玩：主从复制"><a href="#10-3-怎么玩：主从复制" class="headerlink" title="10.3 怎么玩：主从复制"></a>10.3 怎么玩：主从复制</h4><p>​拷贝多个redis.conf文件include(写绝对路径)</p><p>​开启daemonize yes</p><p>​Pid文件名字pidfile</p><p>​指定端口port</p><p>​Log文件名字</p><p>​dump.rdb名字dbfilename</p><p>​Appendonly 关掉或者换名字</p><h5 id="10-3-1-新建redis6379-conf，填写以下内容"><a href="#10-3-1-新建redis6379-conf，填写以下内容" class="headerlink" title="10.3.1 新建redis6379.conf，填写以下内容"></a>10.3.1 新建redis6379.conf，填写以下内容</h5><p>include /myredis/redis.conf</p><p>pidfile /var/run/redis_6379.pid</p><p>port 6379</p><p>dbfilename dump6379.rdb</p> <img src="/2022/09/05/redis-ji-chu-zhi-shi/20.jpg" class>         <h5 id="10-3-2-新建redis6380-conf，填写以下内容"><a href="#10-3-2-新建redis6380-conf，填写以下内容" class="headerlink" title="10.3.2 新建redis6380.conf，填写以下内容"></a>10.3.2 新建redis6380.conf，填写以下内容</h5><img src="/2022/09/05/redis-ji-chu-zhi-shi/21.jpg" class>         <h5 id="10-3-3-新建redis6381-conf，填写以下内容"><a href="#10-3-3-新建redis6381-conf，填写以下内容" class="headerlink" title="10.3.3 新建redis6381.conf，填写以下内容"></a>10.3.3 新建redis6381.conf，填写以下内容</h5><img src="/2022/09/05/redis-ji-chu-zhi-shi/22.jpg" class>         <p>replica-priority 10</p><p>设置从机的优先级，值越小，优先级越高，用于选举主机时使用。默认100</p><h5 id="10-3-4-启动三台redis服务器"><a href="#10-3-4-启动三台redis服务器" class="headerlink" title="10.3.4 启动三台redis服务器"></a>10.3.4 启动三台redis服务器</h5> <img src="/2022/09/05/redis-ji-chu-zhi-shi/23.jpg" class>    <h5 id="10-3-5-查看系统进程，看看三台服务器是否启动"><a href="#10-3-5-查看系统进程，看看三台服务器是否启动" class="headerlink" title="10.3.5 查看系统进程，看看三台服务器是否启动"></a>10.3.5 查看系统进程，看看三台服务器是否启动</h5>  <img src="/2022/09/05/redis-ji-chu-zhi-shi/24.jpg" class>    <h5 id="10-3-6-查看三台主机运行情况"><a href="#10-3-6-查看三台主机运行情况" class="headerlink" title="10.3.6 查看三台主机运行情况"></a>10.3.6 查看三台主机运行情况</h5><p>info replication</p><p>打印主从复制的相关信息</p><img src="/2022/09/05/redis-ji-chu-zhi-shi/25.jpg" class>  <h5 id="10-3-7-配从-库-不配主-库"><a href="#10-3-7-配从-库-不配主-库" class="headerlink" title="10.3.7 配从(库)不配主(库)"></a>10.3.7 配从(库)不配主(库)</h5><p>slaveof <ip><port></port></ip></p><p>成为某个实例的从服务器</p><p>1、在6380和6381上执行: slaveof 127.0.0.1 6379</p> <img src="/2022/09/05/redis-ji-chu-zhi-shi/26.jpg" class>  <p>2、在主机上写，在从机上可以读取数据</p><p>在从机上写数据报错</p>  <img src="/2022/09/05/redis-ji-chu-zhi-shi/27.jpg" class>  <p>3、主机挂掉，重启就行，一切如初</p><p>4、从机重启需重设：slaveof 127.0.0.1 6379</p><p>可以将配置增加到文件中。永久生效。</p>   <img src="/2022/09/05/redis-ji-chu-zhi-shi/28.jpg" class>  <h4 id="10-4-常用3招"><a href="#10-4-常用3招" class="headerlink" title="10.4 常用3招"></a>10.4 常用3招</h4><h5 id="10-4-1-一主二仆"><a href="#10-4-1-一主二仆" class="headerlink" title="10.4.1 一主二仆"></a>10.4.1 一主二仆</h5><p>切入点问题？slave1、slave2是从头开始复制还是从切入点开始复制?比如从k4进来，那之前的k1,k2,k3是否也可以复制？</p><p>从机是否可以写？set可否？ </p><p>主机shutdown后情况如何？从机是上位还是原地待命？</p><p>主机又回来了后，主机新增记录，从机还能否顺利复制？ </p><p>其中一台从机down后情况如何？依照原有它能跟上大部队吗？</p>  <img src="/2022/09/05/redis-ji-chu-zhi-shi/29.jpg" class>  <h5 id="10-4-2-薪火相传"><a href="#10-4-2-薪火相传" class="headerlink" title="10.4.2 薪火相传"></a>10.4.2 薪火相传</h5><p>上一个Slave可以是下一个slave的Master，Slave同样可以接收其他 slaves的连接和同步请求，那么该slave作为了链条中下一个的master, 可以有效减轻master的写压力,去中心化降低风险。</p><p>用 slaveof <ip><port></port></ip></p><p>中途变更转向:会清除之前的数据，重新建立拷贝最新的</p><p>风险是一旦某个slave宕机，后面的slave都没法备份</p><p>主机挂了，从机还是从机，无法写数据了</p>  <img src="/2022/09/05/redis-ji-chu-zhi-shi/30.jpg" class>    <img src="/2022/09/05/redis-ji-chu-zhi-shi/31.jpg" class>  <h5 id="10-4-3-反客为主"><a href="#10-4-3-反客为主" class="headerlink" title="10.4.3 反客为主"></a>10.4.3 反客为主</h5><p>当一个master宕机后，后面的slave可以立刻升为master，其后面的slave不用做任何修改。</p><p>用 slaveof no one  将从机变为主机。</p>   <img src="/2022/09/05/redis-ji-chu-zhi-shi/32.jpg" class>  <h4 id="10-5-复制原理"><a href="#10-5-复制原理" class="headerlink" title="10.5 复制原理"></a>10.5 复制原理</h4><ul><li>Slave启动成功连接到master后会发送一个sync命令</li><li>Master接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令， 在后台进程执行完毕之后，master将传送整个数据文件到slave,以完成一次完全同步</li><li>全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。</li><li>增量复制：Master继续将新的所有收集到的修改命令依次传给slave,完成同步</li><li>但是只要是重新连接master,一次完全同步（全量复制)将被自动执行</li></ul><h4 id="10-6-哨兵模式-sentinel"><a href="#10-6-哨兵模式-sentinel" class="headerlink" title="10.6 哨兵模式(sentinel)"></a>10.6 哨兵模式(sentinel)</h4><h5 id="10-6-1-是什么"><a href="#10-6-1-是什么" class="headerlink" title="10.6.1 是什么"></a>10.6.1 是什么</h5><p><strong>反客为主的自动版</strong>，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库</p><p>​    <img src="/2022/09/05/redis-ji-chu-zhi-shi/33.jpg" class>  </p><h4 id="10-6-2-怎么玩-使用步骤"><a href="#10-6-2-怎么玩-使用步骤" class="headerlink" title="10.6.2 怎么玩(使用步骤)"></a>10.6.2 怎么玩(使用步骤)</h4><h5 id="10-6-2-1-调整为一主二仆模式，6379带着6380、6381"><a href="#10-6-2-1-调整为一主二仆模式，6379带着6380、6381" class="headerlink" title="10.6.2.1 调整为一主二仆模式，6379带着6380、6381"></a>10.6.2.1 调整为一主二仆模式，6379带着6380、6381</h5> <img src="/2022/09/05/redis-ji-chu-zhi-shi/34.jpg" class>  <h5 id="10-6-2-2-自定义的-x2F-myredis目录下新建sentinel-conf文件，名字绝不能错"><a href="#10-6-2-2-自定义的-x2F-myredis目录下新建sentinel-conf文件，名字绝不能错" class="headerlink" title="10.6.2.2 自定义的/myredis目录下新建sentinel.conf文件，名字绝不能错"></a>10.6.2.2 自定义的/myredis目录下新建sentinel.conf文件，名字绝不能错</h5><h5 id="10-6-2-3-配置哨兵-填写内容"><a href="#10-6-2-3-配置哨兵-填写内容" class="headerlink" title="10.6.2.3 配置哨兵,填写内容"></a>10.6.2.3 配置哨兵,填写内容</h5><p>sentinel monitor mymaster 127.0.0.1 6379 1</p><p>其中mymaster为监控对象起的服务器名称， 1 为至少有多少个哨兵同意迁移的数量。 </p><h5 id="10-6-2-4-启动哨兵"><a href="#10-6-2-4-启动哨兵" class="headerlink" title="10.6.2.4 启动哨兵"></a>10.6.2.4 启动哨兵</h5><p>/usr/local/bin</p><p>redis做压测可以用自带的redis-benchmark工具</p><p>执行redis-sentinel /myredis/sentinel.conf </p>  <img src="/2022/09/05/redis-ji-chu-zhi-shi/35.jpg" class>  <h5 id="10-6-2-5-当主机挂掉，从机选举中产生新的主机"><a href="#10-6-2-5-当主机挂掉，从机选举中产生新的主机" class="headerlink" title="10.6.2.5 当主机挂掉，从机选举中产生新的主机"></a>10.6.2.5 当主机挂掉，从机选举中产生新的主机</h5><p>(大概10秒左右可以看到哨兵窗口日志，切换了新的主机)</p><p>哪个从机会被选举为主机呢？根据优先级别：slave-priority </p><p>原主机重启后会变为从机。</p>  <img src="/2022/09/05/redis-ji-chu-zhi-shi/36.jpg" class>  <h5 id="10-6-2-6-复制延时"><a href="#10-6-2-6-复制延时" class="headerlink" title="10.6.2.6 复制延时"></a>10.6.2.6 复制延时</h5><p>由于所有的写操作都是先在Master上操作，然后同步更新到Slave上，所以从Master同步到Slave机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重。</p><h4 id="10-6-3-故障恢复"><a href="#10-6-3-故障恢复" class="headerlink" title="10.6.3 故障恢复"></a>10.6.3 故障恢复</h4> <img src="/2022/09/05/redis-ji-chu-zhi-shi/37.jpg" class>  <p>优先级在redis.conf中默认：replica-priority 100，值越小优先级越高</p><p>偏移量是指获得原主机数据最全的</p><p>每个redis实例启动后都会随机生成一个40位的runid</p><h4 id="10-6-4-主从复制"><a href="#10-6-4-主从复制" class="headerlink" title="10.6.4 主从复制"></a>10.6.4 主从复制</h4><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">JedisSentinelPool</span> jedisSentinelPool<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span>  <span class="token class-name">Jedis</span> <span class="token function">getJedisFromSentinel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span><span class="token punctuation">(</span>jedisSentinelPool<span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> sentinelSet<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            sentinelSet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"192.168.11.103:26379"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">JedisPoolConfig</span> jedisPoolConfig <span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">JedisPoolConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            jedisPoolConfig<span class="token punctuation">.</span><span class="token function">setMaxTotal</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//最大可用连接数</span>jedisPoolConfig<span class="token punctuation">.</span><span class="token function">setMaxIdle</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//最大闲置连接数</span>jedisPoolConfig<span class="token punctuation">.</span><span class="token function">setMinIdle</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//最小闲置连接数</span>jedisPoolConfig<span class="token punctuation">.</span><span class="token function">setBlockWhenExhausted</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//连接耗尽是否等待</span>jedisPoolConfig<span class="token punctuation">.</span><span class="token function">setMaxWaitMillis</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//等待时间</span>jedisPoolConfig<span class="token punctuation">.</span><span class="token function">setTestOnBorrow</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//取连接的时候进行一下测试 ping pong</span>jedisSentinelPool<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">JedisSentinelPool</span><span class="token punctuation">(</span><span class="token string">"mymaster"</span><span class="token punctuation">,</span>sentinelSet<span class="token punctuation">,</span>jedisPoolConfig<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> jedisSentinelPool<span class="token punctuation">.</span><span class="token function">getResource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span><span class="token keyword">return</span> jedisSentinelPool<span class="token punctuation">.</span><span class="token function">getResource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="11-Redis集群"><a href="#11-Redis集群" class="headerlink" title="11. Redis集群"></a>11. Redis集群</h3><h4 id="11-1-问题"><a href="#11-1-问题" class="headerlink" title="11.1 问题"></a>11.1 问题</h4><p>容量不够，redis如何进行扩容？</p><p>并发写操作， redis如何分摊？</p><p>另外，主从模式，薪火相传模式，主机宕机，导致ip地址发生变化，应用程序中配置需要修改对应的主机地址、端口等信息。</p><p>之前通过代理主机来解决，但是redis3.0中提供了解决方案。就是无中心化集群配置。</p><h4 id="11-2-什么是集群"><a href="#11-2-什么是集群" class="headerlink" title="11.2 什么是集群"></a>11.2 什么是集群</h4><p>Redis 集群实现了对Redis的水平扩容，即启动N个redis节点，将整个数据库分布存储在这N个节点中，每个节点存储总数据的1/N。</p><p>Redis 集群通过分区（partition）来提供一定程度的可用性（availability）： 即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求。</p><h4 id="11-3-删除持久化数据"><a href="#11-3-删除持久化数据" class="headerlink" title="11.3 删除持久化数据"></a>11.3 删除持久化数据</h4><p>将rdb,aof文件都删除掉。</p><h4 id="11-4-制作6个实例，6379-6380-6381-6389-6390-6391"><a href="#11-4-制作6个实例，6379-6380-6381-6389-6390-6391" class="headerlink" title="11.4 制作6个实例，6379,6380,6381,6389,6390,6391"></a>11.4 制作6个实例，6379,6380,6381,6389,6390,6391</h4><h5 id="11-4-1-配置基本信息"><a href="#11-4-1-配置基本信息" class="headerlink" title="11.4.1 配置基本信息"></a>11.4.1 配置基本信息</h5><p>开启daemonize yes</p><p>Pid文件名字</p><p>指定端口</p><p>Log文件名字</p><p>Dump.rdb名字</p><p>Appendonly 关掉或者换名字</p><h5 id="11-4-2-redis-cluster配置修改"><a href="#11-4-2-redis-cluster配置修改" class="headerlink" title="11.4.2 redis cluster配置修改"></a>11.4.2 redis cluster配置修改</h5><p>cluster-enabled <strong>yes</strong>  打开集群模式</p><p>cluster-config-file <strong>nodes-6379.conf</strong> 设定节点配置文件名</p><p>cluster-node-timeout <strong>15000</strong>  设定节点失联时间，超过该时间（毫秒），集群自动进行主从切换。</p><pre class="language-none"><code class="language-none">include /home/bigdata/redis.confport 6379  pidfile  "/var/run/redis_6379.pid"  dbfilename "dump6379.rdb"  dir  "/home/bigdata/redis_cluster"  logfile "/home/bigdata/redis_cluster/redis_err_6379.log"  cluster-enabled yes  cluster-config-file nodes-6379.conf  cluster-node-timeout 15000  </code></pre><h5 id="11-4-3-修改好redis6379-conf文件，拷贝多个redis-conf文件"><a href="#11-4-3-修改好redis6379-conf文件，拷贝多个redis-conf文件" class="headerlink" title="11.4.3 修改好redis6379.conf文件，拷贝多个redis.conf文件"></a>11.4.3 修改好redis6379.conf文件，拷贝多个redis.conf文件</h5><img src="/2022/09/05/redis-ji-chu-zhi-shi/38.jpg" class>  <h5 id="11-4-4-使用查找替换修改另外5个文件"><a href="#11-4-4-使用查找替换修改另外5个文件" class="headerlink" title="11.4.4 使用查找替换修改另外5个文件"></a>11.4.4 使用查找替换修改另外5个文件</h5><p>例如：:%s/6379/6380 </p><h5 id="11-4-5-启动6个redis服务"><a href="#11-4-5-启动6个redis服务" class="headerlink" title="11.4.5 启动6个redis服务"></a>11.4.5 启动6个redis服务</h5><img src="/2022/09/05/redis-ji-chu-zhi-shi/39.jpg" class><h4 id="11-5-将六个节点合成一个集群"><a href="#11-5-将六个节点合成一个集群" class="headerlink" title="11.5 将六个节点合成一个集群"></a>11.5 将六个节点合成一个集群</h4><p>组合之前，请确保所有redis实例启动后，nodes-xxxx.conf文件都生成正常。</p> <img src="/2022/09/05/redis-ji-chu-zhi-shi/40.jpg" class><ul><li>合体：</li></ul><p>cd /opt/redis-6.2.1/src</p><pre class="language-none"><code class="language-none">redis-cli --cluster  create --cluster-replicas 1 192.168.11.101:6379 192.168.11.101:6380  192.168.11.101:6381 192.168.11.101:6389 192.168.11.101:6390  192.168.11.101:6391  </code></pre><p><strong>此处不要用127.0.0.1， 请用真实IP地址</strong></p><p><strong>–replicas 1 采用最简单的方式配置集群，一台主机，一台从机，正好三组。</strong></p> <img src="/2022/09/05/redis-ji-chu-zhi-shi/41.jpg" class> <img src="/2022/09/05/redis-ji-chu-zhi-shi/42.jpg" class><ul><li>普通方式登录</li></ul><p>可能直接进入读主机，存储数据时，会出现MOVED重定向操作。所以，应该以集群方式登录。</p><img src="/2022/09/05/redis-ji-chu-zhi-shi/43.jpg" class><h4 id="11-6-c采用集群策略连接，设置数据会自动切换到相应的写主机"><a href="#11-6-c采用集群策略连接，设置数据会自动切换到相应的写主机" class="headerlink" title="11.6 -c采用集群策略连接，设置数据会自动切换到相应的写主机"></a>11.6 -c采用集群策略连接，设置数据会自动切换到相应的写主机</h4><img src="/2022/09/05/redis-ji-chu-zhi-shi/44.jpg" class><h4 id="11-7-通过-cluster-nodes-命令查看集群信息"><a href="#11-7-通过-cluster-nodes-命令查看集群信息" class="headerlink" title="11.7 通过 cluster nodes 命令查看集群信息"></a>11.7 通过 cluster nodes 命令查看集群信息</h4> <img src="/2022/09/05/redis-ji-chu-zhi-shi/45.jpg" class><h4 id="11-8-redis-cluster如何分配这六个节点"><a href="#11-8-redis-cluster如何分配这六个节点" class="headerlink" title="11.8 redis cluster如何分配这六个节点?"></a>11.8 redis cluster如何分配这六个节点?</h4><p>一个集群至少要有三个主节点。</p><p>选项 –cluster-replicas 1 表示我们希望为集群中的每个主节点创建一个从节点。</p><p>分配原则尽量保证每个主数据库运行在不同的IP地址，每个从库和主库不在一个IP地址上。</p><h4 id="11-9-什么是slots"><a href="#11-9-什么是slots" class="headerlink" title="11.9 什么是slots"></a>11.9 什么是slots</h4><p><strong>[OK] All nodes agree about slots configuration.</strong></p><p><strong>&gt;&gt;&gt; Check for open slots…</strong></p><p><strong>&gt;&gt;&gt; Check slots coverage…</strong></p><p><strong>[OK] All 16384 slots covered.</strong></p><p>一个 Redis 集群包含 16384 个插槽（hash slot）， 数据库中的每个键都属于这 16384 个插槽的其中一个， </p><p>集群使用公式 CRC16(key) % 16384 来计算键 key 属于哪个槽， 其中 CRC16(key) 语句用于计算键 key 的 CRC16 校验和 。</p><p>集群中的每个节点负责处理一部分插槽。 举个例子， 如果一个集群可以有主节点， 其中：</p><p>节点 A 负责处理 0 号至 5460 号插槽。</p><p>节点 B 负责处理 5461 号至 10922 号插槽。</p><p>节点 C 负责处理 10923 号至 16383 号插槽。</p><h4 id="11-10-在集群中录入值"><a href="#11-10-在集群中录入值" class="headerlink" title="11.10 在集群中录入值"></a>11.10 在集群中录入值</h4><p>在redis-cli每次录入、查询键值，redis都会计算出该key应该送往的插槽，如果不是该客户端对应服务器的插槽，redis会报错，并告知应前往的redis实例地址和端口。</p><p>redis-cli客户端提供了 –c 参数实现自动重定向。</p><p>如 redis-cli -c –p 6379 登入后，再录入、查询键值对可以自动重定向。</p><p>不在一个slot下的键值，是<strong>不能使用mget,mset等多键操作</strong>。</p><img src="/2022/09/05/redis-ji-chu-zhi-shi/46.jpg" class><p>可以通过{}来定义组的概念，从而使key中{}内相同内容的键值对放到一个slot中去。</p><img src="/2022/09/05/redis-ji-chu-zhi-shi/47.jpg" class><h4 id="11-11-查询集群中的值"><a href="#11-11-查询集群中的值" class="headerlink" title="11.11 查询集群中的值"></a>11.11 查询集群中的值</h4><p>CLUSTER GETKEYSINSLOT <slot><count> 返回 count 个 slot 槽中的键。</count></slot></p><img src="/2022/09/05/redis-ji-chu-zhi-shi/48.jpg" class><h4 id="11-12-故障恢复"><a href="#11-12-故障恢复" class="headerlink" title="11.12 故障恢复"></a>11.12 故障恢复</h4><p>如果主节点下线？从节点能否自动升为主节点？注意：<strong>15秒超时</strong></p><img src="/2022/09/05/redis-ji-chu-zhi-shi/49.jpg" class><p>主节点恢复后，主从关系会如何？主节点回来变成从机。</p> <img src="/2022/09/05/redis-ji-chu-zhi-shi/50.jpg" class><p>如果所有某一段插槽的主从节点都宕掉，redis服务是否还能继续?</p><p>如果某一段插槽的主从都挂掉，而cluster-require-full-coverage 为yes ，那么 ，整个集群都挂掉</p><p>如果某一段插槽的主从都挂掉，而cluster-require-full-coverage 为no ，那么，该插槽数据全都不能使用，也无法存储。</p><p>redis.conf中的参数 cluster-require-full-coverage</p><h4 id="11-13-集群的Jedis开发"><a href="#11-13-集群的Jedis开发" class="headerlink" title="11.13 集群的Jedis开发"></a>11.13 集群的Jedis开发</h4><p>即使连接的不是主机，集群会自动切换主机存储。主机写，从机读。</p><p>无中心化主从集群。无论从哪台主机写的数据，其他主机上都能读到数据。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JedisClusterTest</span> <span class="token punctuation">{</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span>  <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">HostAndPort</span><span class="token punctuation">&gt;</span></span>set <span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">HostAndPort</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HostAndPort</span><span class="token punctuation">(</span><span class="token string">"192.168.31.211"</span><span class="token punctuation">,</span><span class="token number">6379</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token class-name">JedisCluster</span> jedisCluster<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">JedisCluster</span><span class="token punctuation">(</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span>jedisCluster<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"k1"</span><span class="token punctuation">,</span> <span class="token string">"v1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token class-name">System</span><span class="token punctuation">.</span>*out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>jedisCluster<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"k1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span>  </code></pre><h4 id="11-14-Redis集群提供了以下好处"><a href="#11-14-Redis集群提供了以下好处" class="headerlink" title="11.14 Redis集群提供了以下好处"></a>11.14 Redis集群提供了以下好处</h4><p>实现扩容</p><p>分摊压力</p><p>无中心配置相对简单</p><h4 id="11-15-Redis集群的不足"><a href="#11-15-Redis集群的不足" class="headerlink" title="11.15 Redis集群的不足"></a>11.15 Redis集群的不足</h4><p>多键操作是不被支持的 </p><p>多键的Redis事务是不被支持的。lua脚本不被支持</p><p>由于集群方案出现较晚，很多公司已经采用了其他的集群方案，而代理或者客户端分片的方案想要迁移至redis cluster，需要整体迁移而不是逐步过渡，复杂度较大。</p><h3 id="12-Redis应用问题解决"><a href="#12-Redis应用问题解决" class="headerlink" title="12. Redis应用问题解决"></a>12. Redis应用问题解决</h3><h4 id="12-1-缓存穿透"><a href="#12-1-缓存穿透" class="headerlink" title="12.1 缓存穿透"></a>12.1 缓存穿透</h4><h5 id="12-1-1-问题描述"><a href="#12-1-1-问题描述" class="headerlink" title="12.1.1 问题描述"></a>12.1.1 问题描述</h5><p>​key对应的数据在数据源并不存在，每次针对此key的请求从缓存获取不到，请求都会压到数据源，从而可能压垮数据源。比如用一个不存在的用户id获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。</p><img src="/2022/09/05/redis-ji-chu-zhi-shi/51.png" class><h5 id="12-1-2-解决方案"><a href="#12-1-2-解决方案" class="headerlink" title="12.1.2 解决方案"></a>12.1.2 解决方案</h5><p>​一个一定不存在缓存及查询不到的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。</p><p>解决方案：</p><p>（1）  <strong>对空值缓存：</strong>如果一个查询返回的数据为空（不管是数据是否不存在），我们仍然把这个空结果（null）进行缓存，设置空结果的过期时间会很短，最长不超过五分钟</p><p>（2）  <strong>设置可访问的名单（白名单）：</strong></p><p>使用bitmaps类型定义一个可以访问的名单，名单id作为bitmaps的偏移量，每次访问和bitmap里面的id进行比较，如果访问id不在bitmaps里面，进行拦截，不允许访问。</p><p>（3）  <strong>采用布隆过滤器</strong>：(布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量(位图)和一系列随机映射函数（哈希函数）。</p><p>布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。)</p><p>将所有可能存在的数据哈希到一个足够大的bitmaps中，一个一定不存在的数据会被 这个bitmaps拦截掉，从而避免了对底层存储系统的查询压力。</p><p><strong>（4）</strong>  <strong>进行实时监控：</strong>当发现Redis的命中率开始急速降低，需要排查访问对象和访问的数据，和运维人员配合，可以设置黑名单限制服务</p><h4 id="12-2-缓存击穿"><a href="#12-2-缓存击穿" class="headerlink" title="12.2 缓存击穿"></a>12.2 缓存击穿</h4><h5 id="12-2-1-问题描述"><a href="#12-2-1-问题描述" class="headerlink" title="12.2.1 问题描述"></a>12.2.1 问题描述</h5><p>​key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</p><img src="/2022/09/05/redis-ji-chu-zhi-shi/52.png" class><h5 id="12-2-2-解决方案"><a href="#12-2-2-解决方案" class="headerlink" title="12.2.2 解决方案"></a>12.2.2 解决方案</h5><p>​key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题。</p><p>解决问题：</p><p><strong>（1）预先设置热门数据：</strong>在redis高峰访问之前，把一些热门数据提前存入到redis里面，加大这些热门数据key的时长</p><p><strong>（2）实时调整：</strong>现场监控哪些数据热门，实时调整key的过期时长</p><p><strong>（3）使用锁：</strong></p><p>（1）  就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db。</p><p>（2）  先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX）去set一个mutex key</p><p>（3）  当操作返回成功时，再进行load db的操作，并回设缓存,最后删除mutex key；</p><p>（4）  当操作返回失败，证明有线程在load db，当前线程睡眠一段时间再重试整个get缓存的方法。</p><img src="/2022/09/05/redis-ji-chu-zhi-shi/53.png" class><h4 id="12-3-缓存雪崩"><a href="#12-3-缓存雪崩" class="headerlink" title="12.3 缓存雪崩"></a>12.3 缓存雪崩</h4><h5 id="12-3-1-问题描述"><a href="#12-3-1-问题描述" class="headerlink" title="12.3.1 问题描述"></a>12.3.1 问题描述</h5><p>​key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</p><p>缓存雪崩与缓存击穿的区别在于这里针对很多key缓存，前者则是某一个key</p><p>正常访问</p> <img src="/2022/09/05/redis-ji-chu-zhi-shi/54.png" class><p>缓存失效瞬间</p> <img src="/2022/09/05/redis-ji-chu-zhi-shi/55.png" class><h5 id="12-3-2-解决方案"><a href="#12-3-2-解决方案" class="headerlink" title="12.3.2 解决方案"></a>12.3.2 解决方案</h5><p>缓存失效时的雪崩效应对底层系统的冲击非常可怕！</p><p>解决方案：</p><p><strong>（1）</strong>  <strong>构建多级缓存架构：</strong>nginx缓存 + redis缓存 +其他缓存（ehcache等）</p><p><strong>（2）使用锁或队列：</strong></p><p>用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。不适用高并发情况</p><p><strong>（3）</strong>  <strong>设置过期标志更新缓存：</strong></p><p>记录缓存数据是否过期（设置提前量），如果过期会触发通知另外的线程在后台去更新实际key的缓存。</p><p><strong>（4）</strong>  <strong>将缓存失效时间分散开：</strong></p><p>比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p><h4 id="12-4-分布式锁"><a href="#12-4-分布式锁" class="headerlink" title="12.4 分布式锁"></a>12.4 分布式锁</h4><h5 id="11-4-1-问题描述"><a href="#11-4-1-问题描述" class="headerlink" title="11.4.1 问题描述"></a>11.4.1 问题描述</h5><p>​随着业务发展的需要，原单体单机部署的系统被演化成分布式集群系统后，由于分布式系统多线程、多进程并且分布在不同机器上，这将使原单机部署情况下的并发控制锁策略失效，单纯的Java API并不能提供分布式锁的能力。为了解决这个问题就需要一种跨JVM的互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题！</p><p>分布式锁主流的实现方案：</p><ol><li><p>基于数据库实现分布式锁</p></li><li><p>基于缓存（Redis等）</p></li><li><p>基于Zookeeper</p></li></ol><p>每一种分布式锁解决方案都有各自的优缺点：</p><ol><li><p>性能：redis最高</p></li><li><p>可靠性：zookeeper最高</p></li></ol><p>这里，我们就基于redis实现分布式锁。</p><h5 id="12-4-2-解决方案：使用redis实现分布式锁"><a href="#12-4-2-解决方案：使用redis实现分布式锁" class="headerlink" title="12.4.2 解决方案：使用redis实现分布式锁"></a>12.4.2 解决方案：使用redis实现分布式锁</h5><p>redis:命令</p><p># set sku:1:info “OK” NX PX 10000</p><p>EX second ：设置键的过期时间为 second 秒。 SET key value EX second 效果等同于 SETEX key second value 。</p><p>PX millisecond ：设置键的过期时间为 millisecond 毫秒。 SET key value PX millisecond 效果等同于 PSETEX key millisecond value 。</p><p>NX ：只在键不存在时，才对键进行设置操作。 SET key value NX 效果等同于 SETNX key value 。</p><p>XX ：只在键已经存在时，才对键进行设置操作。</p><img src="/2022/09/05/redis-ji-chu-zhi-shi/56.png" class><ol><li><p>多个客户端同时获取锁（setnx）</p></li><li><p>获取成功，执行业务逻辑{从db获取数据，放入缓存}，执行完成释放锁（del）</p></li><li><p>其他客户端等待重试</p></li></ol><h5 id="12-4-3-编写代码"><a href="#12-4-3-编写代码" class="headerlink" title="12.4.3 编写代码"></a>12.4.3 编写代码</h5><p>Redis: set num 0</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token operator">*</span><span class="token string">"testLock"</span><span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token operator">*</span><span class="token comment">//1获取锁，setne    </span><span class="token class-name">Boolean</span>  lock <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setIfAbsent</span><span class="token punctuation">(</span><span class="token string">"lock"</span><span class="token punctuation">,</span> <span class="token string">"111"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//2获取锁成功、查询num的值   </span><span class="token keyword">if</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">{</span>               <span class="token class-name">Object</span> value <span class="token operator">=</span> redisTemplate<span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"num"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//2.1判断num为空return      </span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                     <span class="token keyword">return</span><span class="token punctuation">;</span>               <span class="token punctuation">}</span>               <span class="token comment">//2.2有值就转成成int     </span>        <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>value<span class="token operator">+</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//2.3把redis的num加1       </span>        redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"num"</span><span class="token punctuation">,</span> <span class="token operator">++</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//2.4释放锁，del       </span>    redisTemplate<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token string">"lock"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>               <span class="token comment">//3获取锁失败、每隔0.1秒再获取 </span>        <span class="token keyword">try</span><span class="token punctuation">{</span>                     <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">testLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span>  <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>               e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>        <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  </code></pre><p>重启，服务集群，通过网关压力测试：</p><p>ab -n 1000 -c 100 <a href="http://192.168.140.1:8080/test/testLock">http://192.168.140.1:8080/test/testLock</a></p> <img src="/2022/09/05/redis-ji-chu-zhi-shi/57.png" class><p>查看redis中num的值：</p>  <img src="/2022/09/05/redis-ji-chu-zhi-shi/58.png" class><p>基本实现。</p><p>问题：setnx刚好获取到锁，业务逻辑出现异常，导致锁无法释放</p><p>解决：设置过期时间，自动释放锁。</p><h5 id="12-4-4-优化之设置锁的过期时间"><a href="#12-4-4-优化之设置锁的过期时间" class="headerlink" title="12.4.4 优化之设置锁的过期时间"></a>12.4.4 优化之设置锁的过期时间</h5><p>设置过期时间有两种方式：</p><ol><li><p>首先想到通过expire设置过期时间（缺乏原子性：如果在setnx和expire之间出现异常，锁也无法释放）</p></li><li><p>在set时指定过期时间（推荐）</p><img src="/2022/09/05/redis-ji-chu-zhi-shi/59.png" class></li></ol><p>设置过期时间：</p><p>​    <img src="/2022/09/05/redis-ji-chu-zhi-shi/60.png" class></p><p>压力测试肯定也没有问题。自行测试</p><p>问题：可能会释放其他服务器的锁。</p><p>场景：如果业务逻辑的执行时间是7s。执行流程如下</p><ol><li><p>index1业务逻辑没执行完，3秒后锁被自动释放。</p></li><li><p>index2获取到锁，执行业务逻辑，3秒后锁被自动释放。</p></li><li><p>index3获取到锁，执行业务逻辑</p></li><li><p>index1业务逻辑执行完成，开始调用del释放锁，这时释放的是index3的锁，导致index3的业务只执行1s就被别人释放。</p></li></ol><p>最终等于没锁的情况。</p><p>解决：setnx获取锁时，设置一个指定的唯一值（例如：uuid）；释放前获取这个值，判断是否自己的锁</p><h5 id="12-4-5-优化之UUID防误删"><a href="#12-4-5-优化之UUID防误删" class="headerlink" title="12.4.5 优化之UUID防误删"></a>12.4.5 优化之UUID防误删</h5> <img src="/2022/09/05/redis-ji-chu-zhi-shi/61.png" class> <img src="/2022/09/05/redis-ji-chu-zhi-shi/62.png" class><p>问题：删除操作缺乏原子性。</p><p>场景：</p><ol><li><p>index1执行删除时，查询到的lock值确实和uuid相等</p><p>​uuid=v1</p><p>​set(lock,uuid)；</p></li></ol>  <img src="/2022/09/05/redis-ji-chu-zhi-shi/63.png" class><ol start="2"><li><p>index1执行删除前，lock刚好过期时间已到，被redis自动释放</p><p>在redis中没有了lock，没有了锁。</p></li></ol> <img src="/2022/09/05/redis-ji-chu-zhi-shi/64.png" class><ol start="3"><li><p>index2获取了lock</p><p>​index2线程获取到了cpu的资源，开始执行方法</p><p>​uuid=v2</p><p>​set(lock,uuid)；</p></li><li><p>index1执行删除，此时会把index2的lock删除</p><p>​index1 因为已经在方法中了，所以不需要重新上锁。index1有执行的权限。index1已经比较完成了，这个时候，开始执行</p></li></ol>  <img src="/2022/09/05/redis-ji-chu-zhi-shi/65.png" class><p>​删除的index2的锁！</p><h5 id="12-4-6-优化之LUA脚本保证删除的原子性"><a href="#12-4-6-优化之LUA脚本保证删除的原子性" class="headerlink" title="12.4.6 优化之LUA脚本保证删除的原子性"></a>12.4.6 优化之LUA脚本保证删除的原子性</h5><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"testLockLua"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testLockLua</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//1 声明一个uuid ,将做为一个value 放入我们的key所对应的值中</span>    <span class="token class-name">String</span> uuid <span class="token operator">=</span> UUID<span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//2 定义一个锁：lua 脚本可以使用同一把锁，来实现删除！</span>    <span class="token class-name">String</span> skuId <span class="token operator">=</span> <span class="token string">"25"</span><span class="token punctuation">;</span> <span class="token comment">// 访问skuId 为25号的商品 100008348542</span>    <span class="token class-name">String</span> locKey <span class="token operator">=</span> <span class="token string">"lock:"</span> <span class="token operator">+</span> skuId<span class="token punctuation">;</span> <span class="token comment">// 锁住的是每个商品的数据</span>    <span class="token comment">// 3 获取锁</span>    <span class="token class-name">Boolean</span> lock <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setIfAbsent</span><span class="token punctuation">(</span>locKey<span class="token punctuation">,</span> uuid<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 第一种： lock 与过期时间中间不写任何的代码。</span>    <span class="token comment">// redisTemplate.expire("lock",10, TimeUnit.SECONDS);//设置过期时间</span>    <span class="token comment">// 如果true</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 执行的业务逻辑开始</span>        <span class="token comment">// 获取缓存中的num 数据</span>        <span class="token class-name">Object</span> value <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"num"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 如果是空直接返回</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 不是空 如果说在这出现了异常！ 那么delete 就删除失败！ 也就是说锁永远存在！</span>        <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>value <span class="token operator">+</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 使num 每次+1 放入缓存</span>        redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"num"</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token operator">++</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/*使用lua脚本来锁*/</span>        <span class="token comment">// 定义lua 脚本</span>        <span class="token class-name">String</span> script <span class="token operator">=</span> <span class="token string">"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end"</span><span class="token punctuation">;</span>        <span class="token comment">// 使用redis执行lua执行</span>        <span class="token class-name">DefaultRedisScript</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">&gt;</span></span> redisScript <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultRedisScript</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        redisScript<span class="token punctuation">.</span><span class="token function">setScriptText</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 设置一下返回值类型 为Long</span>        <span class="token comment">// 因为删除判断的时候，返回的0,给其封装为数据类型。如果不封装那么默认返回String 类型，</span>        <span class="token comment">// 那么返回字符串与0 会有发生错误。</span>        redisScript<span class="token punctuation">.</span><span class="token function">setResultType</span><span class="token punctuation">(</span><span class="token class-name">Long</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 第一个要是script 脚本 ，第二个需要判断的key，第三个就是key所对应的值。</span>        redisTemplate<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>redisScript<span class="token punctuation">,</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>locKey<span class="token punctuation">)</span><span class="token punctuation">,</span> uuid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment">// 其他线程等待</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment">// 睡眠</span>            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 睡醒了之后，调用方法。</span>            <span class="token function">testLockLua</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>Lua 脚本详解：</p>   <img src="/2022/09/05/redis-ji-chu-zhi-shi/66.png" class><p>项目中正确使用：</p><ol><li>定义key，key应该是为每个sku定义的，也就是每个sku有一把锁。</li></ol><p>String locKey =”lock:”+skuId; // 锁住的是每个商品的数据 </p><p>Boolean lock = redisTemplate.opsForValue().setIfAbsent(locKey, uuid,3,TimeUnit.SECONDS);</p>   <img src="/2022/09/05/redis-ji-chu-zhi-shi/67.png" class><h5 id="12-4-7-总结"><a href="#12-4-7-总结" class="headerlink" title="12.4.7 总结"></a>12.4.7 总结</h5><p>1、加锁</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// 1. 从redis中获取锁,set k1 v1 px 20000 nx</span><span class="token class-name">String</span> uuid <span class="token operator">=</span> UUID<span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Boolean</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">.</span><span class="token function">setIfAbsent</span><span class="token punctuation">(</span><span class="token string">"lock"</span><span class="token punctuation">,</span> uuid<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>2、使用lua释放锁</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// 2. 释放锁 del</span><span class="token class-name">String</span> script <span class="token operator">=</span> <span class="token string">"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end"</span><span class="token punctuation">;</span><span class="token comment">// 设置lua脚本返回的数据类型</span><span class="token class-name">DefaultRedisScript</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">&gt;</span></span> redisScript <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultRedisScript</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 设置lua脚本返回类型为Long</span>redisScript<span class="token punctuation">.</span><span class="token function">setResultType</span><span class="token punctuation">(</span><span class="token class-name">Long</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>redisScript<span class="token punctuation">.</span><span class="token function">setScriptText</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span><span class="token punctuation">;</span>redisTemplate<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>redisScript<span class="token punctuation">,</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"lock"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>uuid<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>3、重试</p><pre class="language-none"><code class="language-none">Thread.sleep(500);testLock();</code></pre><p> 为了确保分布式锁可用，我们至少要确保锁的实现同时<strong>满足以下四个条件</strong>：</p><p>- 互斥性。在任意时刻，只有一个客户端能持有锁。</p><p>- 不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。</p><p>- 解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。</p><p>- 加锁和解锁必须具有原子性。</p><h3 id="13-Redis6-0新功能"><a href="#13-Redis6-0新功能" class="headerlink" title="13. Redis6.0新功能"></a>13. Redis6.0新功能</h3><h4 id="13-1-ACL"><a href="#13-1-ACL" class="headerlink" title="13.1 ACL"></a>13.1 ACL</h4><h5 id="13-1-1-简介"><a href="#13-1-1-简介" class="headerlink" title="13.1.1 简介"></a>13.1.1 简介</h5><p>​Redis ACL是Access Control List（访问控制列表）的缩写，该功能允许根据可以执行的命令和可以访问的键来限制某些连接。</p><p>​在Redis 5版本之前，Redis 安全规则只有密码控制 还有通过rename 来调整高危命令比如 flushdb ， KEYS* ， shutdown 等。Redis 6 则提供ACL的功能对用户进行更细粒度的权限控制 ：</p><p>（1）接入权限:用户名和密码 </p><p>（2）可以执行的命令 </p><p>（3）可以操作的 KEY</p><p>参考官网：<a href="https://redis.io/topics/acl">https://redis.io/topics/acl</a></p><h5 id="13-1-2-命令"><a href="#13-1-2-命令" class="headerlink" title="13.1.2 命令"></a>13.1.2 命令</h5><p>1、使用acl list命令展现用户权限列表</p><p>（1）数据说明</p><img src="/2022/09/05/redis-ji-chu-zhi-shi/68.png" class><p>2、使用acl cat命令</p><p>（1）查看添加权限指令类别</p> <img src="/2022/09/05/redis-ji-chu-zhi-shi/69.png" class><p>（2）加参数类型名可以查看类型下具体命令</p><img src="/2022/09/05/redis-ji-chu-zhi-shi/70.png" class><p>3、使用acl whoami命令查看当前用户</p><p>4、使用aclsetuser命令创建和编辑用户ACL</p><p>（1）ACL规则</p><p>下面是有效ACL规则的列表。某些规则只是用于激活或删除标志，或对用户ACL执行给定更改的单个单词。其他规则是字符前缀，它们与命令或类别名称、键模式等连接在一起。</p><table><thead><tr><th>ACL规则</th><th></th><th></th></tr></thead><tbody><tr><td>类型</td><td>参数</td><td>说明</td></tr><tr><td>启动和禁用用户</td><td><strong>on</strong></td><td>激活某用户账号</td></tr><tr><td><strong>off</strong></td><td>禁用某用户账号。注意，已验证的连接仍然可以工作。如果默认用户被标记为off，则新连接将在未进行身份验证的情况下启动，并要求用户使用AUTH选项发送AUTH或HELLO，以便以某种方式进行身份验证。</td><td></td></tr><tr><td>权限的添加删除</td><td><strong>+<command></strong></td><td>将指令添加到用户可以调用的指令列表中</td></tr><tr><td><strong>-<command></strong></td><td>从用户可执行指令列表移除指令</td><td></td></tr><tr><td><strong>+@<category></category></strong></td><td>添加该类别中用户要调用的所有指令，有效类别为@admin、@set、@sortedset…等，通过调用ACL CAT命令查看完整列表。特殊类别@all表示所有命令，包括当前存在于服务器中的命令，以及将来将通过模块加载的命令。</td><td></td></tr><tr><td>-@<actegory></actegory></td><td>从用户可调用指令中移除类别</td><td></td></tr><tr><td><strong>allcommands</strong></td><td>+@all的别名</td><td></td></tr><tr><td><strong>nocommand</strong></td><td>-@all的别名</td><td></td></tr><tr><td>可操作键的添加或删除</td><td><strong>~<pattern></pattern></strong></td><td>添加可作为用户可操作的键的模式。例如~*允许所有的键</td></tr></tbody></table><p>（2）通过命令创建新用户默认权限</p><p>acl setuser user1</p> <img src="/2022/09/05/redis-ji-chu-zhi-shi/72.png" class><p>在上面的示例中，我根本没有指定任何规则。如果用户不存在，这将使用just created的默认属性来创建用户。如果用户已经存在，则上面的命令将不执行任何操作。</p><p>（3）设置有用户名、密码、ACL权限、并启用的用户</p><p>acl setuser user2 on &gt;password ~cached:* +get</p> <img src="/2022/09/05/redis-ji-chu-zhi-shi/73.png" class><p>(4)切换用户，验证权限</p> <img src="/2022/09/05/redis-ji-chu-zhi-shi/74.png" class><h4 id="13-2-IO多线程"><a href="#13-2-IO多线程" class="headerlink" title="13.2 IO多线程"></a>13.2 IO多线程</h4><h5 id="13-2-1-简介"><a href="#13-2-1-简介" class="headerlink" title="13.2.1 简介"></a>13.2.1 简介</h5><p>​Redis6终于支撑多线程了，告别单线程了吗？</p><p>​IO多线程其实指<strong>客户端交互部分</strong>的<strong>网络IO</strong>交互处理模块<strong>多线程</strong>，而非<strong>执行命令多线程</strong>。Redis6执行命令依然是单线程。</p><h5 id="13-2-2-原理架构"><a href="#13-2-2-原理架构" class="headerlink" title="13.2.2 原理架构"></a>13.2.2 原理架构</h5><p>​Redis 6 加入多线程,但跟 Memcached 这种从 IO处理到数据访问多线程的实现模式有些差异。Redis 的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程。之所以这么设计是不想因为多线程而变得复杂，需要去控制 key、lua、事务，LPUSH/LPOP 等等的并发问题。整体的设计大体如下:</p> <img src="/2022/09/05/redis-ji-chu-zhi-shi/75.png" class><p>另外，多线程IO默认也是不开启的，需要再配置文件中配置</p><p>io-threads-do-reads yes </p><p>io-threads 4</p><h4 id="13-3-工具支持Cluster"><a href="#13-3-工具支持Cluster" class="headerlink" title="13.3 工具支持Cluster"></a>13.3 工具支持Cluster</h4><p>​之前老版Redis想要搭集群需要单独安装ruby环境，Redis 5 将 redis-trib.rb 的功能集成到 redis-cli 。另外官方 redis-benchmark 工具开始支持 cluster 模式了，通过多线程的方式对多个分片进行压测。</p>  <img src="/2022/09/05/redis-ji-chu-zhi-shi/76.png" class><h4 id="13-4-Redis新功能持续关注"><a href="#13-4-Redis新功能持续关注" class="headerlink" title="13.4 Redis新功能持续关注"></a>13.4 Redis新功能持续关注</h4><p>Redis6新功能还有：</p><p>1、RESP3新的 Redis 通信协议：优化服务端与客户端之间通信</p><p>2、Client side caching客户端缓存：基于 RESP3 协议实现的客户端缓存功能。为了进一步提升缓存的性能，将客户端经常访问的数据cache到客户端。减少TCP网络交互。</p><p>3、Proxy集群代理模式：Proxy 功能，让 Cluster 拥有像单实例一样的接入方式，降低大家使用cluster的门槛。不过需要注意的是代理不改变 Cluster 的功能限制，不支持的命令还是不会支持，比如跨 slot 的多Key操作。</p><p>4、Modules API</p><p>Redis 6中模块API开发进展非常大，因为Redis Labs为了开发复杂的功能，从一开始就用上Redis模块。Redis可以变成一个框架，利用Modules来构建不同系统，而不需要从头开始写然后还要BSD许可。Redis一开始就是一个向编写各种系统开放的平台。</p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NoSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dialog预览URL文件</title>
      <link href="/2022/08/28/dialog-yu-lan-url-wen-jian/"/>
      <url>/2022/08/28/dialog-yu-lan-url-wen-jian/</url>
      
        <content type="html"><![CDATA[<div class="note success no-icon"><p>Android使用Dialog预览URL资源文件</p></div><h2 id="1-Dialog弹窗"><a href="#1-Dialog弹窗" class="headerlink" title="1. Dialog弹窗"></a>1. Dialog弹窗</h2><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">//R.style.ActionSheetDialogStyle为dialog效果样式</span><span class="token class-name">Dialog</span> dialog <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dialog</span><span class="token punctuation">(</span><span class="token class-name">MyUploadGwActivity</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token class-name">R</span><span class="token punctuation">.</span>style<span class="token punctuation">.</span>ActionSheetDialogStyle<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//填充对话框的布局</span><span class="token class-name">View</span> inflate <span class="token operator">=</span> <span class="token class-name">LayoutInflater</span><span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token class-name">MyUploadGwActivity</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">inflate</span><span class="token punctuation">(</span><span class="token class-name">R</span><span class="token punctuation">.</span>layout<span class="token punctuation">.</span>video_dialog<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//通过view绑定布局中的控件</span><span class="token class-name">WebView</span> webView <span class="token operator">=</span> inflate<span class="token punctuation">.</span><span class="token function">findViewById</span><span class="token punctuation">(</span><span class="token class-name">R</span><span class="token punctuation">.</span>id<span class="token punctuation">.</span>mv_webview<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//填充对话框的布局</span>dialog<span class="token punctuation">.</span><span class="token function">setContentView</span><span class="token punctuation">(</span>inflate<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取当前Activity所在的窗体</span><span class="token class-name">Window</span> dialogWindow <span class="token operator">=</span> dialog<span class="token punctuation">.</span><span class="token function">getWindow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//设置Dialog窗体弹出位置</span>dialogWindow<span class="token punctuation">.</span><span class="token function">setGravity</span><span class="token punctuation">(</span><span class="token class-name">Gravity</span><span class="token punctuation">.</span>CENTER<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获得窗体的属性</span><span class="token class-name">WindowManager<span class="token punctuation">.</span>LayoutParams</span> lp <span class="token operator">=</span> dialogWindow<span class="token punctuation">.</span><span class="token function">getAttributes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//设置dialog的宽度</span>lp<span class="token punctuation">.</span>width <span class="token operator">=</span> <span class="token class-name">WindowManager<span class="token punctuation">.</span>LayoutParams</span><span class="token punctuation">.</span>MATCH_PARENT<span class="token punctuation">;</span><span class="token comment">//获取屏幕的分辨率</span><span class="token class-name">DisplayMetrics</span> dm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DisplayMetrics</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>dialog<span class="token punctuation">.</span><span class="token function">getWindow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getWindowManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDefaultDisplay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMetrics</span><span class="token punctuation">(</span>dm<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//按屏幕高度比例设置dialog高度</span>lp<span class="token punctuation">.</span>height <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>dm<span class="token punctuation">.</span>heightPixels <span class="token operator">*</span> <span class="token number">0.7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>dialogWindow<span class="token punctuation">.</span><span class="token function">setAttributes</span><span class="token punctuation">(</span>lp<span class="token punctuation">)</span><span class="token punctuation">;</span>dialog<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//显示对话框</span></code></pre><h2 id="2-WebView显示网页内容"><a href="#2-WebView显示网页内容" class="headerlink" title="2. WebView显示网页内容"></a>2. WebView显示网页内容</h2><pre class="language-java" data-language="java"><code class="language-java"><span class="token number">1.</span>添加网络权限<span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 添加网络权限 <span class="token operator">--</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token keyword">uses</span><span class="token operator">-</span>permission android<span class="token operator">:</span>name<span class="token operator">=</span><span class="token string">"android.permission.INTERNET"</span> <span class="token operator">/</span><span class="token operator">&gt;</span>    <span class="token number">2.</span>在布局文件中添加<span class="token class-name">WebView</span>控件；<span class="token operator">&lt;</span><span class="token class-name">WebView</span>         android<span class="token operator">:</span>id<span class="token operator">=</span><span class="token string">"@+id/wv_webview"</span>         android<span class="token operator">:</span>layout_width<span class="token operator">=</span><span class="token string">"match_parent"</span>         android<span class="token operator">:</span>layout_height<span class="token operator">=</span><span class="token string">"match_parent"</span> <span class="token operator">/</span><span class="token operator">&gt;</span>             <span class="token number">3.</span>在代码中让<span class="token class-name">WebView</span>控件加载显示网页<span class="token comment">//获得控件</span><span class="token class-name">WebView</span> webView <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">WebView</span><span class="token punctuation">)</span> <span class="token function">findViewById</span><span class="token punctuation">(</span><span class="token class-name">R</span><span class="token punctuation">.</span>id<span class="token punctuation">.</span>wv_webview<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//访问网页</span>webView<span class="token punctuation">.</span><span class="token function">loadUrl</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//系统默认会通过手机浏览器打开网页，为了能够直接通过WebView显示网页，则必须设置</span>webView<span class="token punctuation">.</span><span class="token function">setWebViewClient</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">WebViewClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">shouldOverrideUrlLoading</span><span class="token punctuation">(</span><span class="token class-name">WebView</span> view<span class="token punctuation">,</span> <span class="token class-name">WebResourceRequest</span> url<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//返回true</span>       <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment">//开始加载资源监听</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onPageStarted</span><span class="token punctuation">(</span><span class="token class-name">WebView</span> view<span class="token punctuation">,</span> <span class="token class-name">String</span> url<span class="token punctuation">,</span> <span class="token class-name">Bitmap</span> favicon<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//可添加loading动画</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onPageStarted</span><span class="token punctuation">(</span>view<span class="token punctuation">,</span> url<span class="token punctuation">,</span> favicon<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//加载资源完成监听</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onPageFinished</span><span class="token punctuation">(</span><span class="token class-name">WebView</span> view<span class="token punctuation">,</span> <span class="token class-name">String</span> url<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment">//结束loading动画</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onPageFinished</span><span class="token punctuation">(</span>view<span class="token punctuation">,</span> url<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>WebView更多使用可参考：</strong><a href="https://blog.csdn.net/weixin_40438421/article/details/85700109">https://blog.csdn.net/weixin_40438421/article/details/85700109</a></p><h2 id="3-Webview设置缩放以及自适应"><a href="#3-Webview设置缩放以及自适应" class="headerlink" title="3. Webview设置缩放以及自适应"></a>3. Webview设置缩放以及自适应</h2><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">WebSettings</span> settings <span class="token operator">=</span> webView<span class="token punctuation">.</span><span class="token function">getSettings</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>settings<span class="token punctuation">.</span><span class="token function">setUseWideViewPort</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//设定支持 viewport</span>settings<span class="token punctuation">.</span><span class="token function">setLoadWithOverviewMode</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//自适应屏幕</span>settings<span class="token punctuation">.</span><span class="token function">setBuiltInZoomControls</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>settings<span class="token punctuation">.</span><span class="token function">setDisplayZoomControls</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>settings<span class="token punctuation">.</span><span class="token function">setSupportZoom</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//设定支持缩放</span></code></pre><h2 id="4-使用WPS预览office文件"><a href="#4-使用WPS预览office文件" class="headerlink" title="4. 使用WPS预览office文件"></a>4. 使用WPS预览office文件</h2><p>使用过程中发现android中的WebView不能直接预览office文档，因此采用本地软件WPS预览。</p><p><strong>简单使用：</strong></p><pre class="language-java" data-language="java"><code class="language-java">   <span class="token comment">/**     * 通过获取应用列表对比判断是否安装有某个应用     * @param context     * @param pkgName  （wps包名："cn.wps.moffice_eng"）     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">checkAppInstalled</span><span class="token punctuation">(</span><span class="token class-name">Context</span> context<span class="token punctuation">,</span> <span class="token class-name">String</span> pkgName<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pkgName<span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> pkgName<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">final</span> <span class="token class-name">PackageManager</span> packageManager <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getPackageManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">PackageInfo</span><span class="token punctuation">&gt;</span></span> info <span class="token operator">=</span> packageManager<span class="token punctuation">.</span><span class="token function">getInstalledPackages</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>info <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> info<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> info<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>pkgName<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>info<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span>packageName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token class-name">Intent</span> intent <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Intent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Bundle</span> bundle <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Bundle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>bundle<span class="token punctuation">.</span><span class="token function">putString</span><span class="token punctuation">(</span><span class="token string">"OpenMode"</span><span class="token punctuation">,</span> <span class="token string">"ReadOnly"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打开模式,只读模式</span>bundle<span class="token punctuation">.</span><span class="token function">putBoolean</span><span class="token punctuation">(</span><span class="token string">"SendCloseBroad"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 关闭时是否发送广播</span>bundle<span class="token punctuation">.</span><span class="token function">putString</span><span class="token punctuation">(</span><span class="token string">"ThirdPackage"</span><span class="token punctuation">,</span> <span class="token function">getPackageName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 第三方应用的包名，用于对改应用合法性的验证</span>bundle<span class="token punctuation">.</span><span class="token function">putBoolean</span><span class="token punctuation">(</span><span class="token string">"ClearTrace"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 清除打开记录</span>bundle<span class="token punctuation">.</span><span class="token function">putBoolean</span><span class="token punctuation">(</span><span class="token string">"ClearFile"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//关闭后删除打开文件</span>intent<span class="token punctuation">.</span><span class="token function">addFlags</span><span class="token punctuation">(</span><span class="token class-name">Intent</span><span class="token punctuation">.</span>FLAG_ACTIVITY_NEW_TASK<span class="token punctuation">)</span><span class="token punctuation">;</span>intent<span class="token punctuation">.</span><span class="token function">setAction</span><span class="token punctuation">(</span><span class="token class-name"><span class="token namespace">android<span class="token punctuation">.</span>content<span class="token punctuation">.</span></span>Intent</span><span class="token punctuation">.</span>ACTION_VIEW<span class="token punctuation">)</span><span class="token punctuation">;</span>intent<span class="token punctuation">.</span><span class="token function">setClassName</span><span class="token punctuation">(</span><span class="token string">"cn.wps.moffice_eng"</span><span class="token punctuation">,</span> <span class="token string">"cn.wps.moffice.documentmanager.PreStartActivity2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//包名和类名</span>intent<span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span><span class="token class-name">Uri</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//这里采用传入文档的在线地址进行打开，免除下载的步骤，也不需要判断安卓版本号</span>intent<span class="token punctuation">.</span><span class="token function">putExtras</span><span class="token punctuation">(</span>bundle<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token function">startActivity</span><span class="token punctuation">(</span>intent<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ActivityNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>更多使用可参考：</strong><a href="https://www.jianshu.com/p/3de8dc4df569">https://www.jianshu.com/p/3de8dc4df569</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用Git命令</title>
      <link href="/2022/08/26/chang-yong-git-ming-ling/"/>
      <url>/2022/08/26/chang-yong-git-ming-ling/</url>
      
        <content type="html"><![CDATA[<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config --global user.name <span class="token string">"用户名"</span>   <span class="token comment">#配置全局的git提交用户名</span><span class="token function">git</span> config --global user.email <span class="token string">"邮箱"</span>    <span class="token comment">#配置全局的git提交者的邮箱</span><span class="token function">git</span> clone 仓库地址<span class="token comment">#将远程仓库克隆到本地</span><span class="token function">git</span> <span class="token function">add</span> <span class="token builtin class-name">.</span><span class="token comment">#添加文件（控制所有文件）</span><span class="token function">git</span> <span class="token function">add</span> 文件名<span class="token comment">#控制单个文件</span><span class="token function">git</span> commit -m <span class="token string">'本次提交的说明'</span><span class="token comment">#提交文件</span><span class="token function">git</span> push<span class="token comment">#上传文件</span><span class="token function">git</span> branch  <span class="token comment">#查看分支</span><span class="token function">git</span> pull<span class="token comment">#合并更新</span><span class="token function">git</span> branch 分支名    <span class="token comment">#创建分支</span><span class="token function">git</span> checkout -b 分支名   <span class="token comment">#创建并切换到当前分支</span><span class="token comment">### 合并分支并提交到远程仓库</span><span class="token function">git</span> checkout master   <span class="token comment">#先切换到主分支</span><span class="token function">git</span> merge 分支名  <span class="token comment">#将分支合并到主分支</span><span class="token function">git</span> push <span class="token comment">#将本地代码推送到云端</span></code></pre><h2 id="速查表"><a href="#速查表" class="headerlink" title="速查表"></a>速查表</h2><img src="/2022/08/26/chang-yong-git-ming-ling/01.png" class title="Git命令速查表">]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux安装MySQL5.7</title>
      <link href="/2022/08/25/linux-an-zhuang-mysql5-7/"/>
      <url>/2022/08/25/linux-an-zhuang-mysql5-7/</url>
      
        <content type="html"><![CDATA[<h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><h3 id="查看是否已有老版本MySQL并卸载"><a href="#查看是否已有老版本MySQL并卸载" class="headerlink" title="查看是否已有老版本MySQL并卸载"></a>查看是否已有老版本MySQL并卸载</h3><pre class="language-bash" data-language="bash"><code class="language-bash">查看包名：rpm -qa<span class="token operator">|</span><span class="token function">grep</span> -i mysql删除命令：rpm -ev 文件名</code></pre><p>如果提示依赖包错误，则使用以下命令尝试：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">rpm</span> -ev 文件名 --nodeps</code></pre><p>查找之前老版本MySQL的目录并删除：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">find</span> / -name mysql <span class="token function">rm</span> -rf 目录名</code></pre><p><strong>注意：</strong>卸载后/etc/my.cnf不会删除，需要进行手工删除</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">rm</span> -rf /etc/my.cnf</code></pre><p>再次查找机器是否安装MySQL</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">rpm</span> -qa<span class="token operator">|</span><span class="token function">grep</span> -i mysql</code></pre><h3 id="安装MySQL5-7"><a href="#安装MySQL5-7" class="headerlink" title="安装MySQL5.7"></a>安装MySQL5.7</h3><p>下载地址：<a href="https://dev.mysql.com/downloads/mysql/5.7.html#downloads">https://dev.mysql.com/downloads/mysql/5.7.html#downloads</a></p><p>自己用的安装包：<a href="https://pan.baidu.com/s/1eLjtjBJ-v9CJ19U5CqzbHQ">https://pan.baidu.com/s/1eLjtjBJ-v9CJ19U5CqzbHQ</a></p><p><strong>提取码：ipel</strong></p><img src="/2022/08/25/linux-an-zhuang-mysql5-7/01.png" class><p>传输到Linux后解压：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">tar</span> -xvf mysql-5.7.30-linux-glibc2.12-x86_64.tar.gz</code></pre><img src="/2022/08/25/linux-an-zhuang-mysql5-7/02.png" class><p>移动到合适目录并重命名：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">mv</span> mysql-5.7.30-linux-glibc2.12-x86_64 /usr/local/mysql</code></pre><img src="/2022/08/25/linux-an-zhuang-mysql5-7/03.png" class><p>创建MySQL用户组合用户并修改权限：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">groupadd</span> mysql<span class="token function">useradd</span> -r -g mysql mysql</code></pre><p>创建数据目录并赋予权限：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> -p  /data/mysql              <span class="token comment">#创建目录</span><span class="token function">chown</span> mysql:mysql -R /data/mysql   <span class="token comment">#赋予权限</span></code></pre><img src="/2022/08/25/linux-an-zhuang-mysql5-7/04.png" class><p>配置my.cnf：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /etc/my.cnf</code></pre><p>内容如下：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>mysqld<span class="token punctuation">]</span>bind-address<span class="token operator">=</span><span class="token number">0.0</span>.0.0<span class="token assign-left variable">port</span><span class="token operator">=</span><span class="token number">3306</span><span class="token assign-left variable">user</span><span class="token operator">=</span>mysql<span class="token comment">#根据自己路径修改</span><span class="token assign-left variable">basedir</span><span class="token operator">=</span>/usr/local/mysql<span class="token comment">#根据自己路径修改</span><span class="token assign-left variable">datadir</span><span class="token operator">=</span>/data/mysql<span class="token assign-left variable">socket</span><span class="token operator">=</span>/tmp/mysql.socklog-error<span class="token operator">=</span>/data/mysql/mysql.errpid-file<span class="token operator">=</span>/data/mysql/mysql.pid<span class="token comment">#character config</span><span class="token assign-left variable">character_set_server</span><span class="token operator">=</span>utf8mb4symbolic-links<span class="token operator">=</span><span class="token number">0</span><span class="token assign-left variable">explicit_defaults_for_timestamp</span><span class="token operator">=</span>true</code></pre><p>初始化数据库：</p><pre class="language-bash" data-language="bash"><code class="language-bash">进入MySQL的bin目录：<span class="token builtin class-name">cd</span> /usr/local/mysql/bin/初始化：./mysqld --defaults-file<span class="token operator">=</span>/etc/my.cnf --basedir<span class="token operator">=</span>/usr/local/mysql/ --datadir<span class="token operator">=</span>/data/mysql/ --user<span class="token operator">=</span>mysql --initialize</code></pre><p>若出现：</p><p>./mysqld: error while loading shared libraries: libaio.so.1: cannot open shared object file: No such</p><p>查看密码：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> /data/mysql/mysql.err</code></pre><img src="/2022/08/25/linux-an-zhuang-mysql5-7/05.png" class><pre class="language-bash" data-language="bash"><code class="language-bash">先将mysql.server放置到/etc/init.d/mysql中：<span class="token function">cp</span> /usr/local/mysql/support-files/mysql.server /etc/init.d/mysql启动MySQL：<span class="token function">service</span> mysql start<span class="token function">ps</span> -ef<span class="token operator">|</span><span class="token function">grep</span> mysql</code></pre><p>如图显示，说明MySQL已经安装成功！</p><img src="/2022/08/25/linux-an-zhuang-mysql5-7/06.png" class><p>修改密码</p><pre class="language-bash" data-language="bash"><code class="language-bash">使用上面的随机密码登录MySQL后执行下面三步操作，重新登录SET PASSWORD <span class="token operator">=</span> PASSWORD<span class="token punctuation">(</span><span class="token string">'123456'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ALTER <span class="token environment constant">USER</span> <span class="token string">'root'</span>@<span class="token string">'localhost'</span> PASSWORD EXPIRE NEVER<span class="token punctuation">;</span>FLUSH PRIVILEGES</code></pre><img src="/2022/08/25/linux-an-zhuang-mysql5-7/07.png" class><p><strong>设置任意目录都能执行mysql -u root -p登录MySQL（可选）：</strong></p><p>1、进入/etc目录，编辑profile文件</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /etc<span class="token function">vi</span> profile</code></pre><p>2、在文件末尾修改PATH变量，如图：在PATH变量的加上脚本的路径（存在其他路径用冒号“:”隔开在末尾添加）</p><img src="/2022/08/25/linux-an-zhuang-mysql5-7/08.png" class><p>3、保存修改的profile文件，让修改立即生效，运行命令：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">source</span> /etc/profile</code></pre><p><strong>这时候仍无法使用远程连接，登录数据库执行下面三个命令</strong></p><pre class="language-bash" data-language="bash"><code class="language-bash">use mysql                                            <span class="token comment">#访问mysql库</span>update user <span class="token builtin class-name">set</span> <span class="token function">host</span> <span class="token operator">=</span> <span class="token string">'%'</span> where user <span class="token operator">=</span> <span class="token string">'root'</span><span class="token punctuation">;</span>      <span class="token comment">#使root能再任何host访问</span>FLUSH PRIVILEGES<span class="token punctuation">;</span>                                    <span class="token comment">#刷新</span></code></pre><img src="/2022/08/25/linux-an-zhuang-mysql5-7/09.png" class><p><strong>再次使用远程连接</strong></p><img src="/2022/08/25/linux-an-zhuang-mysql5-7/10.png" class><p><strong>连接成功！！！</strong></p><p><strong>MySQL5.7装好了，这是我卸载了其他版本的MySQL重装的过程，按这个流程应该能顺利安装</strong></p><p><strong>远程连接注意防火墙问题！！！</strong><a href="https://feiutech.blog.csdn.net/article/details/74502967?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-8.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-8.control">防火墙相关操作</a></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo常用命令</title>
      <link href="/2022/08/24/hexo-chang-yong-ming-ling/"/>
      <url>/2022/08/24/hexo-chang-yong-ming-ling/</url>
      
        <content type="html"><![CDATA[<h2 id="一、安装、升级"><a href="#一、安装、升级" class="headerlink" title="一、安装、升级"></a>一、安装、升级</h2><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo -g <span class="token comment">#安装  </span><span class="token function">npm</span> update hexo -g <span class="token comment">#升级  </span>hexo init <span class="token comment">#初始化</span></code></pre><h2 id="二、简写"><a href="#二、简写" class="headerlink" title="二、简写"></a>二、简写</h2><pre class="language-bash" data-language="bash"><code class="language-bash">hexo n <span class="token string">"我的博客"</span> <span class="token operator">==</span> hexo new <span class="token string">"我的博客"</span> <span class="token comment">#新建文章</span>hexo p <span class="token operator">==</span> hexo publishhexo g <span class="token operator">==</span> hexo generate<span class="token comment">#生成</span>hexo s <span class="token operator">==</span> hexo server <span class="token comment">#启动服务预览</span>hexo d <span class="token operator">==</span> hexo deploy<span class="token comment">#部署</span></code></pre><h2 id="三、服务器"><a href="#三、服务器" class="headerlink" title="三、服务器"></a>三、服务器</h2><pre class="language-bash" data-language="bash"><code class="language-bash">hexo server <span class="token comment">#Hexo 会监视文件变动并自动更新，您无须重启服务器。</span>hexo server -s <span class="token comment">#静态模式</span>hexo server -p <span class="token number">5000</span> <span class="token comment">#更改端口</span>hexo server -i <span class="token number">192.168</span>.1.1 <span class="token comment">#自定义 IP</span>hexo clean <span class="token comment">#清除缓存 网页正常情况下可以忽略此条命令</span>hexo g <span class="token comment">#生成静态网页</span>hexo d <span class="token comment">#开始部署</span></code></pre><h2 id="四、监视文件变动"><a href="#四、监视文件变动" class="headerlink" title="四、监视文件变动"></a>四、监视文件变动</h2><pre class="language-bash" data-language="bash"><code class="language-bash">hexo generate <span class="token comment">#使用 Hexo 生成静态文件快速而且简单</span>hexo generate --watch <span class="token comment">#监视文件变动</span></code></pre><h2 id="五、完成后部署"><a href="#五、完成后部署" class="headerlink" title="五、完成后部署"></a>五、完成后部署</h2><pre class="language-bash" data-language="bash"><code class="language-bash">两个命令作用相同hexo generate --deployhexo deploy --generatehexo deploy -ghexo server -g</code></pre><h2 id="六、草稿"><a href="#六、草稿" class="headerlink" title="六、草稿"></a>六、草稿</h2><pre class="language-bash" data-language="bash"><code class="language-bash">hexo publish <span class="token punctuation">[</span>layout<span class="token punctuation">]</span> <span class="token operator">&lt;</span>title<span class="token operator">&gt;</span></code></pre><h2 id="七、模板"><a href="#七、模板" class="headerlink" title="七、模板"></a>七、模板</h2><pre class="language-bash" data-language="bash"><code class="language-bash">hexo new <span class="token string">"postName"</span> <span class="token comment">#新建文章</span>hexo new page <span class="token string">"pageName"</span> <span class="token comment">#新建页面</span>hexo generate <span class="token comment">#生成静态页面至public目录</span>hexo server <span class="token comment">#开启预览访问端口（默认端口4000，'ctrl + c'关闭server）</span>hexo deploy <span class="token comment">#将.deploy目录部署到GitHub</span>hexo new <span class="token punctuation">[</span>layout<span class="token punctuation">]</span> <span class="token operator">&lt;</span>title<span class="token operator">&gt;</span>hexo new photo <span class="token string">"My Gallery"</span>hexo new <span class="token string">"Hello World"</span> --lang tw</code></pre><h2 id="八、推送到服务器上"><a href="#八、推送到服务器上" class="headerlink" title="八、推送到服务器上"></a>八、推送到服务器上</h2><pre class="language-bash" data-language="bash"><code class="language-bash">hexo n <span class="token comment">#写文章</span>hexo g <span class="token comment">#生成</span>hexo d <span class="token comment">#部署 #可与hexo g合并为 hexo d -g</span></code></pre><p>更全面详细的指令使用参考官网：<a href="https://hexo.io/zh-cn/docs/commands">指令 | Hexo</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/08/23/hello-world/"/>
      <url>/2022/08/23/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="language-bash" data-language="bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="language-bash" data-language="bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="language-bash" data-language="bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
