<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Docker学习笔记</title>
      <link href="/2022/09/19/docker-xue-xi-bi-ji/"/>
      <url>/2022/09/19/docker-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><h2 id="1-Docker基本组成"><a href="#1-Docker基本组成" class="headerlink" title="1. Docker基本组成"></a>1. Docker基本组成</h2><ul><li>镜像(image)</li></ul><p>Docker镜像是一个只读的模板，镜像可以用来创建Docker容器，一个镜像可以创建多个容器。</p><ul><li>容器(container)</li></ul><p>Docker容器独立运行一个或者一组应用，应用程序或服务运行在容器里面，容器就类似于一个虚拟化的运行环境。(可以把容器看做是一个简易版的Linux环境)</p><ul><li>仓库(repository)</li></ul><p>仓库是集中存放镜像文件的场所。类似于Maven仓库存放各种jar包的地方。</p><img src="/2022/09/19/docker-xue-xi-bi-ji/01.jpg" class=""><h2 id="2-CentOS-7安装Docker"><a href="#2-CentOS-7安装Docker" class="headerlink" title="2. CentOS 7安装Docker"></a>2. CentOS 7安装Docker</h2><p><a href="https://docs.docker.com/engine/install/centos/">Install Docker Engine on CentOS | Docker Documentation</a></p><h3 id="2-1-卸载旧版本"><a href="#2-1-卸载旧版本" class="headerlink" title="2.1 卸载旧版本"></a>2.1 卸载旧版本</h3><img src="/2022/09/19/docker-xue-xi-bi-ji/02.png" class=""><h3 id="2-2-yum安装gcc相关"><a href="#2-2-yum安装gcc相关" class="headerlink" title="2.2 yum安装gcc相关"></a>2.2 yum安装gcc相关</h3><pre class="language-none"><code class="language-none">yum -y install gccyum -y install gcc-c++</code></pre><img src="/2022/09/19/docker-xue-xi-bi-ji/03.png" class=""><h3 id="2-3-安装官网要求的包"><a href="#2-3-安装官网要求的包" class="headerlink" title="2.3 安装官网要求的包"></a>2.3 安装官网要求的包</h3><img src="/2022/09/19/docker-xue-xi-bi-ji/04.png" class=""><p><code>yum install -y yum-utils</code></p><h3 id="2-4-设置stable镜像仓库"><a href="#2-4-设置stable镜像仓库" class="headerlink" title="2.4 设置stable镜像仓库"></a>2.4 设置stable镜像仓库</h3><p>使用官网方式下载速度慢，经常出错，改用阿里云镜像</p><p><code>yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</code></p><h3 id="2-5-更新软件包索引"><a href="#2-5-更新软件包索引" class="headerlink" title="2.5 更新软件包索引"></a>2.5 更新软件包索引</h3><p><code>yum makecache fast</code></p><h3 id="2-6-安装Docker引擎"><a href="#2-6-安装Docker引擎" class="headerlink" title="2.6 安装Docker引擎"></a>2.6 安装Docker引擎</h3><p><code>yum install docker-ce docker-ce-cli containerd.io</code></p><img src="/2022/09/19/docker-xue-xi-bi-ji/05.png" class=""><h3 id="2-7-启动Docker"><a href="#2-7-启动Docker" class="headerlink" title="2.7 启动Docker"></a>2.7 启动Docker</h3><p><code>systemctl start docker</code></p><h3 id="2-8-测试"><a href="#2-8-测试" class="headerlink" title="2.8 测试"></a>2.8 测试</h3><p><code>docker version</code></p><img src="/2022/09/19/docker-xue-xi-bi-ji/06.png" class=""><p><code>docker run hello-world</code></p><img src="/2022/09/19/docker-xue-xi-bi-ji/07.png" class=""><h2 id="3-卸载Docker"><a href="#3-卸载Docker" class="headerlink" title="3. 卸载Docker"></a>3. 卸载Docker</h2><img src="/2022/09/19/docker-xue-xi-bi-ji/08.png" class=""><pre class="language-none"><code class="language-none">systemctl stop dockeryum remove docker-ce docker-ce-cli containerd.io docker-compose-pluginrm -rf /var/lib/dockerrm -rf /var/lib/containerd</code></pre><h2 id="4-阿里云镜像加速（个人版）"><a href="#4-阿里云镜像加速（个人版）" class="headerlink" title="4. 阿里云镜像加速（个人版）"></a>4. 阿里云镜像加速（个人版）</h2><img src="/2022/09/19/docker-xue-xi-bi-ji/09.png" class=""><ul><li>直接粘贴</li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/10.png" class=""><pre class="language-none"><code class="language-none">mkdir -p /etc/dockertee /etc/docker/daemon.json &lt;&lt;-'EOF'{  "registry-mirrors": ["https://hzey81li.mirror.aliyuncs.com"]}EOF</code></pre><ul><li>重启服务</li></ul><pre class="language-none"><code class="language-none">systemctl daemon-reloadsystemctl restart docker</code></pre><h2 id="5-run-hello-world简单分析"><a href="#5-run-hello-world简单分析" class="headerlink" title="5. run hello-world简单分析"></a>5. run hello-world简单分析</h2><ul><li>docker run hello-world</li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/12.png" class=""><p>输出这段提示后，hello-world就会停止运行，容器自动终止。</p><ul><li>run干了什么</li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/11.jpg" class=""><h2 id="6-为什么Docker会比VM虚拟机快"><a href="#6-为什么Docker会比VM虚拟机快" class="headerlink" title="6. 为什么Docker会比VM虚拟机快"></a>6. 为什么Docker会比VM虚拟机快</h2><p><strong>(1)docker有着比虚拟机更少的抽象层</strong></p><p>​由于docker不需要Hypervisor(虚拟机)实现硬件资源虚拟化,运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker将会在效率上有明显优势。</p><p><strong>(2)docker利用的是宿主机的内核,而不需要加载操作系统OS内核</strong></p><p>​当新建一个容器时,docker不需要和虚拟机一样重新加载一个操作系统内核。进而避免引寻、加载操作系统内核返回等比较费时费资源的过程,当新建一个虚拟机时,虚拟机软件需要加载OS,返回新建过程是分钟级别的。而docker由于直接利用宿主机的操作系统,则省略了返回过程,因此新建一个docker容器只需要几秒钟。</p><img src="/2022/09/19/docker-xue-xi-bi-ji/13.jpg" class=""><img src="/2022/09/19/docker-xue-xi-bi-ji/14.png" class=""><h2 id="7-Docker常用命令"><a href="#7-Docker常用命令" class="headerlink" title="7. Docker常用命令"></a>7. Docker常用命令</h2><h3 id="7-1-帮助启动类命令"><a href="#7-1-帮助启动类命令" class="headerlink" title="7.1 帮助启动类命令"></a>7.1 帮助启动类命令</h3><ul><li><p>启动docker： systemctl start docker</p></li><li><p>停止docker： systemctl stop docker</p></li><li><p>重启docker： systemctl restart docker</p></li><li><p>查看docker状态： systemctl status docker</p></li><li><p>开机启动： systemctl enable docker</p></li><li><p>查看docker概要信息： docker info</p></li><li><p>查看docker总体帮助文档： docker –help</p></li><li><p>查看docker命令帮助文档： docker 具体命令 –help</p></li></ul><h3 id="7-2-镜像命令"><a href="#7-2-镜像命令" class="headerlink" title="7.2 镜像命令"></a>7.2 镜像命令</h3><p>（1）列出本地主机上的镜像：docker images [OPTIONS]</p><p>OPTIONS说明：</p><ul><li>-a：列出本地所有的镜像（含历史映像层）</li><li>-q：只显示镜像ID</li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/15.jpg" class=""><p>各个选项说明：</p><pre class="language-none"><code class="language-none">REPOSITORY：表示镜像的仓库源TAG：镜像的标签版本号IMAGE ID：镜像IDCREATED：镜像创建时间SIZE：镜像大小同一仓库源可以有多个 TAG版本，代表这个仓库源的不同个版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。（mysql:5.7）如果你不指定一个镜像的版本标签，例如你只使用 ubuntu，docker 将默认使用 ubuntu:latest 镜像</code></pre><p>（2）搜索某个镜像：docker search [OPTIONS] 镜像名字</p><p>OPTIONS说明：</p><ul><li>–limit：只列出N个镜像，默认25个</li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/16.png" class=""><img src="/2022/09/19/docker-xue-xi-bi-ji/17.jpg" class=""><p>（3）下载镜像：docker pull 镜像名字[:TAG]</p><p>（4）查看镜像/容器/数据卷所占的空间：docker system df</p><img src="/2022/09/19/docker-xue-xi-bi-ji/18.jpg" class=""><p>（5）删除单个镜像：docker rmi -f 镜像ID</p><p>（6）删除多个镜像：docker rmi -f 镜像名1:TAG 镜像名2:TAG</p><p>（7）删除全部镜像：docker rmi -f $(docker image -qa)</p><h3 id="7-3-容器命令"><a href="#7-3-容器命令" class="headerlink" title="7.3 容器命令"></a>7.3 容器命令</h3><p>（1）新建+启动容器：docker run [OPTIONS] IMAGE [COMMAND] [ARG…]</p><p>OPTIONS说明：</p><ul><li><p>–name=”容器新名字”：为容器指定一个名称</p></li><li><p>-d：后台运行容器并返回容器ID，即启动守护式容器(后台运行)</p></li><li><p>-i：以交互模式运行容器，通常与-t同时使用 -it</p></li><li><p>-t：为容器重新分配一个伪输入终端，通常与-i同时使用</p></li><li><p>-P：随机端口映射，大写P</p></li><li><p>-p：指定端口映射，小写p</p></li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/19.jpg" class=""><p>启动交互式容器(前台命令行)：</p><img src="/2022/09/19/docker-xue-xi-bi-ji/20.jpg" class=""><p>-i：交互式操作。</p><p>-t：终端。</p><p>centos：centos 镜像。</p><p>/bin/bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash</p><p>（2）列出当前所有正在运行的容器：docker ps [OPTIONS]</p><p>OPTIONS说明：</p><ul><li>-a：列出当前所有正在运行的容器+历史上运行过的</li><li>-l：显示最近创建的容器</li><li>-n：显示最近n个创建的容器</li><li>-q：静默模式，只显示容器编号</li></ul><p>（3）退出容器：</p><ul><li>run进去容器，exit退出，容器停止</li><li>run进去容器，ctrl+p+q退出，容器不停止</li></ul><p>（4）启动已停止运行的容器：docker start 容器ID或容器名</p><p>（5）重启容器：docker restart 容器ID或容器名</p><p>（6）停止容器：docker stop 容器ID或容器名</p><p>（7）强制停止容器：docker kill 容器ID或容器名</p><p>（8）删除已停止的容器：docker rm 容器ID</p><p>（9）一次删除多个容器：docker rm -f $(docker ps -a -q)</p><p>（10）查看容器内运行的进程：docker top 容器ID</p><p>（11）重新进入容器：</p><ul><li>docker exec -it 容器ID /bin/bash（推荐使用）</li><li>docker attach 容器ID</li></ul><p>两者区别：</p><ol><li>attach直接进入容器启动命令的终端，不会启动新的进程 用exit退出，会导致容器的停止。</li><li>exec 是在容器中打开新的终端，并且可以启动新的进程 用exit退出，不会导致容器的停止。</li></ol><h2 id="8-Docker镜像commit操作案例"><a href="#8-Docker镜像commit操作案例" class="headerlink" title="8. Docker镜像commit操作案例"></a>8. Docker镜像commit操作案例</h2><ul><li>docker commit 提交容器副本使之成为一个新的镜像</li></ul><p>命令：docker commit -m=”提交的描述信息” -a=”作者” 容器ID 要创建的目标镜像名:[标签名]</p><h3 id="案例演示ubuntu安装vim"><a href="#案例演示ubuntu安装vim" class="headerlink" title="案例演示ubuntu安装vim"></a>案例演示ubuntu安装vim</h3><p><strong>原始默认的Ubuntu镜像是不带有vim命令的</strong></p><img src="/2022/09/19/docker-xue-xi-bi-ji/21.png" class=""><ul><li>外网连通的情况下，安装vim</li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/22.jpg" class=""><p>docker容器内执行上述两条命令：</p><p><code>apt-get update</code></p><p><code>apt-get -y install vim</code></p><img src="/2022/09/19/docker-xue-xi-bi-ji/23.png" class=""><img src="/2022/09/19/docker-xue-xi-bi-ji/24.png" class=""><img src="/2022/09/19/docker-xue-xi-bi-ji/242.png" class=""><ul><li>安装完成后，commit新的镜像</li></ul><p><code>docker commit -m="提交的描述信息" -a="作者" 容器ID 要创建的目标镜像名:[标签名]</code></p><img src="/2022/09/19/docker-xue-xi-bi-ji/25.png" class=""><ul><li>启动我们的新镜像并和原来的对比</li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/26.png" class=""><ul><li>小总结</li></ul><p>Docker中的镜像分层，支持通过扩展现有镜像，创建新的镜像。类似Java继承于一个Base基础类，自己再按需扩展。</p><p>新镜像是从 base 镜像一层一层叠加生成的。每安装一个软件，就在现有镜像的基础上增加一层</p><img src="/2022/09/19/docker-xue-xi-bi-ji/27.jpg" class=""><h2 id="9-本地镜像发布到阿里云"><a href="#9-本地镜像发布到阿里云" class="headerlink" title="9. 本地镜像发布到阿里云"></a>9. 本地镜像发布到阿里云</h2><img src="/2022/09/19/docker-xue-xi-bi-ji/28.jpg" class=""><ol><li>本地镜像素材原型</li></ol><img src="/2022/09/19/docker-xue-xi-bi-ji/29.png" class=""><ol start="2"><li>选择控制台，进入容器镜像服务</li></ol><img src="/2022/09/19/docker-xue-xi-bi-ji/30.png" class=""><ol start="3"><li>择个人实例</li></ol><img src="/2022/09/19/docker-xue-xi-bi-ji/31.png" class=""><ol start="4"><li>创建命名空间</li></ol><img src="/2022/09/19/docker-xue-xi-bi-ji/32.png" class=""><ol start="5"><li>创建镜像仓库</li></ol><img src="/2022/09/19/docker-xue-xi-bi-ji/33.png" class=""><img src="/2022/09/19/docker-xue-xi-bi-ji/34.png" class=""><ol start="6"><li>进入仓库管理界面</li></ol><img src="/2022/09/19/docker-xue-xi-bi-ji/35.png" class=""><ol start="7"><li>将镜像推送到阿里云仓库</li></ol><img src="/2022/09/19/docker-xue-xi-bi-ji/36.png" class=""><ol start="8"><li>将阿里云上的镜像下载到本地</li></ol><img src="/2022/09/19/docker-xue-xi-bi-ji/38.png" class=""><img src="/2022/09/19/docker-xue-xi-bi-ji/37.png" class=""><h2 id="10-本地镜像发布到私有库"><a href="#10-本地镜像发布到私有库" class="headerlink" title="10. 本地镜像发布到私有库"></a>10. 本地镜像发布到私有库</h2><h3 id="10-1-下载镜像Docker-Registry"><a href="#10-1-下载镜像Docker-Registry" class="headerlink" title="10.1 下载镜像Docker Registry"></a>10.1 下载镜像Docker Registry</h3><p><code>docker pull registry</code></p><img src="/2022/09/19/docker-xue-xi-bi-ji/39.jpg" class=""><img src="/2022/09/19/docker-xue-xi-bi-ji/40.jpg" class=""><h3 id="10-2-运行私有库Registry，相当于本地有个私有Docker-hub"><a href="#10-2-运行私有库Registry，相当于本地有个私有Docker-hub" class="headerlink" title="10.2 运行私有库Registry，相当于本地有个私有Docker hub"></a>10.2 运行私有库Registry，相当于本地有个私有Docker hub</h3><p><code>docker run -d -p 5000:5000 -v /zzyyuse/myregistry/:/tmp/registry --privileged=true registry</code></p><p>默认情况，仓库被创建在容器的/var/lib/registry目录下，建议自行用容器卷映射，方便于宿主机联调</p><img src="/2022/09/19/docker-xue-xi-bi-ji/41.jpg" class=""><h3 id="10-3-案例演示创建一个新镜像，ubuntu安装ifconfig命令"><a href="#10-3-案例演示创建一个新镜像，ubuntu安装ifconfig命令" class="headerlink" title="10.3 案例演示创建一个新镜像，ubuntu安装ifconfig命令"></a>10.3 案例演示创建一个新镜像，ubuntu安装ifconfig命令</h3><img src="/2022/09/19/docker-xue-xi-bi-ji/42.jpg" class=""><img src="/2022/09/19/docker-xue-xi-bi-ji/43.jpg" class=""><img src="/2022/09/19/docker-xue-xi-bi-ji/44.jpg" class=""><h3 id="10-4-提交新镜像"><a href="#10-4-提交新镜像" class="headerlink" title="10.4 提交新镜像"></a>10.4 提交新镜像</h3><p><code>docker commit -m="提交的描述信息" -a="作者" 容器ID 要创建的目标镜像名:[标签名]</code></p><img src="/2022/09/19/docker-xue-xi-bi-ji/45.jpg" class=""><h3 id="10-5-curl验证私服库上有什么镜像"><a href="#10-5-curl验证私服库上有什么镜像" class="headerlink" title="10.5 curl验证私服库上有什么镜像"></a>10.5 curl验证私服库上有什么镜像</h3><p><code>curl -XGET http://192.168.111.162:5000/v2/_catalog</code></p><p>可以看到，目前私服库没有任何镜像上传过</p><img src="/2022/09/19/docker-xue-xi-bi-ji/46.jpg" class=""><h3 id="10-6-将新镜像的Tag修改成符合规定的Tag"><a href="#10-6-将新镜像的Tag修改成符合规定的Tag" class="headerlink" title="10.6 将新镜像的Tag修改成符合规定的Tag"></a>10.6 将新镜像的Tag修改成符合规定的Tag</h3><p><code>docker tag zzyyubuntu:1.2 192.168.111.162:5000/zzyyubuntu:1.2</code></p><img src="/2022/09/19/docker-xue-xi-bi-ji/47.jpg" class=""><h3 id="10-7-修改配置文件使之支持http"><a href="#10-7-修改配置文件使之支持http" class="headerlink" title="10.7 修改配置文件使之支持http"></a>10.7 修改配置文件使之支持http</h3><img src="/2022/09/19/docker-xue-xi-bi-ji/48.jpg" class=""><p>registry-mirrors 配置的是国内阿里提供的镜像加速地址，不用加速的话访问官网的会很慢。</p><p><strong>2个配置中间有个逗号 ‘,’ 别漏了</strong>，这个配置是json格式的。</p><p>上述理由：docker默认不允许http方式推送镜像，通过配置选项来取消这个限制。====&gt; 修改完后如果不生效，建议重启docker</p><h3 id="10-8-push推送到私服库"><a href="#10-8-push推送到私服库" class="headerlink" title="10.8 push推送到私服库"></a>10.8 push推送到私服库</h3><p><code>docker push 192.168.111.162:5000/zzyyubuntu:1.2</code></p><img src="/2022/09/19/docker-xue-xi-bi-ji/49.jpg" class=""><h3 id="10-9-curl再次验证私服库上有什么镜像"><a href="#10-9-curl再次验证私服库上有什么镜像" class="headerlink" title="10.9 curl再次验证私服库上有什么镜像"></a>10.9 curl再次验证私服库上有什么镜像</h3><p><code>curl -XGET http://192.168.111.162:5000/v2/_catalog</code></p><img src="/2022/09/19/docker-xue-xi-bi-ji/50.jpg" class=""><h3 id="10-10-pull到本地并运行"><a href="#10-10-pull到本地并运行" class="headerlink" title="10.10 pull到本地并运行"></a>10.10 pull到本地并运行</h3><p><code>docker pull 192.168.111.162:5000/zzyyubuntu:1.2</code></p><img src="/2022/09/19/docker-xue-xi-bi-ji/51.jpg" class=""><p><code>docker run -it 镜像ID /bin/bash</code></p><img src="/2022/09/19/docker-xue-xi-bi-ji/52.jpg" class=""><h2 id="11-Docker容器数据卷"><a href="#11-Docker容器数据卷" class="headerlink" title="11. Docker容器数据卷"></a>11. Docker容器数据卷</h2><h3 id="11-1-why"><a href="#11-1-why" class="headerlink" title="11.1 why"></a>11.1 why</h3><p>Docker挂载主机目录访问如果出现cannot open directory .: Permission denied</p><p>解决办法：在挂载目录后多加一个–privileged=true参数即可</p><p>如果是CentOS7安全模块会比之前系统版本加强，不安全的会先禁止，所以目录挂载的情况被默认为不安全的行为，在SELinux里面挂载目录被禁止掉了额，如果要开启，我们一般使用–privileged=true命令，扩大容器的权限解决挂载目录没有权限的问题，也即</p><p>使用该参数，container内的root拥有真正的root权限，否则，container内的root只是外部的一个普通用户权限。</p><h3 id="11-2-是什么"><a href="#11-2-是什么" class="headerlink" title="11.2 是什么"></a>11.2 是什么</h3><p>卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过Union File System提供一些用于持续存储或共享数据的特性：</p><p>卷的设计目的就是<strong>数据的持久化</strong>，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷。</p><ul><li><p>有点类似我们Redis里面的rdb和aof文件</p></li><li><p>将docker容器内的数据保存进宿主机的磁盘中</p></li><li><p>运行一个带有容器卷存储功能的容器实例</p><p><code>docker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录   镜像名</code></p></li></ul><h3 id="11-3-能干嘛"><a href="#11-3-能干嘛" class="headerlink" title="11.3 能干嘛"></a>11.3 能干嘛</h3><ul><li>将运用与运行的环境打包镜像，run后形成容器实例运行 ，但是我们对数据的要求希望是<strong>持久化的</strong></li></ul><p>Docker容器产生的数据，如果不备份，那么当容器实例删除后，容器内的数据自然也就没有了。为了能保存数据在docker中我们使用卷。</p><p>特点：</p><ol><li><p>数据卷可在容器之间共享或重用数据</p></li><li><p>卷中的更改可以直接实时生效</p></li><li><p>数据卷中的更改不会包含在镜像的更新中</p></li><li><p>数据卷的生命周期一直持续到没有容器使用它为止</p></li></ol><h3 id="11-4-数据卷案例"><a href="#11-4-数据卷案例" class="headerlink" title="11.4 数据卷案例"></a>11.4 数据卷案例</h3><ul><li>宿主vs容器之间映射添加容器卷</li></ul><p>命令：<code>docker run -it -v /宿主机目录:/容器内目录 ubuntu /bin/bash</code></p><p><code>docker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录   镜像名</code></p><img src="/2022/09/19/docker-xue-xi-bi-ji/53.jpg" class=""><ul><li>查看数据卷是否挂载成功</li></ul><p><code>docker inspect 容器ID</code></p><img src="/2022/09/19/docker-xue-xi-bi-ji/54.jpg" class=""><ul><li>容器和宿主机之间数据共享<ol><li>docker修改，主机同步获得</li><li>主机修改，docker同步获得</li><li>docker容器stop，主机修改，docker容器重启数据同步</li></ol></li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/55.jpg" class=""><ul><li>读写规则映射添加说明</li></ul><p>（1）默认读写：</p><p><code>docker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录:rw   镜像名</code></p><img src="/2022/09/19/docker-xue-xi-bi-ji/56.jpg" class=""><img src="/2022/09/19/docker-xue-xi-bi-ji/57.jpg" class=""><p>（2）只读</p><p>容器实例内部被限制，只能读取不能写</p><p><code>docker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录:ro   镜像名</code></p><img src="/2022/09/19/docker-xue-xi-bi-ji/58.jpg" class=""><ul><li>卷的继承和共享</li></ul><p>（1）容器1完成和宿主机的映射</p><p><code>docker run -it --privileged=true -v /mydocker/u:/tmp --name u1 ubuntu</code></p><img src="/2022/09/19/docker-xue-xi-bi-ji/59.jpg" class=""><img src="/2022/09/19/docker-xue-xi-bi-ji/60.jpg" class=""><p>（2）容器2继承容器1的卷规则</p><p><code>docker run -it --privileged=true --volumes-from 父类 --name u2 ubuntu</code></p><img src="/2022/09/19/docker-xue-xi-bi-ji/61.jpg" class=""><h2 id="12-Docker安装常用软件"><a href="#12-Docker安装常用软件" class="headerlink" title="12. Docker安装常用软件"></a>12. Docker安装常用软件</h2><p>总体步骤：搜索镜像、拉取镜像、查看镜像、启动镜像、停止容器、移除容器</p><h3 id="12-1-安装tomcat"><a href="#12-1-安装tomcat" class="headerlink" title="12.1 安装tomcat"></a>12.1 安装tomcat</h3><p>（1）docker hub上面查找tomcat镜像</p><p><code>docker search tomcat</code></p><img src="/2022/09/19/docker-xue-xi-bi-ji/62.jpg" class=""><p>（2）从docker hub上拉取tomcat镜像到本地</p><p><code>docker pull tomcat</code></p><img src="/2022/09/19/docker-xue-xi-bi-ji/63.jpg" class=""><p>（3）查看是否有拉取到的tomcat</p><img src="/2022/09/19/docker-xue-xi-bi-ji/64.jpg" class=""><p>（4）使用镜像创建容器实例（运行镜像）</p><ul><li><p>docker run -it -p 8080:8080 tomcat</p></li><li><p>-p 小写，主机端口:docker容器端口</p></li><li><p>-P 大写，随机分配端口</p></li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/65.jpg" class=""><ul><li><p>-i:交互</p></li><li><p>-t:终端</p></li><li><p>-d:后台</p></li></ul><p>（5）访问猫首页</p><p>问题：</p><img src="/2022/09/19/docker-xue-xi-bi-ji/66.jpg" class=""><p>解决：</p><ul><li>可能没有映射端口或者没有关闭防火墙</li><li>把webapps.dist目录换成webapps</li><li>先成功启动tomcat</li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/67.jpg" class=""><ul><li>查看webapps文件夹为空</li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/68.jpg" class=""><p>（6）免修改版说明</p><ul><li><p>docker pull billygoo/tomcat8-jdk8</p></li><li><p>docker run -d -p 8080:8080 –name mytomcat8 billygoo/tomcat8-jdk8</p></li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/69.jpg" class=""><h3 id="12-2-安装mysql"><a href="#12-2-安装mysql" class="headerlink" title="12.2 安装mysql"></a>12.2 安装mysql</h3><ul><li>新建mysql容器实例</li></ul><pre class="language-none"><code class="language-none">docker run -d -p 3306:3306 --privileged=true -v /zzyyuse/mysql/log:/var/log/mysql -v /zzyyuse/mysql/data:/var/lib/mysql -v /zzyyuse/mysql/conf:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=123456  --name mysql mysql:5.7</code></pre><p>挂载容器数据卷，防止删容器数据也丢失。</p><ul><li>新建my.cnf，通过容器卷同步给mysql容器实例</li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/70.png" class=""><ul><li>重新启动mysql容器实例再重新进入并查看字符编码</li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/71.png" class=""><ul><li>新建库新建表插入中文测试</li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/72.png" class=""><img src="/2022/09/19/docker-xue-xi-bi-ji/73.png" class=""><ul><li>强制删除容器后，再次运行容器，数据依然存在</li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/74.png" class=""><h3 id="12-3-安装redis"><a href="#12-3-安装redis" class="headerlink" title="12.3 安装redis"></a>12.3 安装redis</h3><ul><li>从docker hub上(阿里云加速器)拉取redis镜像到本地标签为6.0.8，创建容器</li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/75.jpg" class=""><img src="/2022/09/19/docker-xue-xi-bi-ji/76.jpg" class=""><ul><li><strong>命令提醒：容器卷记得加入</strong>–privileged=true</li></ul><p>Docker挂载主机目录Docker访问出现cannot open directory .: Permission denied</p><p>解决办法：在挂载目录后多加一个–privileged=true参数即可</p><ul><li>在CentOS宿主机下新建目录/app/redis</li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/77.jpg" class=""><ul><li>将一个redis.conf文件模板拷贝进/app/redis目录下</li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/78.jpg" class=""><ul><li>/app/redis目录下修改redis.conf文件</li></ul><p>（1）开启redis验证  可选</p><p>  requirepass 123</p><p>（2）允许redis外地连接 <strong>必须</strong></p><p>   注释掉 # bind 127.0.0.1</p><img src="/2022/09/19/docker-xue-xi-bi-ji/79.jpg" class=""><p>（3） daemonize no</p><p>   将daemonize yes注释起来或者 daemonize no设置，因为该配置和docker run中-d参数冲突，会导致容器一直启动失败</p><img src="/2022/09/19/docker-xue-xi-bi-ji/80.jpg" class=""><p>（4）开启redis数据持久化 appendonly yes 可选</p><ul><li>使用redis6.0.8镜像创建容器(也叫运行镜像)</li></ul><pre class="language-none"><code class="language-none">docker run  -p 6379:6379 --name myr3 --privileged=true -v /app/redis/redis.conf:/etc/redis/redis.conf -v /app/redis/data:/data -d redis:6.0.8 redis-server /etc/redis/redis.conf</code></pre><img src="/2022/09/19/docker-xue-xi-bi-ji/81.jpg" class=""><ul><li>测试redis-cli连接上来</li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/82.jpg" class=""><p><code> docker exec -it 运行着Rediis服务的容器ID</code></p><p><code> redis-cli</code></p><h1 id="高级篇"><a href="#高级篇" class="headerlink" title="高级篇"></a>高级篇</h1><h2 id="13-Docker-复杂安装详说"><a href="#13-Docker-复杂安装详说" class="headerlink" title="13. Docker 复杂安装详说"></a>13. Docker 复杂安装详说</h2><h3 id="13-1-安装mysql主从复制"><a href="#13-1-安装mysql主从复制" class="headerlink" title="13.1 安装mysql主从复制"></a>13.1 安装mysql主从复制</h3><ul><li>新建主服务器容器实例 3307</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -p <span class="token number">3307</span>:3306 --name mysql-master <span class="token punctuation">\</span>-v /mydata/mysql-master/log:/var/log/mysql <span class="token punctuation">\</span>-v /mydata/mysql-master/data:/var/lib/mysql <span class="token punctuation">\</span>-v /mydata/mysql-master/conf:/etc/mysql <span class="token punctuation">\</span>-e <span class="token assign-left variable">MYSQL_ROOT_PASSWORD</span><span class="token operator">=</span>root  <span class="token punctuation">\</span>-d mysql:5.7</code></pre><ul><li>进入/mydata/mysql-master/conf目录下新建my.cnf，vim my.cnf</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>mysqld<span class="token punctuation">]</span><span class="token comment">## 设置server_id，同一局域网中需要唯一</span><span class="token assign-left variable">server_id</span><span class="token operator">=</span><span class="token number">101</span> <span class="token comment">## 指定不需要同步的数据库名称</span>binlog-ignore-db<span class="token operator">=</span>mysql  <span class="token comment">## 开启二进制日志功能</span>log-bin<span class="token operator">=</span>mall-mysql-bin  <span class="token comment">## 设置二进制日志使用内存大小（事务）</span><span class="token assign-left variable">binlog_cache_size</span><span class="token operator">=</span>1M  <span class="token comment">## 设置使用的二进制日志格式（mixed,statement,row）</span><span class="token assign-left variable">binlog_format</span><span class="token operator">=</span>mixed  <span class="token comment">## 二进制日志过期清理时间。默认值为0，表示不自动清理。</span><span class="token assign-left variable">expire_logs_days</span><span class="token operator">=</span><span class="token number">7</span>  <span class="token comment">## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。</span><span class="token comment">## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致</span><span class="token assign-left variable">slave_skip_errors</span><span class="token operator">=</span><span class="token number">1062</span></code></pre><ul><li>修改完配置后重启master实例</li></ul><p><code>docker restart mysql-master</code></p><ul><li>进入mysql-master容器，登录mysql</li></ul><p><code>docker exec -it mysql-master /bin/bash</code></p><p><code>mysql -uroot -proot</code></p><ul><li>master容器实例内创建数据同步用户</li></ul><pre class="language-mysql" data-language="mysql"><code class="language-mysql">CREATE USER 'slave'@'%' IDENTIFIED BY '123456';GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO 'slave'@'%';</code></pre><ul><li>新建从服务器容器实例 3308</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -p <span class="token number">3308</span>:3306 --name mysql-slave <span class="token punctuation">\</span>-v /mydata/mysql-slave/log:/var/log/mysql <span class="token punctuation">\</span>-v /mydata/mysql-slave/data:/var/lib/mysql <span class="token punctuation">\</span>-v /mydata/mysql-slave/conf:/etc/mysql <span class="token punctuation">\</span>-e <span class="token assign-left variable">MYSQL_ROOT_PASSWORD</span><span class="token operator">=</span>root  <span class="token punctuation">\</span>-d mysql:5.7</code></pre><ul><li>进入/mydata/mysql-slave/conf目录下新建my.cnf，vim my.cnf</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>mysqld<span class="token punctuation">]</span><span class="token comment">## 设置server_id，同一局域网中需要唯一</span><span class="token assign-left variable">server_id</span><span class="token operator">=</span><span class="token number">102</span><span class="token comment">## 指定不需要同步的数据库名称</span>binlog-ignore-db<span class="token operator">=</span>mysql  <span class="token comment">## 开启二进制日志功能，以备Slave作为其它数据库实例的Master时使用</span>log-bin<span class="token operator">=</span>mall-mysql-slave1-bin  <span class="token comment">## 设置二进制日志使用内存大小（事务）</span><span class="token assign-left variable">binlog_cache_size</span><span class="token operator">=</span>1M  <span class="token comment">## 设置使用的二进制日志格式（mixed,statement,row）</span><span class="token assign-left variable">binlog_format</span><span class="token operator">=</span>mixed  <span class="token comment">## 二进制日志过期清理时间。默认值为0，表示不自动清理。</span><span class="token assign-left variable">expire_logs_days</span><span class="token operator">=</span><span class="token number">7</span>  <span class="token comment">## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。</span><span class="token comment">## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致</span><span class="token assign-left variable">slave_skip_errors</span><span class="token operator">=</span><span class="token number">1062</span>  <span class="token comment">## relay_log配置中继日志</span><span class="token assign-left variable">relay_log</span><span class="token operator">=</span>mall-mysql-relay-bin  <span class="token comment">## log_slave_updates表示slave将复制事件写进自己的二进制日志</span><span class="token assign-left variable">log_slave_updates</span><span class="token operator">=</span><span class="token number">1</span>  <span class="token comment">## slave设置为只读（具有super权限的用户除外）</span><span class="token assign-left variable">read_only</span><span class="token operator">=</span><span class="token number">1</span></code></pre><ul><li>修改完配置后重启slave实例</li></ul><p><code>docker restart mysql-slave</code></p><ul><li>在<strong>主数据库</strong>中查看主从同步状态</li></ul><p><code>show master status;</code></p><ul><li>进入mysql-slave容器，登录mysql</li></ul><p><code>docker exec -it mysql-slave /bin/bash</code></p><p><code>mysql -uroot -proot</code></p><ul><li>在<strong>从数据库</strong>中配置主从复制</li></ul><pre class="language-mysql" data-language="mysql"><code class="language-mysql">change master to master_host='宿主机ip', master_user='slave', master_password='123456', master_port=3307, master_log_file='mall-mysql-bin.000001', master_log_pos=617, master_connect_retry=30;</code></pre><ul><li>主从复制命令参数说明：</li></ul><p>master_host：主数据库的IP地址；</p><p>master_port：主数据库的运行端口；</p><p>master_user：在主数据库创建的用于同步数据的用户账号；</p><p>master_password：在主数据库创建的用于同步数据的用户密码；</p><p>master_log_file：指定从数据库要复制数据的日志文件，通过查看主数据的状态，获取File参数；</p><p>master_log_pos：指定从数据库从哪个位置开始复制数据，通过查看主数据的状态，获取Position参数；</p><p>master_connect_retry：连接失败重试的时间间隔，单位为秒。</p><ul><li>在<strong>从数据库</strong>中查看主从同步状态</li></ul><p><code>show slave status \G;</code></p><img src="/2022/09/19/docker-xue-xi-bi-ji/83.png" class=""><ul><li>在<strong>从数据库</strong>中开启主从同步</li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/84.png" class=""><ul><li>再次查看<strong>从数据库</strong>同步状态</li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/85.png" class=""><ul><li>主从复制测试</li></ul><p>主机新建库，使用库，新建表，插入数据；从机使用库，查看记录。</p><img src="/2022/09/19/docker-xue-xi-bi-ji/86.png" class=""><img src="/2022/09/19/docker-xue-xi-bi-ji/87.png" class=""><h3 id="13-2-安装redis集群"><a href="#13-2-安装redis集群" class="headerlink" title="13.2 安装redis集群"></a>13.2 安装redis集群</h3><p>哈希槽分区</p><img src="/2022/09/19/docker-xue-xi-bi-ji/88.jpg" class=""><h4 id="13-2-1-3主3从redis集群配置"><a href="#13-2-1-3主3从redis集群配置" class="headerlink" title="13.2.1 3主3从redis集群配置"></a>13.2.1 3主3从redis集群配置</h4><ul><li>新建6个docker容器redis实例</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -d --name redis-node-1 --net <span class="token function">host</span> --privileged<span class="token operator">=</span>true -v /data/redis/share/redis-node-1:/data redis:6.0.8 --cluster-enabled <span class="token function">yes</span> --appendonly <span class="token function">yes</span> --port <span class="token number">6381</span> <span class="token function">docker</span> run -d --name redis-node-2 --net <span class="token function">host</span> --privileged<span class="token operator">=</span>true -v /data/redis/share/redis-node-2:/data redis:6.0.8 --cluster-enabled <span class="token function">yes</span> --appendonly <span class="token function">yes</span> --port <span class="token number">6382</span> <span class="token function">docker</span> run -d --name redis-node-3 --net <span class="token function">host</span> --privileged<span class="token operator">=</span>true -v /data/redis/share/redis-node-3:/data redis:6.0.8 --cluster-enabled <span class="token function">yes</span> --appendonly <span class="token function">yes</span> --port <span class="token number">6383</span> <span class="token function">docker</span> run -d --name redis-node-4 --net <span class="token function">host</span> --privileged<span class="token operator">=</span>true -v /data/redis/share/redis-node-4:/data redis:6.0.8 --cluster-enabled <span class="token function">yes</span> --appendonly <span class="token function">yes</span> --port <span class="token number">6384</span> <span class="token function">docker</span> run -d --name redis-node-5 --net <span class="token function">host</span> --privileged<span class="token operator">=</span>true -v /data/redis/share/redis-node-5:/data redis:6.0.8 --cluster-enabled <span class="token function">yes</span> --appendonly <span class="token function">yes</span> --port <span class="token number">6385</span> <span class="token function">docker</span> run -d --name redis-node-6 --net <span class="token function">host</span> --privileged<span class="token operator">=</span>true -v /data/redis/share/redis-node-6:/data redis:6.0.8 --cluster-enabled <span class="token function">yes</span> --appendonly <span class="token function">yes</span> --port <span class="token number">6386</span></code></pre><p>运行成功，效果如下：</p><img src="/2022/09/19/docker-xue-xi-bi-ji/89.png" class=""><p>命令说明：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run<span class="token comment">#创建并运行docker容器实例</span>--name redis-node-6<span class="token comment">#容器名字</span>--net <span class="token function">host</span><span class="token comment">#使用宿主机的IP和端口，默认</span>--privileged<span class="token operator">=</span>true<span class="token comment">#获取宿主机root用户权限</span>-v /data/redis/share/redis-node-6:/data<span class="token comment">#容器卷，宿主机地址:docker内部地址</span>redis:6.0.8<span class="token comment">#redis镜像和版本号</span>--cluster-enabled <span class="token function">yes</span><span class="token comment">#开启redis集群</span>--appendonly <span class="token function">yes</span><span class="token comment">#开启持久化</span>--port <span class="token number">6386</span><span class="token comment">#redis端口号</span></code></pre><ul><li>进入其中一个容器</li></ul><p><code>docker exec -it redis-node-1 /bin/bash</code></p><ul><li>构建主从关系</li></ul><p><strong>注意自己的真实IP地址</strong></p><pre class="language-bash" data-language="bash"><code class="language-bash">redis-cli --cluster create <span class="token number">192.168</span>.42.53:6381 <span class="token number">192.168</span>.42.53:6382 <span class="token number">192.168</span>.42.53:6383 <span class="token number">192.168</span>.42.53:6384 <span class="token number">192.168</span>.42.53:6385 <span class="token number">192.168</span>.42.53:6386 --cluster-replicas <span class="token number">1</span></code></pre><p>–cluster-replicas 1 表示为每个master创建一个slave节点</p><img src="/2022/09/19/docker-xue-xi-bi-ji/90.png" class=""><img src="/2022/09/19/docker-xue-xi-bi-ji/91.png" class=""><ul><li>链接进入6381作为切点，查看集群、节点状态</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash">redis-cli -p <span class="token number">6381</span>cluster infocluster nodes</code></pre><img src="/2022/09/19/docker-xue-xi-bi-ji/92.png" class=""><h4 id="13-2-2-主从容错切换迁移案例"><a href="#13-2-2-主从容错切换迁移案例" class="headerlink" title="13.2.2 主从容错切换迁移案例"></a>13.2.2 主从容错切换迁移案例</h4><ul><li>防止路由失效加参数-c ，并对6381新增两个key</li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/93.png" class=""><ul><li>查看集群信息</li></ul><p><code> redis-cli  --cluster check 192.168.42.53:6381 </code></p><img src="/2022/09/19/docker-xue-xi-bi-ji/94.png" class=""><ul><li>容错切换迁移</li></ul><p>主6381和从机切换，先停止主机6381；6381主机停了，对应的真实从机上位；6381作为1号主机分配的从机以实际情况为准，具体几号机器就是几号。</p><ul><li>再次查看集群信息</li></ul><p><code>docker stop redis-node-1</code></p><p>6381宕机了，对应从机6385上位成为了新的master</p><img src="/2022/09/19/docker-xue-xi-bi-ji/95.png" class=""><p><strong>再次启动6381后，6381变成6385的从机</strong></p><ul><li>还原之前的3主3从</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#先启动6381，再停6385，再启6385，</span><span class="token comment">#命令执行中间需要等待一会，docker集群重新响应</span><span class="token function">docker</span> start redis-node-1<span class="token function">docker</span> stop redis-node-5<span class="token function">docker</span> start redis-node-5</code></pre><img src="/2022/09/19/docker-xue-xi-bi-ji/96.png" class=""><h4 id="13-2-3-主从扩容案例"><a href="#13-2-3-主从扩容案例" class="headerlink" title="13.2.3 主从扩容案例"></a>13.2.3 主从扩容案例</h4><ul><li>新建6387、6388两个节点 + 新建后启动 + 查看是否8节点</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -d --name redis-node-7 --net <span class="token function">host</span> --privileged<span class="token operator">=</span>true -v /data/redis/share/redis-node-7:/data redis:6.0.8 --cluster-enabled <span class="token function">yes</span> --appendonly <span class="token function">yes</span> --port <span class="token number">6387</span><span class="token function">docker</span> run -d --name redis-node-8 --net <span class="token function">host</span> --privileged<span class="token operator">=</span>true -v /data/redis/share/redis-node-8:/data redis:6.0.8 --cluster-enabled <span class="token function">yes</span> --appendonly <span class="token function">yes</span> --port <span class="token number">6388</span></code></pre><ul><li>进入6387容器实例内部</li></ul><p><code>docker exec -it redis-node-7 /bin/bash</code></p><ul><li>将新增的6387节点(空槽号)作为master节点加入原集群</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash">redis-cli --cluster add-node 自己实际IP地址:6387 自己实际IP地址:6381<span class="token comment">#6387 就是将要作为master新增节点</span><span class="token comment">#6381 就是原来集群节点里面的领路人，相当于6387拜拜6381的码头从而找到组织加入集群</span></code></pre><img src="/2022/09/19/docker-xue-xi-bi-ji/97.jpg" class=""><img src="/2022/09/19/docker-xue-xi-bi-ji/98.jpg" class=""><ul><li>第1次检查集群情况</li></ul><p><code> redis-cli  --cluster check 真实ip地址:6381 </code></p><img src="/2022/09/19/docker-xue-xi-bi-ji/99.jpg" class=""><img src="/2022/09/19/docker-xue-xi-bi-ji/100.jpg" class=""><ul><li>重新分派槽号</li></ul><p><code>redis-cli --cluster reshard IP地址:端口号</code></p><img src="/2022/09/19/docker-xue-xi-bi-ji/101.jpg" class=""><img src="/2022/09/19/docker-xue-xi-bi-ji/102.jpg" class=""><ul><li>第2次检查集群情况</li></ul><p><code> redis-cli  --cluster check 真实ip地址:6381 </code></p><img src="/2022/09/19/docker-xue-xi-bi-ji/103.jpg" class=""><img src="/2022/09/19/docker-xue-xi-bi-ji/104.jpg" class=""><ul><li>槽号分派说明</li></ul><p>为什么6387是3个新的区间，以前的还是连续？</p><p>重新分配成本太高，所以前3家各自匀出来一部分，从6381/6382/6383三个旧节点分别匀出1364个坑位给新节点6387</p><img src="/2022/09/19/docker-xue-xi-bi-ji/105.jpg" class=""><ul><li>为主节点6387分配从节点6388</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#命令：redis-cli --cluster add-node ip:新slave端口 ip:新master端口 --cluster-slave --cluster-master-id 新主机节点ID</span> redis-cli --cluster add-node <span class="token number">192.168</span>.111.147:6388 <span class="token number">192.168</span>.111.147:6387 --cluster-slave --cluster-master-id e4781f644d4a4e4d4b4d107157b9ba8144631451 <span class="token comment">#---这个是6387的编号，按照自己实际情况</span></code></pre><img src="/2022/09/19/docker-xue-xi-bi-ji/106.jpg" class=""><img src="/2022/09/19/docker-xue-xi-bi-ji/107.jpg" class=""><ul><li>第3次检查集群情况</li></ul><p><code>redis-cli --cluster check 192.168.111.147:6382</code></p><img src="/2022/09/19/docker-xue-xi-bi-ji/108.jpg" class=""><img src="/2022/09/19/docker-xue-xi-bi-ji/109.jpg" class=""><h4 id="13-2-4-主从缩容案例"><a href="#13-2-4-主从缩容案例" class="headerlink" title="13.2.4 主从缩容案例"></a>13.2.4 主从缩容案例</h4><ul><li>6387和6388下线；第1次检查集群情况，获得6388的节点ID</li></ul><p><code> redis-cli  --cluster check 192.168.111.147:6382 </code></p><img src="/2022/09/19/docker-xue-xi-bi-ji/110.jpg" class=""><ul><li>将6388删除， 从集群中将4号 从节点6388删除</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash">命令：redis-cli --cluster del-node ip:从机端口 从机6388节点ID redis-cli --cluster del-node <span class="token number">192.168</span>.111.147:6388 5d149074b7e57b802287d1797a874ed7a1a284a8</code></pre><img src="/2022/09/19/docker-xue-xi-bi-ji/111.jpg" class=""><ul><li>检查6388是否被删除，只剩下7台机器</li></ul><p><code> redis-cli  --cluster check 192.168.111.147:6382 </code></p><img src="/2022/09/19/docker-xue-xi-bi-ji/112.jpg" class=""><ul><li>将6387的槽号清空，重新分配。本例将清出来的槽号都给6381</li></ul><p><code>redis-cli --cluster reshard 192.168.111.147:6381</code></p><img src="/2022/09/19/docker-xue-xi-bi-ji/113.jpg" class=""><img src="/2022/09/19/docker-xue-xi-bi-ji/114.jpg" class=""><ul><li>第2次检查集群情况</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash">redis-cli --cluster check <span class="token number">192.168</span>.111.147:6381<span class="token comment">#4096个槽位都指给6381，它变成了8192个槽位，相当于全部都给6381了，不然要输入3次，一锅端</span></code></pre><img src="/2022/09/19/docker-xue-xi-bi-ji/115.jpg" class=""><ul><li>将6387删除</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash">命令：redis-cli --cluster del-node ip:端口 <span class="token number">6387</span>节点ID redis-cli --cluster del-node <span class="token number">192.168</span>.111.147:6387 e4781f644d4a4e4d4b4d107157b9ba8144631451</code></pre><img src="/2022/09/19/docker-xue-xi-bi-ji/116.jpg" class=""><ul><li>第3次检查集群情况</li></ul><p><code> redis-cli  --cluster check 192.168.111.147:6381 </code></p><img src="/2022/09/19/docker-xue-xi-bi-ji/117.jpg" class=""><h2 id="14-DockerFile解析"><a href="#14-DockerFile解析" class="headerlink" title="14. DockerFile解析"></a>14. DockerFile解析</h2><h3 id="14-1-是什么"><a href="#14-1-是什么" class="headerlink" title="14.1 是什么"></a>14.1 是什么</h3><ul><li>Dockerfile是用来构建Docker镜像的文本，是由一条条构建镜像所需的指令和参数构成的脚本。</li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/118.jpg" class=""><ul><li>官网</li></ul><p><a href="https://docs.docker.com/engine/reference/builder/">Dockerfile reference | Docker Documentation</a></p><ul><li>构建三步骤</li></ul><p>（1）编写Dockerfile文件</p><p>（2）docker build 命令构建镜像</p><p>（3）docker run 依镜像运行容器实例</p><h3 id="14-2-Dockerfile构建过程解析"><a href="#14-2-Dockerfile构建过程解析" class="headerlink" title="14.2 Dockerfile构建过程解析"></a>14.2 Dockerfile构建过程解析</h3><ul><li>Dockerfile内容基础知识</li></ul><p>（1）每条保留字指令都必须为大写字母且后面要跟随至少一个参数；</p><p>（2）指令按照从上到下，顺序执行；</p><p>（3）#表示注释；</p><p>（4）每条指令都会创建一个新的镜像层并对镜像进行提交</p><ul><li>Docker执行Dockerfile的大致流程</li></ul><p>（1）docker从基础镜像运行一个容器；</p><p>（2）执行一条指令并对容器作出修改</p><p>（3）执行类似docker commit 的操作提交一个新的镜像层</p><p>（4）docker再基于刚提交的镜像运行一个新容器</p><p>（5）执行Dockerfile中的下一条指令直到所有指令都执行完成</p><h3 id="14-3-Dockerfile常用保留字指令"><a href="#14-3-Dockerfile常用保留字指令" class="headerlink" title="14.3 Dockerfile常用保留字指令"></a>14.3 Dockerfile常用保留字指令</h3><ul><li>参考tomcat8的Dockerfile入门</li></ul><p><a href="https://github.com/docker-library/tomcat">https://github.com/docker-library/tomcat</a></p><ul><li>FROM</li></ul><p>基础镜像，当前新镜像是基于哪个镜像的，指定一个已经存在的镜像作为模板，第一条必须是from</p><ul><li>MAINTAINER</li></ul><p>镜像维护者的姓名和邮箱地址</p><ul><li>RUN</li></ul><p>容器构建时需要运行的命令，RUN是在docker build时运行，RUN有两种格式</p><p>shell格式</p><img src="/2022/09/19/docker-xue-xi-bi-ji/119.jpg" class=""><p><code>RUN yum -y install vim</code></p><p>exec格式</p><img src="/2022/09/19/docker-xue-xi-bi-ji/120.jpg" class=""><ul><li>EXPOSE</li></ul><p>当前容器对外暴露出的端口</p><ul><li>WORKDIR</li></ul><p>指定在创建容器后，终端默认登录进来的工作目录，一个落脚点</p><ul><li>USER</li></ul><p>指定该镜像以什么样的用户去执行，如果都不指定，默认是root</p><ul><li>ENV</li></ul><p>用来构建镜像过程中设置环境变量</p><p>ENV MY_PATH /usr/mytest</p><p>这个环境变量可以在后续的任何RUN指令中使用，这就如同在命令前面指定了环境变量前缀一样；也可以在其它指令中直接使用这些环境变量，</p><p>比如：WORKDIR $MY_PATH</p><ul><li>ADD</li></ul><p>将宿主机目录下的文件拷贝进镜像且会自动处理URL和解压tar压缩包</p><ul><li>COPY</li></ul><p>类似ADD，拷贝文件和目录到镜像中。将从构建上下文目录中&lt;源路径&gt;的文件/目录复制到新的一层的镜像内的&lt;目标路径&gt;位置</p><p>COPY src dest、COPY [“src”, “dest”]；</p><p>&lt;src源路径&gt;：源文件或者源目录</p><p>&lt;dest目标路径&gt;：容器内的指定路径，该路径不用事先建好，路径不存在的话，会自动创建。</p><ul><li>VOLUME</li></ul><p>容器数据卷，用于数据保存和持久化工作</p><ul><li>CMD</li></ul><p>指定容器启动后要干的事情</p><p><strong>注意：</strong>Dockerfile 中可以有多个 CMD 指令，但只有最后一个生效，CMD 会被 docker run 之后的参数替换</p><p>用/bin/bash覆盖原有的CMD，访问tomcat不出现猫首页</p><ul><li>ENTRYPOINT</li></ul><p>类似于 CMD 指令，但是ENTRYPOINT不会被docker run后面的命令覆盖， 而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序</p><p>命令格式：ENTRYPOINT [“<executeable>“, “<param1>“, “<param2>“, …]</param2></param1></executeable></p><p>ENTRYPOINT可以和C MD一起用，一般是变参才会使用 CMD ，这里的 CMD 等于是在给 ENTRYPOINT 传参。</p><p>当指定了ENTRYPOINT后，CMD的含义就发生了变化，不再是直接运行其命令而是将CMD的内容作为参数传递给ENTRYPOINT指令，他两个组合会变成：<entrypoint>“<cmd>“</cmd></entrypoint></p><img src="/2022/09/19/docker-xue-xi-bi-ji/124.jpg" class=""><table><thead><tr><th>是否传参</th><th>按照dockerfile编写执行</th><th>传参运行</th></tr></thead><tbody><tr><td>Docker命令</td><td>docker run   nginx:test</td><td>docker run   nginx:test -c /etc/nginx/<strong>new.conf</strong></td></tr><tr><td>衍生出的实际命令</td><td>nginx -c  /etc/nginx/nginx.conf</td><td>nginx -c  /etc/nginx/<strong>new.conf</strong></td></tr></tbody></table><h3 id="14-4-案例"><a href="#14-4-案例" class="headerlink" title="14.4 案例"></a>14.4 案例</h3><ul><li>自定义镜像ymcentosjava8</li></ul><p>要求：CentOS7 镜像具备vim+ifconfig+jdk8</p><ul><li>准备JDK gz压缩包，编写Dockerfile文件</li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/125.png" class=""><pre class="language-bash" data-language="bash"><code class="language-bash">FROM centos:7MAINTAINER zzyy<span class="token operator">&lt;</span>zzyybs@126.com<span class="token operator">&gt;</span> ENV MYPATH /usr/localWORKDIR <span class="token variable">$MYPATH</span> <span class="token comment">#安装vim编辑器</span>RUN yum -y <span class="token function">install</span> <span class="token function">vim</span><span class="token comment">#安装ifconfig命令查看网络IP</span>RUN yum -y <span class="token function">install</span> net-tools<span class="token comment">#安装java8及lib库</span>RUN yum -y <span class="token function">install</span> glibc.i686RUN <span class="token function">mkdir</span> /usr/local/java<span class="token comment">#ADD 是相对路径jar,把jdk-8u171-linux-x64.tar.gz添加到容器中,安装包必须要和Dockerfile文件在同一位置</span>ADD jdk-8u171-linux-x64.tar.gz /usr/local/java/<span class="token comment">#配置java环境变量</span>ENV JAVA_HOME /usr/local/java/jdk1.8.0_171ENV JRE_HOME <span class="token variable">$JAVA_HOME</span>/jreENV CLASSPATH <span class="token variable">$JAVA_HOME</span>/lib/dt.jar:<span class="token variable">$JAVA_HOME</span>/lib/tools.jar:<span class="token variable">$JRE_HOME</span>/lib:<span class="token variable">$CLASSPATH</span>ENV <span class="token environment constant">PATH</span> <span class="token variable">$JAVA_HOME</span>/bin:<span class="token environment constant">$PATH</span> EXPOSE <span class="token number">80</span> CMD <span class="token builtin class-name">echo</span> <span class="token variable">$MYPATH</span>CMD <span class="token builtin class-name">echo</span> <span class="token string">"success--------------ok"</span>CMD /bin/bash</code></pre><ul><li>构建</li></ul><p><code>docker build -t 新镜像名字:TAG</code></p><p>docker build -t centosjava8:1.5 .</p><img src="/2022/09/19/docker-xue-xi-bi-ji/126.png" class=""><p><strong>注意：</strong>上面TAG后面有个空格，有个点</p><ul><li>运行</li></ul><p><code>docker run -it 新镜像名字:TAG</code></p><p>docker run -it centosjava8:1.5 /bin/bash</p><img src="/2022/09/19/docker-xue-xi-bi-ji/127.png" class=""><h3 id="14-5-虚悬镜像"><a href="#14-5-虚悬镜像" class="headerlink" title="14.5 虚悬镜像"></a>14.5 虚悬镜像</h3><p>虚悬镜像：仓库名、标签都是<none>的镜像，俗称dangling image</none></p><ul><li>Dockerfile编写一个虚悬镜像</li></ul><ol><li>vim Dockerfile</li></ol><pre class="language-none"><code class="language-none">from ubuntuCMD echo 'action is success'</code></pre><ol start="2"><li>docker build</li></ol><ul><li>查看</li></ul><p><code>docker image ls -f dangling=true</code></p><ul><li>删除</li></ul><p><code>docker image prune</code></p><p>虚悬镜像已经失去存在价值，可以删除</p><h2 id="15-Docker微服务实战"><a href="#15-Docker微服务实战" class="headerlink" title="15. Docker微服务实战"></a>15. Docker微服务实战</h2><h3 id="15-1-通过IDEA新建一个普通微服务模块"><a href="#15-1-通过IDEA新建一个普通微服务模块" class="headerlink" title="15.1 通过IDEA新建一个普通微服务模块"></a>15.1 通过IDEA新建一个普通微服务模块</h3><ul><li>建Module<ul><li>docker-boot</li></ul></li><li>改POM</li></ul><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>cloud2020<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.woniu<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.0-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modelVersion</span><span class="token punctuation">&gt;</span></span>4.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modelVersion</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>docker-boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project.build.sourceEncoding</span><span class="token punctuation">&gt;</span></span>UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project.build.sourceEncoding</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>maven.compiler.source</span><span class="token punctuation">&gt;</span></span>1.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>maven.compiler.source</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>maven.compiler.target</span><span class="token punctuation">&gt;</span></span>1.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>maven.compiler.target</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!--SpringBoot通用依赖模块--&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-actuator<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!--test--&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">&gt;</span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">&gt;</span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-maven-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>executions</span><span class="token punctuation">&gt;</span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>execution</span><span class="token punctuation">&gt;</span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>goals</span><span class="token punctuation">&gt;</span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>goal</span><span class="token punctuation">&gt;</span></span>repackage<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>goal</span><span class="token punctuation">&gt;</span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>goal</span><span class="token punctuation">&gt;</span></span>build-info<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>goal</span><span class="token punctuation">&gt;</span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>goals</span><span class="token punctuation">&gt;</span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>execution</span><span class="token punctuation">&gt;</span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>executions</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">&gt;</span></span></code></pre><ul><li>写YML</li></ul><pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">server</span><span class="token punctuation">:</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">6001</span></code></pre><ul><li>主启动</li></ul><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>woniu</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span></span><span class="token class-name">SpringApplication</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span></span><span class="token class-name">SpringBootApplication</span></span><span class="token punctuation">;</span><span class="token annotation punctuation">@SpringBootApplication</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DockerBootApplication</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">DockerBootApplication</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>业务类</li></ul><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>woniu<span class="token punctuation">.</span>controller</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Value</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">RequestMapping</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">RequestMethod</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">RestController</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">UUID</span></span><span class="token punctuation">;</span><span class="token annotation punctuation">@RestController</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OrderController</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${server.port}"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> port<span class="token punctuation">;</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/order/docker"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">helloDocker</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"hello docker"</span> <span class="token operator">+</span> <span class="token string">"\t"</span> <span class="token operator">+</span> port <span class="token operator">+</span> <span class="token string">"\t"</span> <span class="token operator">+</span> UUID<span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/order/index"</span><span class="token punctuation">,</span> method <span class="token operator">=</span> <span class="token class-name">RequestMethod</span><span class="token punctuation">.</span>GET<span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">index</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"服务端口号: "</span> <span class="token operator">+</span> <span class="token string">"\t"</span> <span class="token operator">+</span> port <span class="token operator">+</span> <span class="token string">"\t"</span> <span class="token operator">+</span> UUID<span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="15-2-通过Dockerfile发布微服务部署"><a href="#15-2-通过Dockerfile发布微服务部署" class="headerlink" title="15.2 通过Dockerfile发布微服务部署"></a>15.2 通过Dockerfile发布微服务部署</h3><ul><li>IDEA工具里面搞定微服务jar包</li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/128.png" class=""><ul><li>编写Dockerfile</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 基础镜像使用java</span>FROM java:8<span class="token comment"># 作者</span>MAINTAINER woniu<span class="token comment"># VOLUME 指定临时文件目录为/tmp，在主机/var/lib/docker目录下创建了一个临时文件并链接到容器的/tmp</span>VOLUME /tmp<span class="token comment"># 将jar包添加到容器中并更名为zzyy_docker.jar</span>ADD docker-boot-1.0-SNAPSHOT.jar zzyy_docker.jar<span class="token comment"># 运行jar包</span>RUN <span class="token function">bash</span> -c <span class="token string">'touch /zzyy_docker.jar'</span>ENTRYPOINT <span class="token punctuation">[</span><span class="token string">"java"</span>,<span class="token string">"-jar"</span>,<span class="token string">"/zzyy_docker.jar"</span><span class="token punctuation">]</span><span class="token comment">#暴露6001端口作为微服务</span>EXPOSE <span class="token number">6001</span></code></pre><img src="/2022/09/19/docker-xue-xi-bi-ji/129.png" class=""><ul><li>构建镜像</li></ul><p><code>docker build -t zzyy_docker:1.6 .</code></p><img src="/2022/09/19/docker-xue-xi-bi-ji/130.png" class=""><ul><li>运行容器</li></ul><p><code>docker run -d -p 6001:6001 zzyy_docker:1.6</code></p><img src="/2022/09/19/docker-xue-xi-bi-ji/131.png" class=""><ul><li>访问测试</li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/132.png" class=""><h2 id="16-Docker网络"><a href="#16-Docker网络" class="headerlink" title="16. Docker网络"></a>16. Docker网络</h2><ul><li>docker启动后，会产生一个名为docker0的虚拟网桥</li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/133.jpg" class=""><ul><li>查看docker网络模式命令，默认创建3大网络模式</li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/134.jpg" class=""><ul><li>常用基本命令</li></ul><pre class="language-none"><code class="language-none">查看网络：docker network ls查看网络源数据：docker network inspect xxx网络名字删除网络：docker network rm xxx网络名字</code></pre><img src="/2022/09/19/docker-xue-xi-bi-ji/135.jpg" class=""><h3 id="16-1-网络模式"><a href="#16-1-网络模式" class="headerlink" title="16.1 网络模式"></a>16.1 网络模式</h3><ul><li>总体介绍</li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/136.jpg" class=""><pre class="language-none"><code class="language-none">bridge模式：使用--network  bridge指定，默认使用docker0host模式：使用--network host指定none模式：使用--network none指定container模式：使用--network container:NAME或者容器ID指定</code></pre><p>docker 容器内部的ip是有可能会发生改变的</p><h4 id="16-1-1-bridge"><a href="#16-1-1-bridge" class="headerlink" title="16.1.1 bridge"></a>16.1.1 bridge</h4><p>Docker 服务默认会创建一个 docker0 网桥（其上有一个 docker0 内部接口），该桥接网络的名称为docker0，它在内核层连通了其他的物理或虚拟网卡，这就将所有容器和本地主机都放到同一个物理网络。Docker 默认指定了 docker0 接口 的 IP 地址和子网掩码，让主机和容器之间可以通过网桥相互通信。</p><ol><li><p>Docker使用Linux桥接，在宿主机虚拟一个Docker容器网桥(docker0)，Docker启动一个容器时会根据Docker网桥的网段分配给容器一个IP地址，称为Container-IP，同时Docker网桥是每个容器的默认网关。因为在同一宿主机内的容器都接入同一个网桥，这样容器之间就能够通过容器的Container-IP直接通信。</p></li><li><p>docker run 的时候，没有指定network的话默认使用的网桥模式就是bridge，使用的就是docker0。在宿主机ifconfig,就可以看到docker0和自己create的network(后面讲)eth0，eth1，eth2……代表网卡一，网卡二，网卡三……，lo代表127.0.0.1，即localhost，inet addr用来表示网卡的IP地址</p></li><li><p>网桥docker0创建一对对等虚拟设备接口一个叫veth，另一个叫eth0，成对匹配。</p></li></ol><p>  3.1 整个宿主机的网桥模式都是docker0，类似一个交换机有一堆接口，每个接口叫veth，在本地主机和容器内分别创建一个虚拟接口，并让他们彼此联通（这样一对接口叫veth pair）；</p><p>  3.2 每个容器实例内部也有一块网卡，每个接口叫eth0；</p><p>  3.3 docker0上面的每个veth匹配某个容器实例内部的eth0，两两配对，一一匹配。</p><p> 通过上述，将宿主机上的所有容器都连接到这个内部网络上，两个容器在同一个网络下,会从这个网关下各自拿到分配的ip，此时两个容器的网络是互通的。</p><img src="/2022/09/19/docker-xue-xi-bi-ji/137.jpg" class=""><ul><li>两两匹配验证</li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/138.jpg" class=""><h4 id="16-1-2-host"><a href="#16-1-2-host" class="headerlink" title="16.1.2 host"></a>16.1.2 host</h4><p>直接使用宿主机的 IP 地址与外界进行通信，不再需要额外进行NAT 转换。</p><p>容器将不会获得一个独立的Network Namespace， 而是和宿主机共用一个Network Namespace。容器将不会虚拟出自己的网卡而是使用宿主机的IP和端口。</p><img src="/2022/09/19/docker-xue-xi-bi-ji/139.jpg" class=""><p><code>docker run -d -p 8083:8080 --network host --name tomcat83 billygoo/tomcat8-jdk8</code></p><img src="/2022/09/19/docker-xue-xi-bi-ji/140.jpg" class=""><ul><li><p>问题：</p><p> docke启动时总是遇见标题中的警告</p></li><li><p>原因：</p><p>docker启动时指定–network=host或-net=host，如果还指定了-p映射端口，那这个时候就会有此警告，</p></li></ul><p>并且通过-p设置的参数将不会起到任何作用，端口号会以主机端口号为主，重复时则递增。</p><ul><li><p>解决:</p><p>解决的办法就是使用docker的其他网络模式，例如–network=bridge，这样就可以解决问题，或者直接无视</p></li></ul><p><code>docker run -d --network host --name tomcat83 billygoo/tomcat8-jdk8</code></p><img src="/2022/09/19/docker-xue-xi-bi-ji/141.jpg" class=""><ul><li>没有设置-p的端口映射了，如何访问启动的tomcat83？</li></ul><p><code>http://宿主机IP:8080/</code></p><p>在CentOS里面用默认的火狐浏览器访问容器内的tomcat83看到访问成功，因为此时容器的IP借用主机的，</p><p>所以容器共享宿主机网络IP，这样的好处是外部主机与容器可以直接通信。</p><h4 id="16-1-3-none"><a href="#16-1-3-none" class="headerlink" title="16.1.3 none"></a>16.1.3 none</h4><p>在none模式下，并不为Docker容器进行任何网络配置。 也就是说，这个Docker容器没有网卡、IP、路由等信息，只有一个lo，需要我们自己为Docker容器添加网卡、配置IP等。</p><p><code>docker run -d -p 8084:8080 --network none --name tomcat84 billygoo/tomcat8-jdk8</code></p><ul><li>进入容器内部查看</li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/142.jpg" class=""><ul><li>在容器外部查看</li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/143.jpg" class=""><h4 id="16-1-4-container"><a href="#16-1-4-container" class="headerlink" title="16.1.4 container"></a>16.1.4 container</h4><p>container⽹络模式 </p><p>新建的容器和已经存在的一个容器共享一个网络ip配置而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。</p><img src="/2022/09/19/docker-xue-xi-bi-ji/144.jpg" class=""><h4 id="16-1-5-自定义网络"><a href="#16-1-5-自定义网络" class="headerlink" title="16.1.5 自定义网络"></a>16.1.5 自定义网络</h4><ul><li>新建自定义网络</li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/145.jpg" class=""><ul><li>新建容器加入上一步新建的自定义网络</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -d -p <span class="token number">8081</span>:8080 --network zzyy_network  --name tomcat81 billygoo/tomcat8-jdk8<span class="token function">docker</span> run -d -p <span class="token number">8082</span>:8080 --network zzyy_network  --name tomcat82 billygoo/tomcat8-jdk8</code></pre><ul><li>相互ping测试</li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/146.jpg" class=""><img src="/2022/09/19/docker-xue-xi-bi-ji/147.jpg" class=""><ul><li>问题结论</li></ul><p>自定义网络本身就维护好了主机名和ip的对应关系（ip和域名都能通）</p><h2 id="17-Docker-conpose-容器编排"><a href="#17-Docker-conpose-容器编排" class="headerlink" title="17. Docker-conpose 容器编排"></a>17. Docker-conpose 容器编排</h2><h3 id="17-1-是什么"><a href="#17-1-是什么" class="headerlink" title="17.1 是什么"></a>17.1 是什么</h3><p>Compose 是 Docker 公司推出的一个工具软件，可以管理多个 Docker 容器组成一个应用。你需要定义一个 YAML 格式的配置文件docker-compose.yml，写好多个容器之间的调用关系。然后，只要一个命令，就能同时启动/关闭这些容器</p><ul><li>Docker-Compose是Docker官方的开源项目， 负责实现对Docker容器集群的快速编排</li></ul><h3 id="17-2-能干什么"><a href="#17-2-能干什么" class="headerlink" title="17.2 能干什么"></a>17.2 能干什么</h3><p>docker建议我们每一个容器中只运行一个服务,因为docker容器本身占用资源极少,所以最好是将每个服务单独的分割开来但是这样我们又面临了一个问题？</p><p>如果我需要同时部署好多个服务,难道要每个服务单独写Dockerfile然后在构建镜像,构建容器,这样累都累死了,所以docker官方给我们提供了docker-compose多服务部署的工具</p><p>例如要实现一个Web微服务项目，除了Web服务容器本身，往往还需要再加上后端的数据库mysql服务容器，redis服务器，注册中心eureka，甚至还包括负载均衡容器等等。。。。。。</p><p>Compose允许用户通过一个单独的docker-compose.yml模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。</p><p>可以很容易地用一个配置文件定义一个多容器的应用，然后使用一条指令安装这个应用的所有依赖，完成构建。Docker-Compose 解决了容器与容器之间如何管理编排的问题。</p><h3 id="17-3-下载"><a href="#17-3-下载" class="headerlink" title="17.3 下载"></a>17.3 下载</h3><p><code>https://docs.docker.com/compose/compose-file/compose-file-v3/</code></p><p><code>https://docs.docker.com/compose/install/</code></p><ul><li>安装步骤</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">curl</span> -L <span class="token string">"https://github.com/docker/compose/releases/download/1.29.2/docker-compose-<span class="token variable"><span class="token variable">$(</span><span class="token function">uname</span> -s<span class="token variable">)</span></span>-<span class="token variable"><span class="token variable">$(</span><span class="token function">uname</span> -m<span class="token variable">)</span></span>"</span> -o /usr/local/bin/docker-compose<span class="token function">chmod</span> +x /usr/local/bin/docker-compose<span class="token function">docker-compose</span> --version</code></pre><img src="/2022/09/19/docker-xue-xi-bi-ji/148.jpg" class=""><ul><li>卸载</li></ul><img src="/2022/09/19/docker-xue-xi-bi-ji/149.jpg" class=""><h3 id="17-4-Compose-核心概念"><a href="#17-4-Compose-核心概念" class="headerlink" title="17.4 Compose 核心概念"></a>17.4 Compose 核心概念</h3><ul><li>一文件</li></ul><p>docker-compose.yml</p><ul><li>两要素</li></ul><p>服务：一个个应用容器实例，比如订单微服务、库存微服务、mysql容器、nginx容器或者redis容器</p><p>工程：由一组关联的应用容器组成的一个完整业务单元，在 docker-compose.yml 文件中定义</p><h3 id="17-5-Compose-使用三步骤"><a href="#17-5-Compose-使用三步骤" class="headerlink" title="17.5 Compose 使用三步骤"></a>17.5 Compose 使用三步骤</h3><ol><li>编写Dockerfile定义各个微服务应用并构建出对应的镜像文件</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 基础镜像使用java</span>FROM java:8<span class="token comment"># 作者</span>MAINTAINER zzyy<span class="token comment"># VOLUME 指定临时文件目录为/tmp，在主机/var/lib/docker目录下创建了一个临时文件并链接到容器的/tmp</span>VOLUME /tmp<span class="token comment"># 将jar包添加到容器中并更名为zzyy_docker.jar</span>ADD docker_boot-0.0.1-SNAPSHOT.jar zzyy_docker.jar<span class="token comment"># 运行jar包</span>RUN <span class="token function">bash</span> -c <span class="token string">'touch /zzyy_docker.jar'</span>ENTRYPOINT <span class="token punctuation">[</span><span class="token string">"java"</span>,<span class="token string">"-jar"</span>,<span class="token string">"/zzyy_docker.jar"</span><span class="token punctuation">]</span><span class="token comment">#暴露6001端口作为微服务</span>EXPOSE <span class="token number">6001</span></code></pre><p>构建进行：<code>docker build -t zzyy_docker:1.6 .</code></p><ol start="2"><li>使用 docker-compose.yml 定义一个完整业务单元，安排好整体应用中的各个容器服务。</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash">version: <span class="token string">"3"</span> services:  microService:    image: zzyy_docker:1.6    container_name: ms01    ports:      - <span class="token string">"6001:6001"</span>    volumes:      - /app/microService:/data    networks:       - atguigu_net     depends_on:       - redis      - mysql   redis:    image: redis:6.0.8    ports:      - <span class="token string">"6379:6379"</span>    volumes:      - /app/redis/redis.conf:/etc/redis/redis.conf      - /app/redis/data:/data    networks:       - atguigu_net    command: redis-server /etc/redis/redis.conf   mysql:    image: mysql:5.7    environment:      MYSQL_ROOT_PASSWORD: <span class="token string">'123456'</span>      MYSQL_ALLOW_EMPTY_PASSWORD: <span class="token string">'no'</span>      MYSQL_DATABASE: <span class="token string">'db2021'</span>      MYSQL_USER: <span class="token string">'zzyy'</span>      MYSQL_PASSWORD: <span class="token string">'zzyy123'</span>    ports:       - <span class="token string">"3306:3306"</span>    volumes:       - /app/mysql/db:/var/lib/mysql       - /app/mysql/conf/my.cnf:/etc/my.cnf       - /app/mysql/init:/docker-entrypoint-initdb.d    networks:      - atguigu_net    command: --default-authentication-plugin<span class="token operator">=</span>mysql_native_password <span class="token comment">#解决外部无法访问</span> networks:    atguigu_net: </code></pre><ol start="3"><li>最后，执行docker-compose up命令 来启动并运行整个应用程序，完成一键部署上线</li></ol><img src="/2022/09/19/docker-xue-xi-bi-ji/150.jpg" class=""><img src="/2022/09/19/docker-xue-xi-bi-ji/151.jpg" class=""><h3 id="17-6-Compose-常用命令"><a href="#17-6-Compose-常用命令" class="headerlink" title="17.6 Compose 常用命令"></a>17.6 Compose 常用命令</h3><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker-compose</span> -h                           <span class="token comment"># 查看帮助</span><span class="token function">docker-compose</span> up                           <span class="token comment"># 启动所有docker-compose服务</span><span class="token function">docker-compose</span> up -d                        <span class="token comment"># 启动所有docker-compose服务并后台运行</span><span class="token function">docker-compose</span> down                         <span class="token comment"># 停止并删除容器、网络、卷、镜像。</span><span class="token function">docker-compose</span> <span class="token builtin class-name">exec</span>  yml里面的服务id                 <span class="token comment"># 进入容器实例内部  docker-compose exec docker-compose.yml文件中写的服务id /bin/bash</span><span class="token function">docker-compose</span> <span class="token function">ps</span>                      <span class="token comment"># 展示当前docker-compose编排过的运行的所有容器</span><span class="token function">docker-compose</span> <span class="token function">top</span>                     <span class="token comment"># 展示当前docker-compose编排过的容器进程</span> <span class="token function">docker-compose</span> logs  yml里面的服务id     <span class="token comment"># 查看容器输出日志</span><span class="token function">docker-compose</span> config     <span class="token comment"># 检查配置</span><span class="token function">docker-compose</span> config -q  <span class="token comment"># 检查配置，有问题才有输出</span><span class="token function">docker-compose</span> restart   <span class="token comment"># 重启服务</span><span class="token function">docker-compose</span> start     <span class="token comment"># 启动服务</span><span class="token function">docker-compose</span> stop      <span class="token comment"># 停止服务</span></code></pre><h2 id="18-Docker轻量级可视化工具Portainer"><a href="#18-Docker轻量级可视化工具Portainer" class="headerlink" title="18. Docker轻量级可视化工具Portainer"></a>18. Docker轻量级可视化工具Portainer</h2><p><code>https://www.portainer.io/</code></p><p><code>https://docs.portainer.io/v/ce-2.9/start/install/server/docker/linux</code></p><h2 id="19-Docekr容器监控之-CAdvisor-InfluxDB-Granfana"><a href="#19-Docekr容器监控之-CAdvisor-InfluxDB-Granfana" class="headerlink" title="19. Docekr容器监控之 CAdvisor+InfluxDB+Granfana"></a>19. Docekr容器监控之 CAdvisor+InfluxDB+Granfana</h2>]]></content>
      
      
      <categories>
          
          <category> 容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux笔记</title>
      <link href="/2022/09/09/linux-bi-ji/"/>
      <url>/2022/09/09/linux-bi-ji/</url>
      
        <content type="html"><![CDATA[<div class="note success no-icon"><p>Linux入门</p></div><h2 id="1-Linux目录结构"><a href="#1-Linux目录结构" class="headerlink" title="1. Linux目录结构"></a>1. Linux目录结构</h2><ol><li><p>linux的文件系统是采用级层式的树状目录结构，在此结构中的最上层是根目录“/”，然后在此目录下再创建其他的目录。</p></li><li><p><strong>在Linux世界里，一切皆文件</strong></p></li></ol><img src="/2022/09/09/linux-bi-ji/01.png" class=""><ul><li><p><strong>/bin</strong>：<br>bin 是 Binaries (二进制文件) 的缩写, 这个目录存放着最经常使用的命令。</p></li><li><p><strong>/sbin</strong>：<br>s 就是 Super User 的意思，是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的系统管理程序。</p></li><li><p><strong>/root</strong>：<br>该目录为系统管理员，也称作超级权限者的用户主目录。</p></li><li><p><strong>/lib</strong>：<br>lib 是 Library(库) 的缩写这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。</p></li><li><p><strong>/lost+found</strong>：<br>这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</p></li><li><p><strong>/etc：</strong><br>etc 是 Etcetera(等等) 的缩写,这个目录用来存放所有的系统管理所需要的配置文件和子目录。</p></li><li><p><strong>/usr</strong>：<br> usr 是 unix shared resources(共享资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。</p></li><li><p><strong>/boot：</strong><br>这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。</p></li></ul><ul><li><p><strong>/proc</strong>：<br>proc 是 Processes(进程) 的缩写，/proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。<br>这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器：</p><pre class="language-none"><code class="language-none">echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all</code></pre></li></ul><ul><li><p><strong>/srv</strong>：<br> 该目录存放一些服务启动之后需要提取的数据。</p></li><li><p><strong>/sys</strong>：</p><p>这是 Linux2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs 。</p><p>sysfs 文件系统集成了下面3种文件系统的信息：针对进程信息的 proc 文件系统、针对设备的 devfs 文件系统以及针对伪终端的 devpts 文件系统。</p><p>该文件系统是内核设备树的一个直观反映。</p><p>当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。</p></li><li><p><strong>/tmp</strong>：<br>tmp 是 temporary(临时) 的缩写这个目录是用来存放一些临时文件的。</p></li><li><p><strong>/dev ：</strong><br>dev 是 Device(设备) 的缩写, 该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。</p></li><li><p><strong>/media</strong>：<br>linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。</p></li><li><p><strong>/mnt</strong>：<br>系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 /mnt/ 上，然后进入该目录就可以查看光驱里的内容了。</p></li><li><p><strong>/opt</strong>：<br>opt 是 optional(可选) 的缩写，这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。</p></li><li><p><strong>/var</strong>：<br>var 是 variable(变量) 的缩写，这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</p></li></ul><h2 id="2-vi和vim的基本介绍"><a href="#2-vi和vim的基本介绍" class="headerlink" title="2. vi和vim的基本介绍"></a>2. vi和vim的基本介绍</h2><ul><li><p>Linux系统会内置vi文本编辑器</p></li><li><p>vim具有程序编辑的能力，可以看做是vi的增强版本，可以主动的以字体颜色辨别语法的正确性，方便程序设计。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。</p></li></ul><h3 id="2-1-vi和vim常用的三种模式"><a href="#2-1-vi和vim常用的三种模式" class="headerlink" title="2.1 vi和vim常用的三种模式"></a>2.1 vi和vim常用的三种模式</h3><h4 id="2-1-1-正常模式"><a href="#2-1-1-正常模式" class="headerlink" title="2.1.1 正常模式"></a>2.1.1 正常模式</h4><p>​以<code>vim</code> 打开一个档案就直接进入一般模式了(<strong>这是默认的模式</strong>)。在这个模式中，你可以使用『上下左右』按键来移动光标，你可以使用『删除字符』或『删除整行』来处理档案内容，也可以使用『复制、粘贴』来处理你的文件数据。</p><h4 id="2-1-2-插入模式"><a href="#2-1-2-插入模式" class="headerlink" title="2.1.2 插入模式"></a>2.1.2 插入模式</h4><p>​按下<code>i，I，o，O，a，A，r，R</code>等任何一个字母之后才会进入编辑模式，一般来说按<code>i</code>即可.</p><h4 id="2-1-3-命令行模式"><a href="#2-1-3-命令行模式" class="headerlink" title="2.1.3 命令行模式"></a>2.1.3 命令行模式</h4><p>​按下<code>esc</code>键 再输入<code>:</code>，在这个模式当中，可以提供你相关指令，完成读取、存盘、替换、离开<code>vim</code> 、显示行号等的动作则是在此模式中达成的！</p><h3 id="2-2-各种模式的相互切换"><a href="#2-2-各种模式的相互切换" class="headerlink" title="2.2 各种模式的相互切换"></a>2.2 各种模式的相互切换</h3><img src="/2022/09/09/linux-bi-ji/02.png" class=""><h3 id="2-3-vi和vim快捷键"><a href="#2-3-vi和vim快捷键" class="headerlink" title="2.3 vi和vim快捷键"></a>2.3 vi和vim快捷键</h3><ol><li><p>拷贝当前行yy ，拷贝当前行向下的5行5yy，并粘贴（输入p)。</p></li><li><p>删除当前行dd,删除当前行向下的5行5dd</p></li><li><p>在文件中查找某个单词【 <strong>命令行下</strong>/关键字，回车查找，输入 n就是查找下一个】</p></li><li><p>设置文件的行号，取消文件的行号 [ <strong>命令行下</strong>: set nu和:set nonu ]</p></li><li><p>编辑/etc/profile 文件，<strong>在一般模式下</strong>，使用快捷键到该文档的最末行[G]和最首行[gg]</p></li><li><p>在一个文件中输入”hello” ,<strong>在一般模式下</strong>，然后又撤销这个动作u</p></li><li><p>编辑/etc/profile文件，把光标快速定位到20行，<strong>在一般模式下</strong>，输入20，再输入shift+g</p></li></ol><img src="/2022/09/09/linux-bi-ji/03.png" class=""><p>更多常用快捷键：<a href="http://www.baidu.com/">www.baidu.com</a></p><h2 id="3-关机和重启命令"><a href="#3-关机和重启命令" class="headerlink" title="3. 关机和重启命令"></a>3. 关机和重启命令</h2><ul><li><p>基本介绍</p><p>shutdown -h now立刻进行关机</p><p>shutdown -h  11分钟后会关机</p><p>shutdown -r now现在重新启动计算机</p><p>halt关机，作用和上面一样</p><p>reboot现在重新启动计算机</p><p>sync把内存的数据同步到磁盘</p></li><li><p>注意细节</p></li></ul><ol><li>不管是重启系统还是关闭系统，首先要运行sync命令，把内存中的数据写到磁盘中</li><li>目前的 shutdown/reboot/halt 等命令均已经在关机前进行了sync。</li></ol><h2 id="4-用户登录和注销"><a href="#4-用户登录和注销" class="headerlink" title="4. 用户登录和注销"></a>4. 用户登录和注销</h2><ul><li>基本介绍</li></ul><ol><li>登录时尽量少用root账号登录，因为它是管理员，最大的权限，避免操作失误。可以利用普通用户登录，登录后再用“su - 用户名” 命令来切换成系统管理员身份；</li><li>在提示符下输入logout即可注销用户</li></ol><ul><li>使用细节</li></ul><ol><li>logout注销指令在图形运行级别无效，在运行级别3下有效</li></ol><h2 id="5-用户管理"><a href="#5-用户管理" class="headerlink" title="5. 用户管理"></a>5. 用户管理</h2><h3 id="5-1-添加用户"><a href="#5-1-添加用户" class="headerlink" title="5.1 添加用户"></a>5.1 添加用户</h3><p>语法：useradd    用户名</p><p>细节：</p><ol><li>当创建用户成功后，会自动的创建和用户同名的家目录 /home/xxx</li><li>也可以通过useradd -d 指定目录 新的用户名，给新创建的用户指定家目录（useradd -d home/myfile woniu）</li></ol><h3 id="5-2-修改密码"><a href="#5-2-修改密码" class="headerlink" title="5.2 修改密码"></a>5.2 修改密码</h3><p>语法：password    用户名</p><h3 id="5-3-删除用户"><a href="#5-3-删除用户" class="headerlink" title="5.3 删除用户"></a>5.3 删除用户</h3><p>语法： userdel用户名（保留家目录）    userdel -r 用户名（家目录一并删除）</p><h3 id="5-4-查询用户信息"><a href="#5-4-查询用户信息" class="headerlink" title="5.4 查询用户信息"></a>5.4 查询用户信息</h3><p>语法：id  用户名</p><h3 id="5-5-切换用户"><a href="#5-5-切换用户" class="headerlink" title="5.5 切换用户"></a>5.5 切换用户</h3><p>语法：su  - 用户名</p><p>细节说明：</p><ol><li>从权限高的用户切换到权限低的用户，不需要输入密码，反之需要</li><li>当需要返回到原来用户时，使用exit/logout指令</li></ol><h3 id="5-6-用户组"><a href="#5-6-用户组" class="headerlink" title="5.6 用户组"></a>5.6 用户组</h3><p>介绍：类似于角色，系统可以对有共同权限的多个用户进行统一管理</p><p>新增组：groupadd  组名</p><p>删除组：groupdel  组名</p><p>增加用户时直接加上组：useradd -g 用户组 用户名</p><p>修改用户组：usermod -g 用户组 用户名</p><h2 id="6-运行级别"><a href="#6-运行级别" class="headerlink" title="6. 运行级别"></a>6. 运行级别</h2><ul><li>基本介绍：</li></ul><p>0：关机</p><p>1： 单用户【找回丢失密码】</p><p>2：多用户状态没有网络服务</p><p>3：多用户状态有网络服务</p><p>4：系统未使用保留给用户</p><p>5：图形界面</p><p>6：系统重启</p><p>常用运行级别是3和5，也可以指定默认运行级别（切换运行级别：init 3）</p><h2 id="7-文件目录"><a href="#7-文件目录" class="headerlink" title="7. 文件目录"></a>7. 文件目录</h2><ul><li><p>pwd 指令：显示当前工作目录的绝对路径</p></li><li><p>cd 指令：切换到指定目录（cd ..回到当前目录的上一级目录，cd ~或cd 回到当前用户的家目录）</p></li><li><p>mkdir 指令：创建目录（一级目录：mkdir /home/woniu   多级目录：mkdir <strong>-p</strong> /home/woniu/file）</p></li><li><p>rmdir 指令：删除空目录（rm <strong>-rf</strong> /home/ 强制删除）</p></li><li><p>cp指令：拷贝文件到指定目录</p><ul><li>语法：cp [选项] source dest；</li><li>常用选项 -r：递归复制整个文件夹；</li><li>强制覆盖不提示的方法： \cp -r /home/woniu</li></ul></li><li><p>rm指令：移除文件或目录</p><ul><li>语法：rm [选项] 要删除的文件或目录</li><li>常用选项： -r 递归删除整个文件夹  -f 强制删除不提示</li></ul></li><li><p>mv指令：移动文件或目录或重命名</p><ul><li>语法：mv oldFile newFile(重命名)、mv file /home/xxx</li></ul></li><li><p>cat指令：查看文件内容</p><ul><li>语法：cat [选项] 要查看的文件    选项： -n显示行号</li></ul></li><li><p>more指令：基于VI编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件的内容</p><ul><li>语法：more 要查看的文件</li><li>操作：空格（下翻一页）、Enter（下翻一行）、 q（离开more）、Ctrl+F（下滚一屏）、Ctrl + B（返回上一层）、=（输出当前行的行号）、:f输出文件名和当前行的</li></ul></li><li><p>less指令：用来分屏查看文件内容，它的功能与more指令类似，但是比more指令更强大，支持各种终端；less指令显示内容时。一个将整个文件加载之后显示，而是根据，对于显示大型具有较高的销较高文件具体较高的效率。</p><ul><li>语法：空白键（向反动解冻下）、pagedown（向下翻动一页）pageup（向上翻动一页）、/字串（向下搜寻[字典]，n:向下 N（向下））、？字串（向上搜寻）、q（离开less）</li></ul></li><li><p>echo指令：输出内容到控制台显示</p><ul><li>echo “hello”</li></ul></li><li><p>head指令：head用于显示文件的开头部分内容，默认情况下head指令显示文件的前10行内容</p><ul><li>语法：head -n 5 文件（查看文件前5行内容）</li></ul></li><li><p>tail指令：用于输出文件中尾部的内容，默认情况下tail指令显示的文件的前10行</p><ul><li>语法：tail 文件、 tail -n 5 文件、tail -f 实时追踪该文档的所有内容</li></ul></li></ul><h2 id="8-搜索查找"><a href="#8-搜索查找" class="headerlink" title="8. 搜索查找"></a>8. 搜索查找</h2><ul><li><p>find指令：从指定目录向下递归地遍历其各个子目录，将满足条件的文件或者目录显示在终端</p><ul><li>语法：find [搜索范围] [选项]   </li><li>选项：<ul><li>-name&lt;查询方式&gt; 按照指定的文件名查询模式查找文件</li><li>-user&lt;用户名&gt;查找属于用户名所有文件</li><li>-size&lt;文件大小&gt;按照指定的文件大小查找文件（+n大于、-n小于、n等于，+200M大于200M）</li></ul></li></ul></li><li><p>locate指令：可以快速定位文件路径</p><p><strong>注意：</strong>由于locate指令基于数据库进行查询，所有第一次运行前，必须使用updatedb指令创建locate数据库</p></li><li><p>which指令：可以查看某个指令在哪个目录下</p></li></ul><h2 id="9-压缩和解压"><a href="#9-压缩和解压" class="headerlink" title="9. 压缩和解压"></a>9. 压缩和解压</h2><ul><li><p>gzip/gunzip指令：gzip用于压缩文件/文件夹，gunzip用于解压</p><ul><li>语法：<ul><li>gzip  文件（只能将文件压缩为*.gz文件）</li><li>gunzip  文件.gz （添加-d&lt;目录&gt; 指定解压后文件的存放路径）</li></ul></li></ul></li><li><p>tar指令：</p><ul><li>选项：<ul><li>-c 产生.tar打包文件</li><li>-v 显示详细信息</li><li>-f 指定压缩后的文件名</li><li>-z 打包同时压缩</li><li>-x 解包.tar文件</li></ul></li><li>打包文件常用tar -zcvf xxx.tar.gz 打包的内容</li><li>解包文件常用tar -xcvf  xxx.tar.gz -C 解压到指定的目录</li></ul></li></ul><h2 id="10-权限的基本介绍"><a href="#10-权限的基本介绍" class="headerlink" title="10. 权限的基本介绍"></a>10. 权限的基本介绍</h2><h3 id="10-1-rwx权限详解"><a href="#10-1-rwx权限详解" class="headerlink" title="10.1 rwx权限详解"></a>10.1 rwx权限详解</h3><ul><li><p>rwx作用到文件</p><ol><li>r 代表可读(read):可以读取，查看</li><li>w 代表可写(write):可以修改，但是不代表可以删除该文件，删除一个文件的前提条件是对该文件所在的目录有写的权限，才能删除该文件</li><li>x 代表可执行(execute):可以被执行</li></ol></li><li><p>rwx作用到目录</p><ol><li>r 代表可读(read):可以读取，ls查看目录内容</li><li>w 代表可写(write):可以修改，对目录内创建+删除+重命名目录</li><li>x 代表可执行(execute):可以进入该目录</li></ol></li></ul><p>ls -l中显示的内容如下：</p><p>-<font color="#dd0000">rwx</font><font color="#00dd00">rw-</font><font color="#0000dd">r–</font> 1 root root 1213 Feb 2 09:39 abc</p><p>0-9位说明：</p><ul><li>第0位确定文件类型（d, -, l, c, b）<ul><li>－是普通文件</li><li>l 是链接，相当于windows的快捷方式</li><li>d 是目录，相当于windows的文件夹</li><li>c 是字符设备文件，鼠标、键盘</li><li>b 是块设备，如硬盘</li></ul></li><li>第1-3位确定所有者（该文件的所有者）拥有该文件的权限。</li><li>第4-6位确定所属组（同用户组的）拥有该文件的权限。</li><li>第7-9位确定其他用户拥有该文件的权限。</li></ul><p>可用数字表示为：r=4, w=2, x=1 因此rwx=4+2+1=7</p><p>其他说明：</p><p>1文件：硬连接数或目录：子目录数</p><p>root用户</p><p>root组</p><p>1213文件大小(字节)，如果是文件夹，显示4096字节</p><p>Feb 2 09:39最后修改日期</p><p>abc文件名</p><h3 id="10-2-修改权限-chmod"><a href="#10-2-修改权限-chmod" class="headerlink" title="10.2 修改权限 -chmod"></a>10.2 修改权限 -chmod</h3><p>通过chmod指令，可以修改文件或者目录的权限</p><p>方式一：+、-、= 变更权限</p><p>​u:所有者g:所有者o:其他人a:所有人(u、g、o的总和)</p><ol><li>chmodu=rwx,g=rx,o=x文件/目录名</li><li>chmod    o+w    文件/目录名</li><li>chmod    a-x    文件/目录名</li></ol><p>方式二：通过数字变更权限</p><p>​r=4, w=2, x=1rwx=4+2+1=7</p><p>​chmodu=rwx,g=rx,o=x文件/目录名</p><p>相当于 chmod751文件/目录名</p><h2 id="11-定时任务调度"><a href="#11-定时任务调度" class="headerlink" title="11. 定时任务调度"></a>11. 定时任务调度</h2><h3 id="11-1-crond任务调度"><a href="#11-1-crond任务调度" class="headerlink" title="11.1 crond任务调度"></a>11.1 crond任务调度</h3><img src="/2022/09/09/linux-bi-ji/04.png" class=""><img src="/2022/09/09/linux-bi-ji/05.png" class=""><img src="/2022/09/09/linux-bi-ji/06.png" class=""><p>crond 相关指令：</p><ul><li>crontab -r：终止任务调度</li><li>crontab -l：列出当前有哪些任务调度</li><li>service crond restart  重启任务调度</li></ul><h3 id="11-2-at任务调度"><a href="#11-2-at任务调度" class="headerlink" title="11.2 at任务调度"></a>11.2 at任务调度</h3><h2 id="12-主机名和hosts映射"><a href="#12-主机名和hosts映射" class="headerlink" title="12. 主机名和hosts映射"></a>12. 主机名和hosts映射</h2><h3 id="12-1-设置主机名和hosts映射"><a href="#12-1-设置主机名和hosts映射" class="headerlink" title="12.1 设置主机名和hosts映射"></a>12.1 设置主机名和hosts映射</h3><img src="/2022/09/09/linux-bi-ji/07.png" class=""><h3 id="12-2-主机名解析机制分析"><a href="#12-2-主机名解析机制分析" class="headerlink" title="12.2 主机名解析机制分析"></a>12.2 主机名解析机制分析</h3><p>用户在浏览器输入<a href="http://www.baidu.com：">www.baidu.com：</a></p><ol><li>检查本地解析器缓存（浏览器缓存、DNS解析器缓存）</li><li>检查系统中hosts文件是否配置对应的域名IP映射</li><li>到域名服务DNS进行解析域</li></ol><p>浏览器缓存 –&gt; DNS缓存 –&gt; hosts –&gt; DNS</p><h2 id="13-进程管理"><a href="#13-进程管理" class="headerlink" title="13. 进程管理"></a>13. 进程管理</h2><img src="/2022/09/09/linux-bi-ji/08.png" class=""><h3 id="终止进行kill和killall"><a href="#终止进行kill和killall" class="headerlink" title="终止进行kill和killall"></a>终止进行kill和killall</h3><ul><li>基本语法：<ul><li>kill [选项] 进程号（通过进程号杀死/终止进程）</li><li>killall 进程名称（通过进程名称杀死进程）</li></ul></li><li>常用选项<ul><li>-9 ：表示强迫进程立即停止</li></ul></li></ul><h2 id="14-服务管理"><a href="#14-服务管理" class="headerlink" title="14. 服务管理"></a>14. 服务管理</h2><img src="/2022/09/09/linux-bi-ji/09.png" class=""><img src="/2022/09/09/linux-bi-ji/10.png" class=""><h2 id="15-RPM与YUM"><a href="#15-RPM与YUM" class="headerlink" title="15. RPM与YUM"></a>15. RPM与YUM</h2><h3 id="15-1-RPM"><a href="#15-1-RPM" class="headerlink" title="15.1 RPM"></a>15.1 RPM</h3><p>rpm用于互联网下载包的打包及安装工具。</p><p>rpm包的简单查询指令：rpm -qa | grep xxx</p><img src="/2022/09/09/linux-bi-ji/11.png" class=""><p>卸载rpm包：</p><img src="/2022/09/09/linux-bi-ji/12.png" class=""><p>安装rpm包：</p><img src="/2022/09/09/linux-bi-ji/13.png" class=""><h3 id="15-2-YUM"><a href="#15-2-YUM" class="headerlink" title="15.2 YUM"></a>15.2 YUM</h3><img src="/2022/09/09/linux-bi-ji/14.png" class=""><h2 id="16-Shell脚本"><a href="#16-Shell脚本" class="headerlink" title="16. Shell脚本"></a>16. Shell脚本</h2><h3 id="16-1-Shell的变量"><a href="#16-1-Shell的变量" class="headerlink" title="16.1 Shell的变量"></a>16.1 Shell的变量</h3><p>变量介绍：</p><ol><li>Linux Shell中的变量分为系统变量和用户自定义变量；</li><li>系统变量：$HOME、$PWD、$USER等等</li><li>显示当前shell中所有变量：set</li></ol><p>自定义变量：</p><ol><li>定义变量：变量=值（中间没有空格）</li><li>撤销变量：unset 变量</li><li>声明静态变量：readonly变量，注意不能unset</li></ol><img src="/2022/09/09/linux-bi-ji/15.png" class=""><p>定义变量规则：</p><ol><li>变量名称可以由字母、数字和下划线组成，但是不能以数字开头</li><li>等号两侧不能有空格</li><li>变量名称一般习惯为大写，这是一个规范；</li></ol><p>将命令的返回值赋给变量：</p><ol><li>A=<code>`date`</code>反引号，运行里面的命令，并把结构返回给变量A</li><li>A=$(date) 等价于反引号</li></ol><h3 id="16-2-设置环境变量"><a href="#16-2-设置环境变量" class="headerlink" title="16.2 设置环境变量"></a>16.2 设置环境变量</h3><p>基本语法：</p><ol><li>export 变量名=变量值（将shell变量输出为环境变量/全局变量）</li><li>source 配置文件（让修改后的配置信息立即生效）</li><li>echo $变量名（查询环境变量的值）</li></ol><img src="/2022/09/09/linux-bi-ji/16.png" class=""><p>使用环境变量：</p><img src="/2022/09/09/linux-bi-ji/17.png" class=""><h3 id="16-3-位置参数变量"><a href="#16-3-位置参数变量" class="headerlink" title="16.3 位置参数变量"></a>16.3 位置参数变量</h3><p>介绍：</p><p>​当我们执行一个shell脚本时，如果希望获取到命令行的参数信息，就可以使用到位置参数变量比如：./myshell.sh 100 200，这个就是一个执行shell的命令行，可以在myshell脚本中获取到参数信息</p><p>基本语法：</p><p>$n（n为数字，$0代表命令本身，$1-$9代表第一到第九个参数，十以上的参数需要用大括号包含，如${10}）</p><p>$*（这个变量代表命令行中所有的参数，把所有的参数看成一个整体）</p><p>$@（这个变量也代表命令行中所有参数，把每个参数区分对待）</p><p>$#（这个变量代表命令行中所有参数的个数）</p><img src="/2022/09/09/linux-bi-ji/18.png" class=""><img src="/2022/09/09/linux-bi-ji/19.png" class=""><h3 id="16-4-Shell基本语法"><a href="#16-4-Shell基本语法" class="headerlink" title="16.4 Shell基本语法"></a>16.4 Shell基本语法</h3><p><a href="http://www.baidu.com/">www.baidu.com</a></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx入门</title>
      <link href="/2022/09/08/nginx-ru-men/"/>
      <url>/2022/09/08/nginx-ru-men/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Nginx简介"><a href="#1-Nginx简介" class="headerlink" title="1. Nginx简介"></a>1. Nginx简介</h2><ul><li><p>Nginx (engine x) 是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务。Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点（俄文：Рамблер）开发的，第一个公开版本0.1.0发布于2004年10月4日。2011年6月1日，nginx 1.0.4发布。</p></li><li><p>其特点是占有内存少，并发能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。在全球活跃的网站中有12.18%的使用比率，大约为2220万个网站。</p></li><li><p>Nginx 是一个安装非常的简单、配置文件非常简洁（还能够支持perl语法）、Bug非常少的服务。Nginx 启动特别容易，并且几乎可以做到7*24不间断运行，即使运行数个月也不需要重新启动。你还能够不间断服务的情况下进行软件版本的升级。</p></li><li><p>Nginx代码完全用C语言从头写成。官方数据测试表明能够支持高达 50,000 个并发连接数的响应。</p></li></ul><h2 id="2-Nginx作用"><a href="#2-Nginx作用" class="headerlink" title="2. Nginx作用"></a>2. Nginx作用</h2><div class="note success no-icon"><p>Http代理，反向代理：作为web服务器最常用的功能之一，尤其是反向代理。</p></div><ul><li>正向代理：代理客户端</li></ul><img src="/2022/09/08/nginx-ru-men/01.png" class=""><ul><li>反向代理：代理服务器</li></ul><img src="/2022/09/08/nginx-ru-men/02.png" class=""><div class="note success no-icon"><p>Nginx提供的负载均衡策略有2种：内置策略和扩展策略。内置策略为轮询，加权轮询，Ip hash。扩展策略，就天马行空，只有你想不到的没有他做不到的。</p></div><ul><li>轮询</li></ul><img src="/2022/09/08/nginx-ru-men/03.png" class=""><ul><li>加权轮询（可根据服务器性能设置权重，处理更多请求）</li></ul><img src="/2022/09/08/nginx-ru-men/04.png" class=""><ul><li>iphash对客户端请求的ip进行hash操作，然后根据hash结果将同一个客户端ip的请求分发给同一台服务器进行处理，可以解决session不共享的问题。</li></ul><img src="/2022/09/08/nginx-ru-men/05.png" class=""><div class="note success no-icon"><p>动静分离，在我们的软件开发中，有些请求是需要后台处理的，有些请求是不需要经过后台处理的（如：css、html、jpg、js等等文件），这些不需要经过后台处理的文件称为静态文件。让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后，我们就可以根据静态资源的特点将其做缓存操作。提高资源响应的速度。</p></div><img src="/2022/09/08/nginx-ru-men/06.png" class=""><h2 id="3-Nginx安装"><a href="#3-Nginx安装" class="headerlink" title="3. Nginx安装"></a>3. Nginx安装</h2><h3 id="3-1-windows下安装"><a href="#3-1-windows下安装" class="headerlink" title="3.1 windows下安装"></a>3.1 windows下安装</h3><h4 id="3-1-1-下载nginx"><a href="#3-1-1-下载nginx" class="headerlink" title="3.1.1 下载nginx"></a>3.1.1 下载nginx</h4><p><a href="http://nginx.org/en/download.html">http://nginx.org/en/download.html</a> 下载稳定版本。<br>以nginx/Windows-1.16.1为例，直接下载 nginx-1.16.1.zip。<br>下载后解压，解压后如下：</p><img src="/2022/09/08/nginx-ru-men/07.png" class=""><h4 id="3-1-2-启动nginx"><a href="#3-1-2-启动nginx" class="headerlink" title="3.1.2 启动nginx"></a>3.1.2 启动nginx</h4><ol><li>直接双击nginx.exe，双击后一个黑色的弹窗一闪而过</li><li>打开cmd命令窗口，切换到nginx解压目录下，输入命令 <code>nginx.exe</code> ，回车即可</li></ol><h4 id="3-1-3-检查nginx是否启动成功"><a href="#3-1-3-检查nginx是否启动成功" class="headerlink" title="3.1.3 检查nginx是否启动成功"></a>3.1.3 检查nginx是否启动成功</h4><p>直接在浏览器地址栏输入网址 <a href="http://localhost/">http://localhost:80</a> 回车，出现以下页面说明启动成功！</p><img src="/2022/09/08/nginx-ru-men/08.png" class=""><h4 id="3-1-4-配置监听"><a href="#3-1-4-配置监听" class="headerlink" title="3.1.4 配置监听"></a>3.1.4 配置监听</h4><p>nginx的配置文件是conf目录下的nginx.conf，默认配置的nginx监听的端口为80，如果80端口被占用可以修改为未被占用的端口即可。</p><img src="/2022/09/08/nginx-ru-men/09.png" class=""><p>当我们修改了nginx的配置文件nginx.conf 时，不需要关闭nginx后重新启动nginx，只需要执行命令 <code>nginx -s reload</code> 即可让改动生效</p><h4 id="3-1-5-关闭nginx"><a href="#3-1-5-关闭nginx" class="headerlink" title="3.1.5 关闭nginx"></a>3.1.5 关闭nginx</h4><p>如果使用cmd命令窗口启动nginx， 关闭cmd窗口是不能结束nginx进程的，可使用两种方法关闭nginx</p><p>(1)输入nginx命令 <code>nginx -s stop</code>(快速停止nginx) 或 <code>nginx -s quit</code>(完整有序的停止nginx)</p><p>(2)使用taskkill <code>taskkill /f /t /im nginx.exe</code></p><pre class="language-none"><code class="language-none">taskkill是用来终止进程的，/f是强制终止 ./t终止指定的进程和任何由此启动的子进程。/im示指定的进程名称 .</code></pre><h3 id="3-2-linux下安装"><a href="#3-2-linux下安装" class="headerlink" title="3.2 linux下安装"></a>3.2 linux下安装</h3><h4 id="3-2-1-安装gcc"><a href="#3-2-1-安装gcc" class="headerlink" title="3.2.1 安装gcc"></a>3.2.1 安装gcc</h4><p>安装 nginx 需要先将官网下载的源码进行编译，编译依赖 gcc 环境，如果没有 gcc 环境，则需要安装：</p><pre class="language-none"><code class="language-none">yum install gcc-c++</code></pre><h4 id="3-2-2-PCRE-pcre-devel-安装"><a href="#3-2-2-PCRE-pcre-devel-安装" class="headerlink" title="3.2.2 PCRE pcre-devel 安装"></a>3.2.2 PCRE pcre-devel 安装</h4><p>PCRE(Perl Compatible Regular Expressions) 是一个Perl库，包括 perl 兼容的正则表达式库。nginx 的 http 模块使用 pcre 来解析正则表达式，所以需要在 linux 上安装 pcre 库，pcre-devel 是使用 pcre 开发的一个二次开发库。nginx也需要此库。命令：</p><pre class="language-none"><code class="language-none">yum install -y pcre pcre-devel</code></pre><h4 id="3-2-3-zlib-安装"><a href="#3-2-3-zlib-安装" class="headerlink" title="3.2.3 zlib 安装"></a>3.2.3 zlib 安装</h4><p>zlib 库提供了很多种压缩和解压缩的方式， nginx 使用 zlib 对 http 包的内容进行 gzip ，所以需要在 Centos 上安装 zlib 库。</p><pre class="language-none"><code class="language-none">yum install -y zlib zlib-devel</code></pre><h4 id="3-2-4-OpenSSL-安装"><a href="#3-2-4-OpenSSL-安装" class="headerlink" title="3.2.4 OpenSSL 安装"></a>3.2.4 OpenSSL 安装</h4><p>OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及 SSL 协议，并提供丰富的应用程序供测试或其它目的使用。<br>nginx 不仅支持 http 协议，还支持 https（即在ssl协议上传输http），所以需要在 Centos 安装 OpenSSL 库。</p><pre class="language-none"><code class="language-none">yum install -y openssl openssl-devel</code></pre><h4 id="3-2-5-下载安装包"><a href="#3-2-5-下载安装包" class="headerlink" title="3.2.5 下载安装包"></a>3.2.5 下载安装包</h4><p>手动下载.tar.gz安装包，地址：<a href="https://nginx.org/en/download.html">https://nginx.org/en/download.html</a></p><img src="/2022/09/08/nginx-ru-men/10.png" class=""><p>下载完毕上传到服务器</p><h4 id="3-2-6-解压"><a href="#3-2-6-解压" class="headerlink" title="3.2.6 解压"></a>3.2.6 解压</h4><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">tar</span> -zxvf nginx-1.18.0.tar.gz<span class="token builtin class-name">cd</span> nginx-1.18.0</code></pre><h4 id="3-2-7-配置"><a href="#3-2-7-配置" class="headerlink" title="3.2.7 配置"></a>3.2.7 配置</h4><p>使用默认配置，在nginx根目录下执行</p><pre class="language-bash" data-language="bash"><code class="language-bash">./configure<span class="token function">make</span><span class="token function">make</span> <span class="token function">install</span></code></pre><p>查找安装路径： <code>whereis nginx</code></p><h4 id="3-2-8-Nginx常用命令"><a href="#3-2-8-Nginx常用命令" class="headerlink" title="3.2.8 Nginx常用命令"></a>3.2.8 Nginx常用命令</h4><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /usr/local/nginx/sbin/./nginx  启动./nginx -s stop  停止./nginx -s quit  安全退出./nginx -s reload  重新加载配置文件<span class="token function">ps</span> aux<span class="token operator">|</span><span class="token function">grep</span> nginx  查看nginx进程</code></pre><p>启动成功访问 服务器ip:80</p><img src="/2022/09/08/nginx-ru-men/11.png" class=""><p>注意：如何连接不上，检查阿里云安全组是否开放端口，或者服务器防火墙是否开放端口！<br>相关命令：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 开启</span><span class="token function">service</span> firewalld start<span class="token comment"># 重启</span><span class="token function">service</span> firewalld restart<span class="token comment"># 关闭</span><span class="token function">service</span> firewalld stop<span class="token comment"># 查看防火墙规则</span>firewall-cmd --list-all<span class="token comment"># 查询端口是否开放</span>firewall-cmd --query-port<span class="token operator">=</span><span class="token number">8080</span>/tcp<span class="token comment"># 开放80端口</span>firewall-cmd --permanent --add-port<span class="token operator">=</span><span class="token number">80</span>/tcp<span class="token comment"># 移除端口</span>firewall-cmd --permanent --remove-port<span class="token operator">=</span><span class="token number">8080</span>/tcp<span class="token comment">#重启防火墙(修改配置后要重启防火墙)</span>firewall-cmd --reload<span class="token comment"># 参数解释</span><span class="token number">1</span>、firwall-cmd：是Linux提供的操作firewall的一个工具；<span class="token number">2</span>、--permanent：表示设置为持久；<span class="token number">3</span>、--add-port：标识添加的端口；</code></pre><h2 id="4-Nginx配置详解"><a href="#4-Nginx配置详解" class="headerlink" title="4. Nginx配置详解"></a>4. Nginx配置详解</h2><p>文件结构：</p><pre class="language-none"><code class="language-none">...              #全局配置events {         #events配置   ...}http {     #http配置    upstream edustudy {# 负载均衡配置，默认是轮询        server 127.0.0.1:8080 weight=1;# weight是权重        server 127.0.0.1:8081 weight=1;    }    server {        #server代理        listen       9001;        server_name  localhost;# 监听到之后转发到localhost                location / {  # 9001端口下的所有请求都会被匹配到这里proxy_pass http://edustudy;# 转发至负载均衡里        }                # www.edustudy.com/admin        location /admin {                    }                # 当地址中包含"eduService"时，请求会转发至 http://localhost:8085        location ~ /eduService/ {             proxy_pass http://localhost:8085;        }    }        server {      listen       9002;        server_name  localhost;    }}</code></pre><ul><li><strong>全局块</strong>：配置影响nginx全局的指令。一般有运行nginx服务器的用户组，nginx进程pid存放路径，日志存放路径，配置文件引入，允许生成worker process数等。</li></ul><ul><li><strong>events块</strong>：配置影响nginx服务器或与用户的网络连接。有每个进程的最大连接数，选取哪种事件驱动模型处理连接请求，是否允许同时接受多个网路连接，开启多个网络连接序列化等。</li><li><strong>http块</strong>：可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。如文件引入，mime-type定义，日志自定义，是否使用sendfile传输文件，连接超时时间，单连接请求数等。</li><li><strong>server块</strong>：配置虚拟主机的相关参数，一个http中可以有多个server。</li><li><strong>location块</strong>：配置请求的路由，以及各种页面的处理情况。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis基础知识</title>
      <link href="/2022/09/05/redis-ji-chu-zhi-shi/"/>
      <url>/2022/09/05/redis-ji-chu-zhi-shi/</url>
      
        <content type="html"><![CDATA[<div class="note success no-icon"><p>尚硅谷Redis 6笔记</p></div><h3 id="1-NoSQL-数据库"><a href="#1-NoSQL-数据库" class="headerlink" title="1. NoSQL 数据库"></a>1. NoSQL 数据库</h3><h4 id="1-1-NoSQL-数据库简介"><a href="#1-1-NoSQL-数据库简介" class="headerlink" title="1.1 NoSQL 数据库简介"></a>1.1 NoSQL 数据库简介</h4><p>NoSQL( <strong>Not Only SQL</strong> )，意即“不仅仅是SQL”，泛指<strong>非关系型的数据库</strong>（Redis、MongoDB ……）。 </p><p>NoSQL 不依赖业务逻辑方式存储，而以简单的key-value模式存储。因此大大的增加了数据库的扩展能力。</p><ul><li>不遵循SQL标准</li><li>不支持ACID</li><li>远超于SQL的性能</li></ul><h4 id="1-2-NoSQL-适用场景"><a href="#1-2-NoSQL-适用场景" class="headerlink" title="1.2 NoSQL 适用场景"></a>1.2 NoSQL 适用场景</h4><ul><li>对数据高并发的读写</li><li>海量数据的读写</li><li>对数据高扩展性的</li></ul><h4 id="1-3-NoSQL-不适用场景"><a href="#1-3-NoSQL-不适用场景" class="headerlink" title="1.3 NoSQL 不适用场景"></a>1.3 NoSQL 不适用场景</h4><ul><li>需要事务支持</li><li>基于sql的结构化查询存储，处理复杂的关系</li></ul><h3 id="2-Redis-介绍"><a href="#2-Redis-介绍" class="headerlink" title="2. Redis 介绍"></a>2. Redis 介绍</h3><p>Redis 是完全开源的，遵守 BSD 协议，是一个高性能的 key-value 数据库。</p><p>默认16个数据库，类似数组下标从0开始，默认使用0号库，使用命令select <dbid>来切换数据库。如：select 15</dbid></p><p>Redis 与其他 key - value 缓存产品有以下三个特点：</p><ul><li>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</li><li>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。</li><li>Redis支持数据的备份，即master-slave模式的数据备份。</li></ul><p>Redis是单线程 + 多路IO复用技术：</p><ul><li>Redis 内部使用文件事件处理器 file event handler，这个文件事件处理器是单线程的，所以 Redis 才叫做单线程的模型。</li><li>它采用 IO 多路复用机制同时监听多个 Socket，并把所有产生事件的socket压入一个队列中，然后有序地每次仅一个socket的方式传送给文件事件分派器，文件事件分派器接收到socket之后会根据socket产生的事件类型调用对应的事件处理器进行处理。</li></ul><img src="/2022/09/05/redis-ji-chu-zhi-shi/01.png" class=""><h3 id="3-常用五大数据类型"><a href="#3-常用五大数据类型" class="headerlink" title="3. 常用五大数据类型"></a>3. 常用五大数据类型</h3><p>String(字符串 最多长度512M)、Hash(哈希)、List(列表)、Set(集合)、ZSet(有序集合)</p><p>相关操作命令：<a href="http://www.redis.cn/commands.html">http://www.redis.cn/commands.html</a></p><h3 id="4-Redis的发布和订阅"><a href="#4-Redis的发布和订阅" class="headerlink" title="4. Redis的发布和订阅"></a>4. Redis的发布和订阅</h3><ol><li><p>客户端可以订阅频道如下图：</p><img src="/2022/09/05/redis-ji-chu-zhi-shi/02.png" class=""></li><li><p>当给这个频道发布消息后，消息就会发送给订阅的客户端</p><img src="/2022/09/05/redis-ji-chu-zhi-shi/03.png" class=""></li></ol><p><strong>注：</strong>发布的消息没有持久化，这就会导致新订阅的客户端将不会收到历史消息。（使用专业MQ）</p><h3 id="5-Redis新数据类型"><a href="#5-Redis新数据类型" class="headerlink" title="5. Redis新数据类型"></a>5. Redis新数据类型</h3><p> Bitmaps、HyperLogLog、Geospatial</p><h3 id="6-Redis与SpringBoot整合"><a href="#6-Redis与SpringBoot整合" class="headerlink" title="6. Redis与SpringBoot整合"></a>6. Redis与SpringBoot整合</h3><h4 id="1-在pom-xml文件中引入redis相关依赖"><a href="#1-在pom-xml文件中引入redis相关依赖" class="headerlink" title="1. 在pom.xml文件中引入redis相关依赖"></a>1. 在pom.xml文件中引入redis相关依赖</h4><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- redis --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-data-redis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!-- springboot2.x之后，操作redis的底层使用的Lettuce,而不是jedis --&gt;</span><span class="token comment">&lt;!-- Jedis：采用的直连，多个线程操作的话，是不安全的，如果想要避免不安全的，使用jedis pool 连接池！ --&gt;</span><span class="token comment">&lt;!-- Lettuce：采用netty,实例可以在多个线程中进行共享，不存在线程不安全的情况！可以减少线程数据了！--&gt;</span><span class="token comment">&lt;!-- spring2.X集成redis所需common-pool2--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.apache.commons<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>commons-pool2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>2.6.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span></code></pre><h4 id="2-application-yml-配置redis配置"><a href="#2-application-yml-配置redis配置" class="headerlink" title="2. application.yml 配置redis配置"></a>2. application.yml 配置redis配置</h4><pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">redis</span><span class="token punctuation">:</span>    <span class="token comment"># redis数据库索引(默认为0)，我们使用索引为3的数据库，避免和其他数据库冲突</span>    <span class="token key atrule">database</span><span class="token punctuation">:</span> <span class="token number">0</span>    <span class="token comment"># redis服务器地址（默认为loaclhost）</span>    <span class="token key atrule">host</span><span class="token punctuation">:</span> 192.168.79.150    <span class="token comment"># redis端口（默认为6379）</span>    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">6379</span>    <span class="token comment"># redis访问密码（默认为空）</span>    <span class="token key atrule">password</span><span class="token punctuation">:</span> <span class="token number">123456</span>    <span class="token comment"># redis连接超时时间（单位毫秒）</span>    <span class="token key atrule">timeout</span><span class="token punctuation">:</span> <span class="token number">0</span>    <span class="token comment"># redis连接池配置</span>    <span class="token key atrule">pool</span><span class="token punctuation">:</span>      <span class="token comment"># 最大可用连接数（默认为8，负数表示无限）</span>      <span class="token key atrule">max-active</span><span class="token punctuation">:</span> <span class="token number">8</span>      <span class="token comment"># 最大空闲连接数（默认为8，负数表示无限）</span>      <span class="token key atrule">max-idle</span><span class="token punctuation">:</span> <span class="token number">8</span>      <span class="token comment"># 最小空闲连接数（默认为0，该值只有为正数才有用）</span>      <span class="token key atrule">min-idle</span><span class="token punctuation">:</span> <span class="token number">0</span>      <span class="token comment"># 从连接池中获取连接最大等待时间（默认为-1，单位为毫秒，负数表示无限）</span>      <span class="token key atrule">max-wait</span><span class="token punctuation">:</span> <span class="token number">-1</span></code></pre><h4 id="3-添加redis配置类"><a href="#3-添加redis配置类" class="headerlink" title="3. 添加redis配置类"></a>3. 添加redis配置类</h4><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@EnableCaching</span><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedisConfig</span> <span class="token keyword">extends</span> <span class="token class-name">CachingConfigurerSupport</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> <span class="token function">redisTemplate</span><span class="token punctuation">(</span><span class="token class-name">RedisConnectionFactory</span> factory<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> template <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">RedisSerializer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> redisSerializer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringRedisSerializer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Jackson2JsonRedisSerializer</span> jackson2JsonRedisSerializer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Jackson2JsonRedisSerializer</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">ObjectMapper</span> om <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        om<span class="token punctuation">.</span><span class="token function">setVisibility</span><span class="token punctuation">(</span><span class="token class-name">PropertyAccessor</span><span class="token punctuation">.</span>ALL<span class="token punctuation">,</span> <span class="token class-name">JsonAutoDetect<span class="token punctuation">.</span>Visibility</span><span class="token punctuation">.</span>ANY<span class="token punctuation">)</span><span class="token punctuation">;</span>        om<span class="token punctuation">.</span><span class="token function">enableDefaultTyping</span><span class="token punctuation">(</span><span class="token class-name">ObjectMapper<span class="token punctuation">.</span>DefaultTyping</span><span class="token punctuation">.</span>NON_FINAL<span class="token punctuation">)</span><span class="token punctuation">;</span>        jackson2JsonRedisSerializer<span class="token punctuation">.</span><span class="token function">setObjectMapper</span><span class="token punctuation">(</span>om<span class="token punctuation">)</span><span class="token punctuation">;</span>        template<span class="token punctuation">.</span><span class="token function">setConnectionFactory</span><span class="token punctuation">(</span>factory<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//key序列化方式</span>        template<span class="token punctuation">.</span><span class="token function">setKeySerializer</span><span class="token punctuation">(</span>redisSerializer<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//value序列化</span>        template<span class="token punctuation">.</span><span class="token function">setValueSerializer</span><span class="token punctuation">(</span>jackson2JsonRedisSerializer<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//value hashmap序列化</span>        template<span class="token punctuation">.</span><span class="token function">setHashValueSerializer</span><span class="token punctuation">(</span>jackson2JsonRedisSerializer<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> template<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">CacheManager</span> <span class="token function">cacheManager</span><span class="token punctuation">(</span><span class="token class-name">RedisConnectionFactory</span> factory<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">RedisSerializer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> redisSerializer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringRedisSerializer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Jackson2JsonRedisSerializer</span> jackson2JsonRedisSerializer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Jackson2JsonRedisSerializer</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//解决查询缓存转换异常的问题</span>        <span class="token class-name">ObjectMapper</span> om <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        om<span class="token punctuation">.</span><span class="token function">setVisibility</span><span class="token punctuation">(</span><span class="token class-name">PropertyAccessor</span><span class="token punctuation">.</span>ALL<span class="token punctuation">,</span> <span class="token class-name">JsonAutoDetect<span class="token punctuation">.</span>Visibility</span><span class="token punctuation">.</span>ANY<span class="token punctuation">)</span><span class="token punctuation">;</span>        om<span class="token punctuation">.</span><span class="token function">enableDefaultTyping</span><span class="token punctuation">(</span><span class="token class-name">ObjectMapper<span class="token punctuation">.</span>DefaultTyping</span><span class="token punctuation">.</span>NON_FINAL<span class="token punctuation">)</span><span class="token punctuation">;</span>        jackson2JsonRedisSerializer<span class="token punctuation">.</span><span class="token function">setObjectMapper</span><span class="token punctuation">(</span>om<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 配置序列化（解决乱码的问题）,过期时间600秒</span>        <span class="token class-name">RedisCacheConfiguration</span> config <span class="token operator">=</span> <span class="token class-name">RedisCacheConfiguration</span><span class="token punctuation">.</span><span class="token function">defaultCacheConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">entryTtl</span><span class="token punctuation">(</span><span class="token class-name">Duration</span><span class="token punctuation">.</span><span class="token function">ofSeconds</span><span class="token punctuation">(</span><span class="token number">600</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">serializeKeysWith</span><span class="token punctuation">(</span><span class="token class-name">RedisSerializationContext<span class="token punctuation">.</span>SerializationPair</span><span class="token punctuation">.</span><span class="token function">fromSerializer</span><span class="token punctuation">(</span>redisSerializer<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">serializeValuesWith</span><span class="token punctuation">(</span><span class="token class-name">RedisSerializationContext<span class="token punctuation">.</span>SerializationPair</span><span class="token punctuation">.</span><span class="token function">fromSerializer</span><span class="token punctuation">(</span>jackson2JsonRedisSerializer<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">disableCachingNullValues</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">RedisCacheManager</span> cacheManager <span class="token operator">=</span> <span class="token class-name">RedisCacheManager</span><span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span>factory<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">cacheDefaults</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> cacheManager<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="7-Redis事务"><a href="#7-Redis事务" class="headerlink" title="7. Redis事务"></a>7. Redis事务</h3><h4 id="7-1-事务定义"><a href="#7-1-事务定义" class="headerlink" title="7.1 事务定义"></a>7.1 事务定义</h4><p>Redis事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p><p>Redis事务的主要作用就是串联多个命令防止别的命令插队。</p><h4 id="7-2-Multi、Exec、discard"><a href="#7-2-Multi、Exec、discard" class="headerlink" title="7.2 Multi、Exec、discard"></a>7.2 Multi、Exec、discard</h4><p>从输入Multi命令开始，输入的命令都会依次进入命令队列中，但不会执行，直到输入Exec后，Redis会将之前的命令队列中的命令依次执行。</p><p>组队的过程中可以通过discard来放弃组队。 </p><h4 id="7-3-事务的错误处理"><a href="#7-3-事务的错误处理" class="headerlink" title="7.3 事务的错误处理"></a>7.3 事务的错误处理</h4><ul><li><p>组队中某个命令出现了报告错误，执行时整个的所有队列都会被取消。</p></li><li><p>执行阶段某个命令报出了错误，则只有报错的命令不会被执行，而其他的命令都会执行，不会回滚。</p></li></ul><h4 id="7-4-事务冲突问题"><a href="#7-4-事务冲突问题" class="headerlink" title="7.4 事务冲突问题"></a>7.4 事务冲突问题</h4><img src="/2022/09/05/redis-ji-chu-zhi-shi/04.jpg" class=""><h5 id="7-4-1-悲观锁"><a href="#7-4-1-悲观锁" class="headerlink" title="7.4.1 悲观锁"></a>7.4.1 悲观锁</h5><p><strong>悲观锁(Pessimistic Lock)<strong>，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。</strong>传统的关系型数据库里边就用到了很多这种锁机制</strong>，比如<strong>行锁</strong>，<strong>表锁</strong>等，<strong>读锁</strong>，<strong>写锁</strong>等，都是在做操作之前先上锁。</p><img src="/2022/09/05/redis-ji-chu-zhi-shi/05.jpg" class=""><h5 id="7-4-2-乐观锁"><a href="#7-4-2-乐观锁" class="headerlink" title="7.4.2 乐观锁"></a>7.4.2 乐观锁</h5><p><strong>乐观锁(Optimistic Lock)<strong>，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。</strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量</strong>。Redis就是利用这种check-and-set机制实现事务的。</p><img src="/2022/09/05/redis-ji-chu-zhi-shi/06.jpg" class=""><h5 id="7-4-3-watch-key-key-…"><a href="#7-4-3-watch-key-key-…" class="headerlink" title="7.4.3 watch key [key …]"></a>7.4.3 watch key [key …]</h5><p>在执行multi之前，先执行watch key1 [key2],可以监视一个(或多个) key ，如果在事务<strong>执行之前这个(或这些) key被其他命令所改动，那么事务将被打断。</strong></p><h5 id="7-4-4-unwatch"><a href="#7-4-4-unwatch" class="headerlink" title="7.4.4 unwatch"></a>7.4.4 unwatch</h5><p>取消 watch命令对所有 key 的监视。</p><p>如果在执行 watch 命令之后，exec命令或discard命令先被执行了的话，那么就不需要再执行unwatch了。</p><h5 id="7-4-5-Redis事务三特性"><a href="#7-4-5-Redis事务三特性" class="headerlink" title="7.4.5 Redis事务三特性"></a>7.4.5 Redis事务三特性</h5><p>单独的隔离操作：</p><ul><li>事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断</li></ul><p>没有隔离级别的概念：</p><ul><li>队列中的命令没有提交之前都不会实际被执行，因为事务提交前任何指令都不会被实际执行</li></ul><p>不保证原子性：</p><ul><li>事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚</li></ul><h3 id="8-Redis持久化之RDB"><a href="#8-Redis持久化之RDB" class="headerlink" title="8. Redis持久化之RDB"></a>8. Redis持久化之RDB</h3><p>RDB(Redis DataBase)：</p><p>​在指定的时间间隔内将内存中的数据集快照写入磁盘， 也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里</p><h4 id="8-1-备份是如何执行的"><a href="#8-1-备份是如何执行的" class="headerlink" title="8.1 备份是如何执行的"></a>8.1 备份是如何执行的</h4><p>​Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到 一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。 整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能 如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。<strong>RDB的缺点是最后一次持久化后的数据可能丢失</strong>。</p><h4 id="8-2-Fork"><a href="#8-2-Fork" class="headerlink" title="8.2 Fork"></a>8.2 Fork</h4><ul><li>Fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等） 数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程</li><li>在Linux程序中，fork()会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，Linux中引入了“<strong>写时复制技术</strong>”</li><li><strong>一般情况父进程和子进程会共用同一段物理内存</strong>，只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。</li></ul><h4 id="8-3-dump-rdb文件"><a href="#8-3-dump-rdb文件" class="headerlink" title="8.3 dump.rdb文件"></a>8.3 dump.rdb文件</h4><p>在redis.conf中配置文件名称，默认为dump.rdb         </p><img src="/2022/09/05/redis-ji-chu-zhi-shi/07.png" class="">                     <h4 id="8-4-配置位置"><a href="#8-4-配置位置" class="headerlink" title="8.4 配置位置"></a>8.4 配置位置</h4><p>rdb文件的保存路径，也可以修改。默认为Redis启动时命令行所在的目录下</p><p>dir “/myredis/“</p> <img src="/2022/09/05/redis-ji-chu-zhi-shi/08.png" class="">         <h4 id="8-5-如何触发RDB快照；保持策略"><a href="#8-5-如何触发RDB快照；保持策略" class="headerlink" title="8.5 如何触发RDB快照；保持策略"></a>8.5 如何触发RDB快照；保持策略</h4><h5 id="8-5-1-配置文件中默认的快照配置"><a href="#8-5-1-配置文件中默认的快照配置" class="headerlink" title="8.5.1 配置文件中默认的快照配置"></a>8.5.1 配置文件中默认的快照配置</h5> <img src="/2022/09/05/redis-ji-chu-zhi-shi/09.png" class="">         <h5 id="8-5-2-命令save-VS-bgsave"><a href="#8-5-2-命令save-VS-bgsave" class="headerlink" title="8.5.2 命令save VS bgsave"></a>8.5.2 命令save VS bgsave</h5><p>save ：save时只管保存，其它不管，全部阻塞。手动保存。不建议。</p><p><strong>bgsave：Redis会在后台异步进行快照操作，快照同时还可以响应客户端请求。</strong></p><p>可以通过lastsave 命令获取最后一次成功执行快照的时间</p><h5 id="8-5-3-flushall命令"><a href="#8-5-3-flushall命令" class="headerlink" title="8.5.3  flushall命令"></a>8.5.3  flushall命令</h5><p>执行flushall命令，也会产生dump.rdb文件，但里面是空的，无意义</p><h5 id="8-5-4-Save"><a href="#8-5-4-Save" class="headerlink" title="8.5.4 Save"></a>8.5.4 Save</h5><p>格式：save 秒钟 写操作次数</p><p>RDB是整个内存的压缩过的Snapshot，RDB的数据结构，可以配置复合的快照触发条件，</p><p><strong>默认是1分钟内改了万次，或5分钟内改了10次，或15分钟内改了1次。</strong></p><p>禁用</p><p>不设置save指令，或者给save传入空字符串</p><h5 id="8-5-5-stop-writes-on-bgsave-error"><a href="#8-5-5-stop-writes-on-bgsave-error" class="headerlink" title="8.5.5 stop-writes-on-bgsave-error"></a>8.5.5 <strong>stop-writes-on-bgsave-error</strong></h5><img src="/2022/09/05/redis-ji-chu-zhi-shi/10.png" class="">      <p>当Redis无法写入磁盘的话，直接关掉Redis的写操作。推荐yes.</p><h5 id="8-5-6-rdbcompression压缩文件"><a href="#8-5-6-rdbcompression压缩文件" class="headerlink" title="8.5.6 rdbcompression压缩文件"></a>8.5.6 rdbcompression压缩文件</h5><img src="/2022/09/05/redis-ji-chu-zhi-shi/11.png" class="">     <p>对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用LZF算法进行压缩。</p><p>如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能。推荐yes.</p><h5 id="8-5-7-rdbchecksum-检查完整性"><a href="#8-5-7-rdbchecksum-检查完整性" class="headerlink" title="8.5.7 rdbchecksum 检查完整性"></a>8.5.7 rdbchecksum 检查完整性</h5><img src="/2022/09/05/redis-ji-chu-zhi-shi/12.png" class="">     <p>在存储快照后，还可以让redis使用CRC64算法来进行数据校验，</p><p>但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能</p><p>推荐yes.</p><h5 id="8-5-8-rdb的备份"><a href="#8-5-8-rdb的备份" class="headerlink" title="8.5.8 rdb的备份"></a>8.5.8 rdb的备份</h5><p>先通过config get dir 查询rdb文件的目录 </p><p>将*.rdb的文件拷贝到别的地方</p><p>rdb的恢复</p><ul><li><p>关闭Redis</p></li><li><p>先把备份的文件拷贝到工作目录下 cp dump2.rdb dump.rdb</p></li><li><p>启动Redis, 备份数据会直接加载</p></li></ul><h4 id="8-6-优势"><a href="#8-6-优势" class="headerlink" title="8.6 优势"></a>8.6 优势</h4><ul><li>适合大规模的数据恢复</li><li>对数据完整性和一致性要求不高更适合使用</li><li>节省磁盘空间</li><li>恢复速度快</li></ul> <img src="/2022/09/05/redis-ji-chu-zhi-shi/13.jpg" class="">   <h4 id="8-7劣势"><a href="#8-7劣势" class="headerlink" title="8.7劣势"></a>8.7劣势</h4><ul><li>Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑</li><li>虽然Redis在fork时使用了<strong>写时拷贝技术</strong>,但是如果数据庞大时还是比较消耗性能。</li><li>在备份周期在一定间隔时间做一次备份，所以如果Redis意外down掉的话，就会丢失最后一次快照后的所有修改。</li></ul><h4 id="8-8-如何停止"><a href="#8-8-如何停止" class="headerlink" title="8.8 如何停止"></a>8.8 如何停止</h4><p>动态停止RDB：redis-cli config set save “”#save后给空值，表示禁用保存策略</p><h4 id="8-9-小总结"><a href="#8-9-小总结" class="headerlink" title="8.9 小总结"></a>8.9 小总结</h4>  <img src="/2022/09/05/redis-ji-chu-zhi-shi/14.jpg" class="">   <h3 id="9-Redis持久化之AOF"><a href="#9-Redis持久化之AOF" class="headerlink" title="9. Redis持久化之AOF"></a>9. Redis持久化之AOF</h3><p>AOF(Append Only File)：</p><p>​以<strong>日志</strong>的形式来记录每个写操作（增量保存），将Redis执行过的所有写指令记录下来(<strong>读操作不记录</strong>)， <strong>只许追加文件但不可以改写文件</strong>，redis启动之初会读取该文件重新构建数据，换言之，redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作</p><h4 id="9-1-AOF持久化流程"><a href="#9-1-AOF持久化流程" class="headerlink" title="9.1 AOF持久化流程"></a>9.1 AOF持久化流程</h4><p>（1）客户端的请求写命令会被append追加到AOF缓冲区内；</p><p>（2）AOF缓冲区根据AOF持久化策略[always,everysec,no]将操作sync同步到磁盘的AOF文件中；</p><p>（3）AOF文件大小超过重写策略或手动重写时，会对AOF文件rewrite重写，压缩AOF文件容量；</p><p>（4）Redis服务重启时，会重新load加载AOF文件中的写操作达到数据恢复的目的；</p>  <img src="/2022/09/05/redis-ji-chu-zhi-shi/15.png" class="">   <h4 id="9-2-AOF默认不开启"><a href="#9-2-AOF默认不开启" class="headerlink" title="9.2 AOF默认不开启"></a>9.2 AOF默认不开启</h4><p>​可以在redis.conf中配置文件名称，默认为 appendonly.aof</p><p>​AOF文件的保存路径，同RDB的路径一致。</p><h4 id="9-3-AOF和RDB同时开启，redis听谁的？"><a href="#9-3-AOF和RDB同时开启，redis听谁的？" class="headerlink" title="9.3 AOF和RDB同时开启，redis听谁的？"></a>9.3 AOF和RDB同时开启，redis听谁的？</h4><p>AOF和RDB同时开启，系统默认取AOF的数据（数据不会存在丢失）</p><h4 id="9-4-AOF启动-x2F-修复-x2F-恢复"><a href="#9-4-AOF启动-x2F-修复-x2F-恢复" class="headerlink" title="9.4 AOF启动/修复/恢复"></a>9.4 AOF启动/修复/恢复</h4><p>​AOF的备份机制和性能虽然和RDB不同, 但是备份和恢复的操作同RDB一样，都是拷贝备份文件，需要恢复时再拷贝到Redis工作目录下，启动系统即加载。</p><p>​正常恢复</p><ul><li>修改默认的appendonly no，改为yes</li><li>将有数据的aof文件复制一份保存到对应目录(查看目录：config get dir)</li><li>恢复：重启redis然后重新加载</li></ul><p>​异常恢复</p><ul><li>修改默认的appendonly no，改为yes</li><li>如遇到<strong>AOF文件损坏</strong>，通过/usr/local/bin/<strong>redis-check-aof–fix appendonly.aof</strong>进行恢复</li><li>备份被写坏的AOF文件</li><li>恢复：重启redis，然后重新加载</li></ul><h4 id="9-5-AOF同步频率设置"><a href="#9-5-AOF同步频率设置" class="headerlink" title="9.5 AOF同步频率设置"></a>9.5 AOF同步频率设置</h4><p>​appendfsync always</p><p>​始终同步，每次Redis的写入都会立刻记入日志；性能较差但数据完整性比较好</p><p>​appendfsync everysec</p><p>​每秒同步，每秒记入日志一次，如果宕机，本秒的数据可能丢失。</p><p>​appendfsync no</p><p>​redis不主动进行同步，把同步时机交给操作系统。</p><h4 id="9-6-Rewrite压缩"><a href="#9-6-Rewrite压缩" class="headerlink" title="9.6 Rewrite压缩"></a>9.6 Rewrite压缩</h4><h5 id="9-6-1-是什么："><a href="#9-6-1-是什么：" class="headerlink" title="9.6.1 是什么："></a>9.6.1 是什么：</h5><p>AOF采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制, 当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩， 只保留可以恢复数据的最小指令集.可以使用命令bgrewriteaof</p><h5 id="9-6-2-重写原理，如何实现重写"><a href="#9-6-2-重写原理，如何实现重写" class="headerlink" title="9.6.2 重写原理，如何实现重写"></a>9.6.2 重写原理，如何实现重写</h5><p>AOF文件持续增长而过大时，会fork出一条新进程来将文件重写(也是先写临时文件最后再rename)，redis4.0版本后的重写，是指上就是把rdb 的快照，以二级制的形式附在新的aof头部，作为已有的历史数据，替换掉原来的流水账操作。</p><p>no-appendfsync-on-rewrite：</p><p>如果 no-appendfsync-on-rewrite=yes ,不写入aof文件只写入缓存，用户请求不会阻塞，但是在这段时间如果宕机会丢失这段时间的缓存数据。（降低数据安全性，提高性能）</p><p>   如果 no-appendfsync-on-rewrite=no, 还是会把数据往磁盘里刷，但是遇到重写操作，可能会发生阻塞。（数据安全，但是性能降低）</p><p>触发机制，何时重写</p><p>Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发</p><p>重写虽然可以节约大量磁盘空间，减少恢复时间。但是每次重写还是有一定的负担的，因此设定Redis要满足一定条件才会进行重写。 </p><p>auto-aof-rewrite-percentage：设置重写的基准值，文件达到100%时开始重写（文件是原来重写后文件的2倍时触发）</p><p>auto-aof-rewrite-min-size：设置重写的基准值，最小文件64MB。达到这个值开始重写。</p><p>例如：文件达到70MB开始重写，降到50MB，下次什么时候开始重写？100MB</p><p>系统载入时或者上次重写完毕时，Redis会记录此时AOF大小，设为base_size,</p><p>如果Redis的AOF当前大小&gt;= base_size +base_size*100% (默认)且当前大小&gt;=64mb(默认)的情况下，Redis会对AOF进行重写。 </p><h5 id="9-6-3-重写流程"><a href="#9-6-3-重写流程" class="headerlink" title="9.6.3 重写流程"></a>9.6.3 重写流程</h5><p>（1）bgrewriteaof触发重写，判断是否当前有bgsave或bgrewriteaof在运行，如果有，则等待该命令结束后再继续执行。</p><p>（2）主进程fork出子进程执行重写操作，保证主进程不会阻塞。</p><p>（3）子进程遍历redis内存中数据到临时文件，客户端的写请求同时写入aof_buf缓冲区和aof_rewrite_buf重写缓冲区保证原AOF文件完整以及新AOF文件生成期间的新的数据修改动作不会丢失。</p><p>（4）1).子进程写完新的AOF文件后，向主进程发信号，父进程更新统计信息。2).主进程把aof_rewrite_buf中的数据写入到新的AOF文件。</p><p>（5）使用新的AOF文件覆盖旧的AOF文件，完成AOF重写。</p>  <img src="/2022/09/05/redis-ji-chu-zhi-shi/16.png" class="">                      <h4 id="9-7-优势"><a href="#9-7-优势" class="headerlink" title="9.7 优势"></a>9.7 优势</h4>   <img src="/2022/09/05/redis-ji-chu-zhi-shi/17.jpg" class="">       <ul><li><p>备份机制更稳健，丢失数据概率更低。</p></li><li><p>可读的日志文本，通过操作AOF稳健，可以处理误操作。</p></li></ul><h4 id="9-8-劣势"><a href="#9-8-劣势" class="headerlink" title="9.8 劣势"></a>9.8 劣势</h4><ul><li><p>比起RDB占用更多的磁盘空间。</p></li><li><p>恢复备份速度要慢。</p></li><li><p>每次读写都同步的话，有一定的性能压力。</p></li><li><p>存在个别Bug，造成恢复不能。</p></li></ul><h4 id="9-9-小总结"><a href="#9-9-小总结" class="headerlink" title="9.9 小总结"></a>9.9 小总结</h4><p>​    <img src="/2022/09/05/redis-ji-chu-zhi-shi/18.jpg" class="">    </p><h4 id="9-10-总结-Which-one"><a href="#9-10-总结-Which-one" class="headerlink" title="9.10 总结(Which one)"></a>9.10 总结(Which one)</h4><h5 id="9-10-1-用哪个好"><a href="#9-10-1-用哪个好" class="headerlink" title="9.10.1 用哪个好"></a>9.10.1 用哪个好</h5><p>官方推荐两个都启用。</p><p>如果对数据不敏感，可以选单独用RDB。</p><p>不建议单独用 AOF，因为可能会出现Bug。</p><p>如果只是做纯内存缓存，可以都不用。</p><h5 id="9-10-2-官网建议"><a href="#9-10-2-官网建议" class="headerlink" title="9.10.2 官网建议"></a>9.10.2 官网建议</h5><ul><li><p>RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储</p></li><li><p>AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据,AOF命令以redis协议追加保存每次写的操作到文件末尾. </p></li><li><p>Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大</p></li><li><p>只做缓存：如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式.</p></li><li><p>同时开启两种持久化方式</p></li><li><p>在这种情况下,当redis重启的时候会优先载入AOF文件来恢复原始的数据, 因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整.</p></li><li><p>RDB的数据不实时，同时使用两者时服务器重启也只会找AOF文件。那要不要只使用AOF呢？ </p></li><li><p>建议不要，因为RDB更适合用于备份数据库(AOF在不断变化不好备份)， 快速重启，而且不会有AOF可能潜在的bug，留着作为一个万一的手段。</p></li><li><p>性能建议</p><pre class="language-none"><code class="language-none">因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留save 900 1这条规则。如果使用AOF，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了。代价,一是带来了持续的IO，二是AOF rewrite的最后将rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上。默认超过原大小100%大小时重写可以改到适当的数值。</code></pre></li></ul><h3 id="10-Redis主从复制"><a href="#10-Redis主从复制" class="headerlink" title="10 Redis主从复制"></a>10 Redis主从复制</h3><h4 id="10-1-是什么"><a href="#10-1-是什么" class="headerlink" title="10.1 是什么"></a>10.1 是什么</h4><p>主机数据更新后根据配置和策略， 自动同步到备机的master/slaver机制，<strong>Master以写为主，Slave以读为主</strong></p><h4 id="10-2-能干嘛"><a href="#10-2-能干嘛" class="headerlink" title="10.2 能干嘛"></a>10.2 能干嘛</h4><ul><li>读写分离，性能扩展</li><li>容灾快速恢复</li></ul><p>​     <img src="/2022/09/05/redis-ji-chu-zhi-shi/19.jpg" class="">          </p><h4 id="10-3-怎么玩：主从复制"><a href="#10-3-怎么玩：主从复制" class="headerlink" title="10.3 怎么玩：主从复制"></a>10.3 怎么玩：主从复制</h4><p>​拷贝多个redis.conf文件include(写绝对路径)</p><p>​开启daemonize yes</p><p>​Pid文件名字pidfile</p><p>​指定端口port</p><p>​Log文件名字</p><p>​dump.rdb名字dbfilename</p><p>​Appendonly 关掉或者换名字</p><h5 id="10-3-1-新建redis6379-conf，填写以下内容"><a href="#10-3-1-新建redis6379-conf，填写以下内容" class="headerlink" title="10.3.1 新建redis6379.conf，填写以下内容"></a>10.3.1 新建redis6379.conf，填写以下内容</h5><p>include /myredis/redis.conf</p><p>pidfile /var/run/redis_6379.pid</p><p>port 6379</p><p>dbfilename dump6379.rdb</p> <img src="/2022/09/05/redis-ji-chu-zhi-shi/20.jpg" class="">         <h5 id="10-3-2-新建redis6380-conf，填写以下内容"><a href="#10-3-2-新建redis6380-conf，填写以下内容" class="headerlink" title="10.3.2 新建redis6380.conf，填写以下内容"></a>10.3.2 新建redis6380.conf，填写以下内容</h5><img src="/2022/09/05/redis-ji-chu-zhi-shi/21.jpg" class="">         <h5 id="10-3-3-新建redis6381-conf，填写以下内容"><a href="#10-3-3-新建redis6381-conf，填写以下内容" class="headerlink" title="10.3.3 新建redis6381.conf，填写以下内容"></a>10.3.3 新建redis6381.conf，填写以下内容</h5><img src="/2022/09/05/redis-ji-chu-zhi-shi/22.jpg" class="">         <p>replica-priority 10</p><p>设置从机的优先级，值越小，优先级越高，用于选举主机时使用。默认100</p><h5 id="10-3-4-启动三台redis服务器"><a href="#10-3-4-启动三台redis服务器" class="headerlink" title="10.3.4 启动三台redis服务器"></a>10.3.4 启动三台redis服务器</h5> <img src="/2022/09/05/redis-ji-chu-zhi-shi/23.jpg" class="">    <h5 id="10-3-5-查看系统进程，看看三台服务器是否启动"><a href="#10-3-5-查看系统进程，看看三台服务器是否启动" class="headerlink" title="10.3.5 查看系统进程，看看三台服务器是否启动"></a>10.3.5 查看系统进程，看看三台服务器是否启动</h5>  <img src="/2022/09/05/redis-ji-chu-zhi-shi/24.jpg" class="">    <h5 id="10-3-6-查看三台主机运行情况"><a href="#10-3-6-查看三台主机运行情况" class="headerlink" title="10.3.6 查看三台主机运行情况"></a>10.3.6 查看三台主机运行情况</h5><p>info replication</p><p>打印主从复制的相关信息</p><img src="/2022/09/05/redis-ji-chu-zhi-shi/25.jpg" class="">  <h5 id="10-3-7-配从-库-不配主-库"><a href="#10-3-7-配从-库-不配主-库" class="headerlink" title="10.3.7 配从(库)不配主(库)"></a>10.3.7 配从(库)不配主(库)</h5><p>slaveof <ip><port></port></ip></p><p>成为某个实例的从服务器</p><p>1、在6380和6381上执行: slaveof 127.0.0.1 6379</p> <img src="/2022/09/05/redis-ji-chu-zhi-shi/26.jpg" class="">  <p>2、在主机上写，在从机上可以读取数据</p><p>在从机上写数据报错</p>  <img src="/2022/09/05/redis-ji-chu-zhi-shi/27.jpg" class="">  <p>3、主机挂掉，重启就行，一切如初</p><p>4、从机重启需重设：slaveof 127.0.0.1 6379</p><p>可以将配置增加到文件中。永久生效。</p>   <img src="/2022/09/05/redis-ji-chu-zhi-shi/28.jpg" class="">  <h4 id="10-4-常用3招"><a href="#10-4-常用3招" class="headerlink" title="10.4 常用3招"></a>10.4 常用3招</h4><h5 id="10-4-1-一主二仆"><a href="#10-4-1-一主二仆" class="headerlink" title="10.4.1 一主二仆"></a>10.4.1 一主二仆</h5><p>切入点问题？slave1、slave2是从头开始复制还是从切入点开始复制?比如从k4进来，那之前的k1,k2,k3是否也可以复制？</p><p>从机是否可以写？set可否？ </p><p>主机shutdown后情况如何？从机是上位还是原地待命？</p><p>主机又回来了后，主机新增记录，从机还能否顺利复制？ </p><p>其中一台从机down后情况如何？依照原有它能跟上大部队吗？</p>  <img src="/2022/09/05/redis-ji-chu-zhi-shi/29.jpg" class="">  <h5 id="10-4-2-薪火相传"><a href="#10-4-2-薪火相传" class="headerlink" title="10.4.2 薪火相传"></a>10.4.2 薪火相传</h5><p>上一个Slave可以是下一个slave的Master，Slave同样可以接收其他 slaves的连接和同步请求，那么该slave作为了链条中下一个的master, 可以有效减轻master的写压力,去中心化降低风险。</p><p>用 slaveof <ip><port></port></ip></p><p>中途变更转向:会清除之前的数据，重新建立拷贝最新的</p><p>风险是一旦某个slave宕机，后面的slave都没法备份</p><p>主机挂了，从机还是从机，无法写数据了</p>  <img src="/2022/09/05/redis-ji-chu-zhi-shi/30.jpg" class="">    <img src="/2022/09/05/redis-ji-chu-zhi-shi/31.jpg" class="">  <h5 id="10-4-3-反客为主"><a href="#10-4-3-反客为主" class="headerlink" title="10.4.3 反客为主"></a>10.4.3 反客为主</h5><p>当一个master宕机后，后面的slave可以立刻升为master，其后面的slave不用做任何修改。</p><p>用 slaveof no one  将从机变为主机。</p>   <img src="/2022/09/05/redis-ji-chu-zhi-shi/32.jpg" class="">  <h4 id="10-5-复制原理"><a href="#10-5-复制原理" class="headerlink" title="10.5 复制原理"></a>10.5 复制原理</h4><ul><li>Slave启动成功连接到master后会发送一个sync命令</li><li>Master接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令， 在后台进程执行完毕之后，master将传送整个数据文件到slave,以完成一次完全同步</li><li>全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。</li><li>增量复制：Master继续将新的所有收集到的修改命令依次传给slave,完成同步</li><li>但是只要是重新连接master,一次完全同步（全量复制)将被自动执行</li></ul><h4 id="10-6-哨兵模式-sentinel"><a href="#10-6-哨兵模式-sentinel" class="headerlink" title="10.6 哨兵模式(sentinel)"></a>10.6 哨兵模式(sentinel)</h4><h5 id="10-6-1-是什么"><a href="#10-6-1-是什么" class="headerlink" title="10.6.1 是什么"></a>10.6.1 是什么</h5><p><strong>反客为主的自动版</strong>，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库</p><p>​    <img src="/2022/09/05/redis-ji-chu-zhi-shi/33.jpg" class="">  </p><h4 id="10-6-2-怎么玩-使用步骤"><a href="#10-6-2-怎么玩-使用步骤" class="headerlink" title="10.6.2 怎么玩(使用步骤)"></a>10.6.2 怎么玩(使用步骤)</h4><h5 id="10-6-2-1-调整为一主二仆模式，6379带着6380、6381"><a href="#10-6-2-1-调整为一主二仆模式，6379带着6380、6381" class="headerlink" title="10.6.2.1 调整为一主二仆模式，6379带着6380、6381"></a>10.6.2.1 调整为一主二仆模式，6379带着6380、6381</h5> <img src="/2022/09/05/redis-ji-chu-zhi-shi/34.jpg" class="">  <h5 id="10-6-2-2-自定义的-x2F-myredis目录下新建sentinel-conf文件，名字绝不能错"><a href="#10-6-2-2-自定义的-x2F-myredis目录下新建sentinel-conf文件，名字绝不能错" class="headerlink" title="10.6.2.2 自定义的/myredis目录下新建sentinel.conf文件，名字绝不能错"></a>10.6.2.2 自定义的/myredis目录下新建sentinel.conf文件，名字绝不能错</h5><h5 id="10-6-2-3-配置哨兵-填写内容"><a href="#10-6-2-3-配置哨兵-填写内容" class="headerlink" title="10.6.2.3 配置哨兵,填写内容"></a>10.6.2.3 配置哨兵,填写内容</h5><p>sentinel monitor mymaster 127.0.0.1 6379 1</p><p>其中mymaster为监控对象起的服务器名称， 1 为至少有多少个哨兵同意迁移的数量。 </p><h5 id="10-6-2-4-启动哨兵"><a href="#10-6-2-4-启动哨兵" class="headerlink" title="10.6.2.4 启动哨兵"></a>10.6.2.4 启动哨兵</h5><p>/usr/local/bin</p><p>redis做压测可以用自带的redis-benchmark工具</p><p>执行redis-sentinel /myredis/sentinel.conf </p>  <img src="/2022/09/05/redis-ji-chu-zhi-shi/35.jpg" class="">  <h5 id="10-6-2-5-当主机挂掉，从机选举中产生新的主机"><a href="#10-6-2-5-当主机挂掉，从机选举中产生新的主机" class="headerlink" title="10.6.2.5 当主机挂掉，从机选举中产生新的主机"></a>10.6.2.5 当主机挂掉，从机选举中产生新的主机</h5><p>(大概10秒左右可以看到哨兵窗口日志，切换了新的主机)</p><p>哪个从机会被选举为主机呢？根据优先级别：slave-priority </p><p>原主机重启后会变为从机。</p>  <img src="/2022/09/05/redis-ji-chu-zhi-shi/36.jpg" class="">  <h5 id="10-6-2-6-复制延时"><a href="#10-6-2-6-复制延时" class="headerlink" title="10.6.2.6 复制延时"></a>10.6.2.6 复制延时</h5><p>由于所有的写操作都是先在Master上操作，然后同步更新到Slave上，所以从Master同步到Slave机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重。</p><h4 id="10-6-3-故障恢复"><a href="#10-6-3-故障恢复" class="headerlink" title="10.6.3 故障恢复"></a>10.6.3 故障恢复</h4> <img src="/2022/09/05/redis-ji-chu-zhi-shi/37.jpg" class="">  <p>优先级在redis.conf中默认：replica-priority 100，值越小优先级越高</p><p>偏移量是指获得原主机数据最全的</p><p>每个redis实例启动后都会随机生成一个40位的runid</p><h4 id="10-6-4-主从复制"><a href="#10-6-4-主从复制" class="headerlink" title="10.6.4 主从复制"></a>10.6.4 主从复制</h4><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">JedisSentinelPool</span> jedisSentinelPool<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span>  <span class="token class-name">Jedis</span> <span class="token function">getJedisFromSentinel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span><span class="token punctuation">(</span>jedisSentinelPool<span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> sentinelSet<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            sentinelSet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"192.168.11.103:26379"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">JedisPoolConfig</span> jedisPoolConfig <span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">JedisPoolConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            jedisPoolConfig<span class="token punctuation">.</span><span class="token function">setMaxTotal</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//最大可用连接数</span>jedisPoolConfig<span class="token punctuation">.</span><span class="token function">setMaxIdle</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//最大闲置连接数</span>jedisPoolConfig<span class="token punctuation">.</span><span class="token function">setMinIdle</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//最小闲置连接数</span>jedisPoolConfig<span class="token punctuation">.</span><span class="token function">setBlockWhenExhausted</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//连接耗尽是否等待</span>jedisPoolConfig<span class="token punctuation">.</span><span class="token function">setMaxWaitMillis</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//等待时间</span>jedisPoolConfig<span class="token punctuation">.</span><span class="token function">setTestOnBorrow</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//取连接的时候进行一下测试 ping pong</span>jedisSentinelPool<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">JedisSentinelPool</span><span class="token punctuation">(</span><span class="token string">"mymaster"</span><span class="token punctuation">,</span>sentinelSet<span class="token punctuation">,</span>jedisPoolConfig<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> jedisSentinelPool<span class="token punctuation">.</span><span class="token function">getResource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span><span class="token keyword">return</span> jedisSentinelPool<span class="token punctuation">.</span><span class="token function">getResource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="11-Redis集群"><a href="#11-Redis集群" class="headerlink" title="11. Redis集群"></a>11. Redis集群</h3><h4 id="11-1-问题"><a href="#11-1-问题" class="headerlink" title="11.1 问题"></a>11.1 问题</h4><p>容量不够，redis如何进行扩容？</p><p>并发写操作， redis如何分摊？</p><p>另外，主从模式，薪火相传模式，主机宕机，导致ip地址发生变化，应用程序中配置需要修改对应的主机地址、端口等信息。</p><p>之前通过代理主机来解决，但是redis3.0中提供了解决方案。就是无中心化集群配置。</p><h4 id="11-2-什么是集群"><a href="#11-2-什么是集群" class="headerlink" title="11.2 什么是集群"></a>11.2 什么是集群</h4><p>Redis 集群实现了对Redis的水平扩容，即启动N个redis节点，将整个数据库分布存储在这N个节点中，每个节点存储总数据的1/N。</p><p>Redis 集群通过分区（partition）来提供一定程度的可用性（availability）： 即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求。</p><h4 id="11-3-删除持久化数据"><a href="#11-3-删除持久化数据" class="headerlink" title="11.3 删除持久化数据"></a>11.3 删除持久化数据</h4><p>将rdb,aof文件都删除掉。</p><h4 id="11-4-制作6个实例，6379-6380-6381-6389-6390-6391"><a href="#11-4-制作6个实例，6379-6380-6381-6389-6390-6391" class="headerlink" title="11.4 制作6个实例，6379,6380,6381,6389,6390,6391"></a>11.4 制作6个实例，6379,6380,6381,6389,6390,6391</h4><h5 id="11-4-1-配置基本信息"><a href="#11-4-1-配置基本信息" class="headerlink" title="11.4.1 配置基本信息"></a>11.4.1 配置基本信息</h5><p>开启daemonize yes</p><p>Pid文件名字</p><p>指定端口</p><p>Log文件名字</p><p>Dump.rdb名字</p><p>Appendonly 关掉或者换名字</p><h5 id="11-4-2-redis-cluster配置修改"><a href="#11-4-2-redis-cluster配置修改" class="headerlink" title="11.4.2 redis cluster配置修改"></a>11.4.2 redis cluster配置修改</h5><p>cluster-enabled <strong>yes</strong>  打开集群模式</p><p>cluster-config-file <strong>nodes-6379.conf</strong> 设定节点配置文件名</p><p>cluster-node-timeout <strong>15000</strong>  设定节点失联时间，超过该时间（毫秒），集群自动进行主从切换。</p><pre class="language-none"><code class="language-none">include /home/bigdata/redis.confport 6379  pidfile  "/var/run/redis_6379.pid"  dbfilename "dump6379.rdb"  dir  "/home/bigdata/redis_cluster"  logfile "/home/bigdata/redis_cluster/redis_err_6379.log"  cluster-enabled yes  cluster-config-file nodes-6379.conf  cluster-node-timeout 15000  </code></pre><h5 id="11-4-3-修改好redis6379-conf文件，拷贝多个redis-conf文件"><a href="#11-4-3-修改好redis6379-conf文件，拷贝多个redis-conf文件" class="headerlink" title="11.4.3 修改好redis6379.conf文件，拷贝多个redis.conf文件"></a>11.4.3 修改好redis6379.conf文件，拷贝多个redis.conf文件</h5><img src="/2022/09/05/redis-ji-chu-zhi-shi/38.jpg" class="">  <h5 id="11-4-4-使用查找替换修改另外5个文件"><a href="#11-4-4-使用查找替换修改另外5个文件" class="headerlink" title="11.4.4 使用查找替换修改另外5个文件"></a>11.4.4 使用查找替换修改另外5个文件</h5><p>例如：:%s/6379/6380 </p><h5 id="11-4-5-启动6个redis服务"><a href="#11-4-5-启动6个redis服务" class="headerlink" title="11.4.5 启动6个redis服务"></a>11.4.5 启动6个redis服务</h5><img src="/2022/09/05/redis-ji-chu-zhi-shi/39.jpg" class=""><h4 id="11-5-将六个节点合成一个集群"><a href="#11-5-将六个节点合成一个集群" class="headerlink" title="11.5 将六个节点合成一个集群"></a>11.5 将六个节点合成一个集群</h4><p>组合之前，请确保所有redis实例启动后，nodes-xxxx.conf文件都生成正常。</p> <img src="/2022/09/05/redis-ji-chu-zhi-shi/40.jpg" class=""><ul><li>合体：</li></ul><p>cd /opt/redis-6.2.1/src</p><pre class="language-none"><code class="language-none">redis-cli --cluster  create --cluster-replicas 1 192.168.11.101:6379 192.168.11.101:6380  192.168.11.101:6381 192.168.11.101:6389 192.168.11.101:6390  192.168.11.101:6391  </code></pre><p><strong>此处不要用127.0.0.1， 请用真实IP地址</strong></p><p><strong>–replicas 1 采用最简单的方式配置集群，一台主机，一台从机，正好三组。</strong></p> <img src="/2022/09/05/redis-ji-chu-zhi-shi/41.jpg" class=""> <img src="/2022/09/05/redis-ji-chu-zhi-shi/42.jpg" class=""><ul><li>普通方式登录</li></ul><p>可能直接进入读主机，存储数据时，会出现MOVED重定向操作。所以，应该以集群方式登录。</p><img src="/2022/09/05/redis-ji-chu-zhi-shi/43.jpg" class=""><h4 id="11-6-c采用集群策略连接，设置数据会自动切换到相应的写主机"><a href="#11-6-c采用集群策略连接，设置数据会自动切换到相应的写主机" class="headerlink" title="11.6 -c采用集群策略连接，设置数据会自动切换到相应的写主机"></a>11.6 -c采用集群策略连接，设置数据会自动切换到相应的写主机</h4><img src="/2022/09/05/redis-ji-chu-zhi-shi/44.jpg" class=""><h4 id="11-7-通过-cluster-nodes-命令查看集群信息"><a href="#11-7-通过-cluster-nodes-命令查看集群信息" class="headerlink" title="11.7 通过 cluster nodes 命令查看集群信息"></a>11.7 通过 cluster nodes 命令查看集群信息</h4> <img src="/2022/09/05/redis-ji-chu-zhi-shi/45.jpg" class=""><h4 id="11-8-redis-cluster如何分配这六个节点"><a href="#11-8-redis-cluster如何分配这六个节点" class="headerlink" title="11.8 redis cluster如何分配这六个节点?"></a>11.8 redis cluster如何分配这六个节点?</h4><p>一个集群至少要有三个主节点。</p><p>选项 –cluster-replicas 1 表示我们希望为集群中的每个主节点创建一个从节点。</p><p>分配原则尽量保证每个主数据库运行在不同的IP地址，每个从库和主库不在一个IP地址上。</p><h4 id="11-9-什么是slots"><a href="#11-9-什么是slots" class="headerlink" title="11.9 什么是slots"></a>11.9 什么是slots</h4><p><strong>[OK] All nodes agree about slots configuration.</strong></p><p><strong>&gt;&gt;&gt; Check for open slots…</strong></p><p><strong>&gt;&gt;&gt; Check slots coverage…</strong></p><p><strong>[OK] All 16384 slots covered.</strong></p><p>一个 Redis 集群包含 16384 个插槽（hash slot）， 数据库中的每个键都属于这 16384 个插槽的其中一个， </p><p>集群使用公式 CRC16(key) % 16384 来计算键 key 属于哪个槽， 其中 CRC16(key) 语句用于计算键 key 的 CRC16 校验和 。</p><p>集群中的每个节点负责处理一部分插槽。 举个例子， 如果一个集群可以有主节点， 其中：</p><p>节点 A 负责处理 0 号至 5460 号插槽。</p><p>节点 B 负责处理 5461 号至 10922 号插槽。</p><p>节点 C 负责处理 10923 号至 16383 号插槽。</p><h4 id="11-10-在集群中录入值"><a href="#11-10-在集群中录入值" class="headerlink" title="11.10 在集群中录入值"></a>11.10 在集群中录入值</h4><p>在redis-cli每次录入、查询键值，redis都会计算出该key应该送往的插槽，如果不是该客户端对应服务器的插槽，redis会报错，并告知应前往的redis实例地址和端口。</p><p>redis-cli客户端提供了 –c 参数实现自动重定向。</p><p>如 redis-cli -c –p 6379 登入后，再录入、查询键值对可以自动重定向。</p><p>不在一个slot下的键值，是<strong>不能使用mget,mset等多键操作</strong>。</p><img src="/2022/09/05/redis-ji-chu-zhi-shi/46.jpg" class=""><p>可以通过{}来定义组的概念，从而使key中{}内相同内容的键值对放到一个slot中去。</p><img src="/2022/09/05/redis-ji-chu-zhi-shi/47.jpg" class=""><h4 id="11-11-查询集群中的值"><a href="#11-11-查询集群中的值" class="headerlink" title="11.11 查询集群中的值"></a>11.11 查询集群中的值</h4><p>CLUSTER GETKEYSINSLOT <slot><count> 返回 count 个 slot 槽中的键。</count></slot></p><img src="/2022/09/05/redis-ji-chu-zhi-shi/48.jpg" class=""><h4 id="11-12-故障恢复"><a href="#11-12-故障恢复" class="headerlink" title="11.12 故障恢复"></a>11.12 故障恢复</h4><p>如果主节点下线？从节点能否自动升为主节点？注意：<strong>15秒超时</strong></p><img src="/2022/09/05/redis-ji-chu-zhi-shi/49.jpg" class=""><p>主节点恢复后，主从关系会如何？主节点回来变成从机。</p> <img src="/2022/09/05/redis-ji-chu-zhi-shi/50.jpg" class=""><p>如果所有某一段插槽的主从节点都宕掉，redis服务是否还能继续?</p><p>如果某一段插槽的主从都挂掉，而cluster-require-full-coverage 为yes ，那么 ，整个集群都挂掉</p><p>如果某一段插槽的主从都挂掉，而cluster-require-full-coverage 为no ，那么，该插槽数据全都不能使用，也无法存储。</p><p>redis.conf中的参数 cluster-require-full-coverage</p><h4 id="11-13-集群的Jedis开发"><a href="#11-13-集群的Jedis开发" class="headerlink" title="11.13 集群的Jedis开发"></a>11.13 集群的Jedis开发</h4><p>即使连接的不是主机，集群会自动切换主机存储。主机写，从机读。</p><p>无中心化主从集群。无论从哪台主机写的数据，其他主机上都能读到数据。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JedisClusterTest</span> <span class="token punctuation">{</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span>  <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">HostAndPort</span><span class="token punctuation">&gt;</span></span>set <span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">HostAndPort</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HostAndPort</span><span class="token punctuation">(</span><span class="token string">"192.168.31.211"</span><span class="token punctuation">,</span><span class="token number">6379</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token class-name">JedisCluster</span> jedisCluster<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">JedisCluster</span><span class="token punctuation">(</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span>jedisCluster<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"k1"</span><span class="token punctuation">,</span> <span class="token string">"v1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token class-name">System</span><span class="token punctuation">.</span>*out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>jedisCluster<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"k1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span>  </code></pre><h4 id="11-14-Redis集群提供了以下好处"><a href="#11-14-Redis集群提供了以下好处" class="headerlink" title="11.14 Redis集群提供了以下好处"></a>11.14 Redis集群提供了以下好处</h4><p>实现扩容</p><p>分摊压力</p><p>无中心配置相对简单</p><h4 id="11-15-Redis集群的不足"><a href="#11-15-Redis集群的不足" class="headerlink" title="11.15 Redis集群的不足"></a>11.15 Redis集群的不足</h4><p>多键操作是不被支持的 </p><p>多键的Redis事务是不被支持的。lua脚本不被支持</p><p>由于集群方案出现较晚，很多公司已经采用了其他的集群方案，而代理或者客户端分片的方案想要迁移至redis cluster，需要整体迁移而不是逐步过渡，复杂度较大。</p><h3 id="12-Redis应用问题解决"><a href="#12-Redis应用问题解决" class="headerlink" title="12. Redis应用问题解决"></a>12. Redis应用问题解决</h3><h4 id="12-1-缓存穿透"><a href="#12-1-缓存穿透" class="headerlink" title="12.1 缓存穿透"></a>12.1 缓存穿透</h4><h5 id="12-1-1-问题描述"><a href="#12-1-1-问题描述" class="headerlink" title="12.1.1 问题描述"></a>12.1.1 问题描述</h5><p>​key对应的数据在数据源并不存在，每次针对此key的请求从缓存获取不到，请求都会压到数据源，从而可能压垮数据源。比如用一个不存在的用户id获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。</p><img src="/2022/09/05/redis-ji-chu-zhi-shi/51.png" class=""><h5 id="12-1-2-解决方案"><a href="#12-1-2-解决方案" class="headerlink" title="12.1.2 解决方案"></a>12.1.2 解决方案</h5><p>​一个一定不存在缓存及查询不到的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。</p><p>解决方案：</p><p>（1）  <strong>对空值缓存：</strong>如果一个查询返回的数据为空（不管是数据是否不存在），我们仍然把这个空结果（null）进行缓存，设置空结果的过期时间会很短，最长不超过五分钟</p><p>（2）  <strong>设置可访问的名单（白名单）：</strong></p><p>使用bitmaps类型定义一个可以访问的名单，名单id作为bitmaps的偏移量，每次访问和bitmap里面的id进行比较，如果访问id不在bitmaps里面，进行拦截，不允许访问。</p><p>（3）  <strong>采用布隆过滤器</strong>：(布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量(位图)和一系列随机映射函数（哈希函数）。</p><p>布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。)</p><p>将所有可能存在的数据哈希到一个足够大的bitmaps中，一个一定不存在的数据会被 这个bitmaps拦截掉，从而避免了对底层存储系统的查询压力。</p><p><strong>（4）</strong>  <strong>进行实时监控：</strong>当发现Redis的命中率开始急速降低，需要排查访问对象和访问的数据，和运维人员配合，可以设置黑名单限制服务</p><h4 id="12-2-缓存击穿"><a href="#12-2-缓存击穿" class="headerlink" title="12.2 缓存击穿"></a>12.2 缓存击穿</h4><h5 id="12-2-1-问题描述"><a href="#12-2-1-问题描述" class="headerlink" title="12.2.1 问题描述"></a>12.2.1 问题描述</h5><p>​key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</p><img src="/2022/09/05/redis-ji-chu-zhi-shi/52.png" class=""><h5 id="12-2-2-解决方案"><a href="#12-2-2-解决方案" class="headerlink" title="12.2.2 解决方案"></a>12.2.2 解决方案</h5><p>​key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题。</p><p>解决问题：</p><p><strong>（1）预先设置热门数据：</strong>在redis高峰访问之前，把一些热门数据提前存入到redis里面，加大这些热门数据key的时长</p><p><strong>（2）实时调整：</strong>现场监控哪些数据热门，实时调整key的过期时长</p><p><strong>（3）使用锁：</strong></p><p>（1）  就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db。</p><p>（2）  先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX）去set一个mutex key</p><p>（3）  当操作返回成功时，再进行load db的操作，并回设缓存,最后删除mutex key；</p><p>（4）  当操作返回失败，证明有线程在load db，当前线程睡眠一段时间再重试整个get缓存的方法。</p><img src="/2022/09/05/redis-ji-chu-zhi-shi/53.png" class=""><h4 id="12-3-缓存雪崩"><a href="#12-3-缓存雪崩" class="headerlink" title="12.3 缓存雪崩"></a>12.3 缓存雪崩</h4><h5 id="12-3-1-问题描述"><a href="#12-3-1-问题描述" class="headerlink" title="12.3.1 问题描述"></a>12.3.1 问题描述</h5><p>​key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</p><p>缓存雪崩与缓存击穿的区别在于这里针对很多key缓存，前者则是某一个key</p><p>正常访问</p> <img src="/2022/09/05/redis-ji-chu-zhi-shi/54.png" class=""><p>缓存失效瞬间</p> <img src="/2022/09/05/redis-ji-chu-zhi-shi/55.png" class=""><h5 id="12-3-2-解决方案"><a href="#12-3-2-解决方案" class="headerlink" title="12.3.2 解决方案"></a>12.3.2 解决方案</h5><p>缓存失效时的雪崩效应对底层系统的冲击非常可怕！</p><p>解决方案：</p><p><strong>（1）</strong>  <strong>构建多级缓存架构：</strong>nginx缓存 + redis缓存 +其他缓存（ehcache等）</p><p><strong>（2）使用锁或队列：</strong></p><p>用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。不适用高并发情况</p><p><strong>（3）</strong>  <strong>设置过期标志更新缓存：</strong></p><p>记录缓存数据是否过期（设置提前量），如果过期会触发通知另外的线程在后台去更新实际key的缓存。</p><p><strong>（4）</strong>  <strong>将缓存失效时间分散开：</strong></p><p>比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p><h4 id="12-4-分布式锁"><a href="#12-4-分布式锁" class="headerlink" title="12.4 分布式锁"></a>12.4 分布式锁</h4><h5 id="11-4-1-问题描述"><a href="#11-4-1-问题描述" class="headerlink" title="11.4.1 问题描述"></a>11.4.1 问题描述</h5><p>​随着业务发展的需要，原单体单机部署的系统被演化成分布式集群系统后，由于分布式系统多线程、多进程并且分布在不同机器上，这将使原单机部署情况下的并发控制锁策略失效，单纯的Java API并不能提供分布式锁的能力。为了解决这个问题就需要一种跨JVM的互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题！</p><p>分布式锁主流的实现方案：</p><ol><li><p>基于数据库实现分布式锁</p></li><li><p>基于缓存（Redis等）</p></li><li><p>基于Zookeeper</p></li></ol><p>每一种分布式锁解决方案都有各自的优缺点：</p><ol><li><p>性能：redis最高</p></li><li><p>可靠性：zookeeper最高</p></li></ol><p>这里，我们就基于redis实现分布式锁。</p><h5 id="12-4-2-解决方案：使用redis实现分布式锁"><a href="#12-4-2-解决方案：使用redis实现分布式锁" class="headerlink" title="12.4.2 解决方案：使用redis实现分布式锁"></a>12.4.2 解决方案：使用redis实现分布式锁</h5><p>redis:命令</p><p># set sku:1:info “OK” NX PX 10000</p><p>EX second ：设置键的过期时间为 second 秒。 SET key value EX second 效果等同于 SETEX key second value 。</p><p>PX millisecond ：设置键的过期时间为 millisecond 毫秒。 SET key value PX millisecond 效果等同于 PSETEX key millisecond value 。</p><p>NX ：只在键不存在时，才对键进行设置操作。 SET key value NX 效果等同于 SETNX key value 。</p><p>XX ：只在键已经存在时，才对键进行设置操作。</p><img src="/2022/09/05/redis-ji-chu-zhi-shi/56.png" class=""><ol><li><p>多个客户端同时获取锁（setnx）</p></li><li><p>获取成功，执行业务逻辑{从db获取数据，放入缓存}，执行完成释放锁（del）</p></li><li><p>其他客户端等待重试</p></li></ol><h5 id="12-4-3-编写代码"><a href="#12-4-3-编写代码" class="headerlink" title="12.4.3 编写代码"></a>12.4.3 编写代码</h5><p>Redis: set num 0</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token operator">*</span><span class="token string">"testLock"</span><span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token operator">*</span><span class="token comment">//1获取锁，setne    </span><span class="token class-name">Boolean</span>  lock <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setIfAbsent</span><span class="token punctuation">(</span><span class="token string">"lock"</span><span class="token punctuation">,</span> <span class="token string">"111"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//2获取锁成功、查询num的值   </span><span class="token keyword">if</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">{</span>               <span class="token class-name">Object</span> value <span class="token operator">=</span> redisTemplate<span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"num"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//2.1判断num为空return      </span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                     <span class="token keyword">return</span><span class="token punctuation">;</span>               <span class="token punctuation">}</span>               <span class="token comment">//2.2有值就转成成int     </span>        <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>value<span class="token operator">+</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//2.3把redis的num加1       </span>        redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"num"</span><span class="token punctuation">,</span> <span class="token operator">++</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//2.4释放锁，del       </span>    redisTemplate<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token string">"lock"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>               <span class="token comment">//3获取锁失败、每隔0.1秒再获取 </span>        <span class="token keyword">try</span><span class="token punctuation">{</span>                     <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">testLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span>  <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>               e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>        <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  </code></pre><p>重启，服务集群，通过网关压力测试：</p><p>ab -n 1000 -c 100 <a href="http://192.168.140.1:8080/test/testLock">http://192.168.140.1:8080/test/testLock</a></p> <img src="/2022/09/05/redis-ji-chu-zhi-shi/57.png" class=""><p>查看redis中num的值：</p>  <img src="/2022/09/05/redis-ji-chu-zhi-shi/58.png" class=""><p>基本实现。</p><p>问题：setnx刚好获取到锁，业务逻辑出现异常，导致锁无法释放</p><p>解决：设置过期时间，自动释放锁。</p><h5 id="12-4-4-优化之设置锁的过期时间"><a href="#12-4-4-优化之设置锁的过期时间" class="headerlink" title="12.4.4 优化之设置锁的过期时间"></a>12.4.4 优化之设置锁的过期时间</h5><p>设置过期时间有两种方式：</p><ol><li><p>首先想到通过expire设置过期时间（缺乏原子性：如果在setnx和expire之间出现异常，锁也无法释放）</p></li><li><p>在set时指定过期时间（推荐）</p><img src="/2022/09/05/redis-ji-chu-zhi-shi/59.png" class=""></li></ol><p>设置过期时间：</p><p>​    <img src="/2022/09/05/redis-ji-chu-zhi-shi/60.png" class=""></p><p>压力测试肯定也没有问题。自行测试</p><p>问题：可能会释放其他服务器的锁。</p><p>场景：如果业务逻辑的执行时间是7s。执行流程如下</p><ol><li><p>index1业务逻辑没执行完，3秒后锁被自动释放。</p></li><li><p>index2获取到锁，执行业务逻辑，3秒后锁被自动释放。</p></li><li><p>index3获取到锁，执行业务逻辑</p></li><li><p>index1业务逻辑执行完成，开始调用del释放锁，这时释放的是index3的锁，导致index3的业务只执行1s就被别人释放。</p></li></ol><p>最终等于没锁的情况。</p><p>解决：setnx获取锁时，设置一个指定的唯一值（例如：uuid）；释放前获取这个值，判断是否自己的锁</p><h5 id="12-4-5-优化之UUID防误删"><a href="#12-4-5-优化之UUID防误删" class="headerlink" title="12.4.5 优化之UUID防误删"></a>12.4.5 优化之UUID防误删</h5> <img src="/2022/09/05/redis-ji-chu-zhi-shi/61.png" class=""> <img src="/2022/09/05/redis-ji-chu-zhi-shi/62.png" class=""><p>问题：删除操作缺乏原子性。</p><p>场景：</p><ol><li><p>index1执行删除时，查询到的lock值确实和uuid相等</p><p>​uuid=v1</p><p>​set(lock,uuid)；</p></li></ol>  <img src="/2022/09/05/redis-ji-chu-zhi-shi/63.png" class=""><ol start="2"><li><p>index1执行删除前，lock刚好过期时间已到，被redis自动释放</p><p>在redis中没有了lock，没有了锁。</p></li></ol> <img src="/2022/09/05/redis-ji-chu-zhi-shi/64.png" class=""><ol start="3"><li><p>index2获取了lock</p><p>​index2线程获取到了cpu的资源，开始执行方法</p><p>​uuid=v2</p><p>​set(lock,uuid)；</p></li><li><p>index1执行删除，此时会把index2的lock删除</p><p>​index1 因为已经在方法中了，所以不需要重新上锁。index1有执行的权限。index1已经比较完成了，这个时候，开始执行</p></li></ol>  <img src="/2022/09/05/redis-ji-chu-zhi-shi/65.png" class=""><p>​删除的index2的锁！</p><h5 id="12-4-6-优化之LUA脚本保证删除的原子性"><a href="#12-4-6-优化之LUA脚本保证删除的原子性" class="headerlink" title="12.4.6 优化之LUA脚本保证删除的原子性"></a>12.4.6 优化之LUA脚本保证删除的原子性</h5><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"testLockLua"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testLockLua</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//1 声明一个uuid ,将做为一个value 放入我们的key所对应的值中</span>    <span class="token class-name">String</span> uuid <span class="token operator">=</span> UUID<span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//2 定义一个锁：lua 脚本可以使用同一把锁，来实现删除！</span>    <span class="token class-name">String</span> skuId <span class="token operator">=</span> <span class="token string">"25"</span><span class="token punctuation">;</span> <span class="token comment">// 访问skuId 为25号的商品 100008348542</span>    <span class="token class-name">String</span> locKey <span class="token operator">=</span> <span class="token string">"lock:"</span> <span class="token operator">+</span> skuId<span class="token punctuation">;</span> <span class="token comment">// 锁住的是每个商品的数据</span>    <span class="token comment">// 3 获取锁</span>    <span class="token class-name">Boolean</span> lock <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setIfAbsent</span><span class="token punctuation">(</span>locKey<span class="token punctuation">,</span> uuid<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 第一种： lock 与过期时间中间不写任何的代码。</span>    <span class="token comment">// redisTemplate.expire("lock",10, TimeUnit.SECONDS);//设置过期时间</span>    <span class="token comment">// 如果true</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 执行的业务逻辑开始</span>        <span class="token comment">// 获取缓存中的num 数据</span>        <span class="token class-name">Object</span> value <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"num"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 如果是空直接返回</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 不是空 如果说在这出现了异常！ 那么delete 就删除失败！ 也就是说锁永远存在！</span>        <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>value <span class="token operator">+</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 使num 每次+1 放入缓存</span>        redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"num"</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token operator">++</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/*使用lua脚本来锁*/</span>        <span class="token comment">// 定义lua 脚本</span>        <span class="token class-name">String</span> script <span class="token operator">=</span> <span class="token string">"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end"</span><span class="token punctuation">;</span>        <span class="token comment">// 使用redis执行lua执行</span>        <span class="token class-name">DefaultRedisScript</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">&gt;</span></span> redisScript <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultRedisScript</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        redisScript<span class="token punctuation">.</span><span class="token function">setScriptText</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 设置一下返回值类型 为Long</span>        <span class="token comment">// 因为删除判断的时候，返回的0,给其封装为数据类型。如果不封装那么默认返回String 类型，</span>        <span class="token comment">// 那么返回字符串与0 会有发生错误。</span>        redisScript<span class="token punctuation">.</span><span class="token function">setResultType</span><span class="token punctuation">(</span><span class="token class-name">Long</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 第一个要是script 脚本 ，第二个需要判断的key，第三个就是key所对应的值。</span>        redisTemplate<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>redisScript<span class="token punctuation">,</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>locKey<span class="token punctuation">)</span><span class="token punctuation">,</span> uuid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment">// 其他线程等待</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment">// 睡眠</span>            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 睡醒了之后，调用方法。</span>            <span class="token function">testLockLua</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>Lua 脚本详解：</p>   <img src="/2022/09/05/redis-ji-chu-zhi-shi/66.png" class=""><p>项目中正确使用：</p><ol><li>定义key，key应该是为每个sku定义的，也就是每个sku有一把锁。</li></ol><p>String locKey =”lock:”+skuId; // 锁住的是每个商品的数据 </p><p>Boolean lock = redisTemplate.opsForValue().setIfAbsent(locKey, uuid,3,TimeUnit.SECONDS);</p>   <img src="/2022/09/05/redis-ji-chu-zhi-shi/67.png" class=""><h5 id="12-4-7-总结"><a href="#12-4-7-总结" class="headerlink" title="12.4.7 总结"></a>12.4.7 总结</h5><p>1、加锁</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// 1. 从redis中获取锁,set k1 v1 px 20000 nx</span><span class="token class-name">String</span> uuid <span class="token operator">=</span> UUID<span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Boolean</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">.</span><span class="token function">setIfAbsent</span><span class="token punctuation">(</span><span class="token string">"lock"</span><span class="token punctuation">,</span> uuid<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>2、使用lua释放锁</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// 2. 释放锁 del</span><span class="token class-name">String</span> script <span class="token operator">=</span> <span class="token string">"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end"</span><span class="token punctuation">;</span><span class="token comment">// 设置lua脚本返回的数据类型</span><span class="token class-name">DefaultRedisScript</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">&gt;</span></span> redisScript <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultRedisScript</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 设置lua脚本返回类型为Long</span>redisScript<span class="token punctuation">.</span><span class="token function">setResultType</span><span class="token punctuation">(</span><span class="token class-name">Long</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>redisScript<span class="token punctuation">.</span><span class="token function">setScriptText</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span><span class="token punctuation">;</span>redisTemplate<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>redisScript<span class="token punctuation">,</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"lock"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>uuid<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>3、重试</p><pre class="language-none"><code class="language-none">Thread.sleep(500);testLock();</code></pre><p> 为了确保分布式锁可用，我们至少要确保锁的实现同时<strong>满足以下四个条件</strong>：</p><p>- 互斥性。在任意时刻，只有一个客户端能持有锁。</p><p>- 不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。</p><p>- 解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。</p><p>- 加锁和解锁必须具有原子性。</p><h3 id="13-Redis6-0新功能"><a href="#13-Redis6-0新功能" class="headerlink" title="13. Redis6.0新功能"></a>13. Redis6.0新功能</h3><h4 id="13-1-ACL"><a href="#13-1-ACL" class="headerlink" title="13.1 ACL"></a>13.1 ACL</h4><h5 id="13-1-1-简介"><a href="#13-1-1-简介" class="headerlink" title="13.1.1 简介"></a>13.1.1 简介</h5><p>​Redis ACL是Access Control List（访问控制列表）的缩写，该功能允许根据可以执行的命令和可以访问的键来限制某些连接。</p><p>​在Redis 5版本之前，Redis 安全规则只有密码控制 还有通过rename 来调整高危命令比如 flushdb ， KEYS* ， shutdown 等。Redis 6 则提供ACL的功能对用户进行更细粒度的权限控制 ：</p><p>（1）接入权限:用户名和密码 </p><p>（2）可以执行的命令 </p><p>（3）可以操作的 KEY</p><p>参考官网：<a href="https://redis.io/topics/acl">https://redis.io/topics/acl</a></p><h5 id="13-1-2-命令"><a href="#13-1-2-命令" class="headerlink" title="13.1.2 命令"></a>13.1.2 命令</h5><p>1、使用acl list命令展现用户权限列表</p><p>（1）数据说明</p><img src="/2022/09/05/redis-ji-chu-zhi-shi/68.png" class=""><p>2、使用acl cat命令</p><p>（1）查看添加权限指令类别</p> <img src="/2022/09/05/redis-ji-chu-zhi-shi/69.png" class=""><p>（2）加参数类型名可以查看类型下具体命令</p><img src="/2022/09/05/redis-ji-chu-zhi-shi/70.png" class=""><p>3、使用acl whoami命令查看当前用户</p><p>4、使用aclsetuser命令创建和编辑用户ACL</p><p>（1）ACL规则</p><p>下面是有效ACL规则的列表。某些规则只是用于激活或删除标志，或对用户ACL执行给定更改的单个单词。其他规则是字符前缀，它们与命令或类别名称、键模式等连接在一起。</p><table><thead><tr><th>ACL规则</th><th></th><th></th></tr></thead><tbody><tr><td>类型</td><td>参数</td><td>说明</td></tr><tr><td>启动和禁用用户</td><td><strong>on</strong></td><td>激活某用户账号</td></tr><tr><td><strong>off</strong></td><td>禁用某用户账号。注意，已验证的连接仍然可以工作。如果默认用户被标记为off，则新连接将在未进行身份验证的情况下启动，并要求用户使用AUTH选项发送AUTH或HELLO，以便以某种方式进行身份验证。</td><td></td></tr><tr><td>权限的添加删除</td><td><strong>+<command></command></strong></td><td>将指令添加到用户可以调用的指令列表中</td></tr><tr><td><strong>-<command></command></strong></td><td>从用户可执行指令列表移除指令</td><td></td></tr><tr><td><strong>+@<category></category></strong></td><td>添加该类别中用户要调用的所有指令，有效类别为@admin、@set、@sortedset…等，通过调用ACL CAT命令查看完整列表。特殊类别@all表示所有命令，包括当前存在于服务器中的命令，以及将来将通过模块加载的命令。</td><td></td></tr><tr><td>-@<actegory></actegory></td><td>从用户可调用指令中移除类别</td><td></td></tr><tr><td><strong>allcommands</strong></td><td>+@all的别名</td><td></td></tr><tr><td><strong>nocommand</strong></td><td>-@all的别名</td><td></td></tr><tr><td>可操作键的添加或删除</td><td><strong>~<pattern></pattern></strong></td><td>添加可作为用户可操作的键的模式。例如~*允许所有的键</td></tr></tbody></table><p>（2）通过命令创建新用户默认权限</p><p>acl setuser user1</p> <img src="/2022/09/05/redis-ji-chu-zhi-shi/72.png" class=""><p>在上面的示例中，我根本没有指定任何规则。如果用户不存在，这将使用just created的默认属性来创建用户。如果用户已经存在，则上面的命令将不执行任何操作。</p><p>（3）设置有用户名、密码、ACL权限、并启用的用户</p><p>acl setuser user2 on &gt;password ~cached:* +get</p> <img src="/2022/09/05/redis-ji-chu-zhi-shi/73.png" class=""><p>(4)切换用户，验证权限</p> <img src="/2022/09/05/redis-ji-chu-zhi-shi/74.png" class=""><h4 id="13-2-IO多线程"><a href="#13-2-IO多线程" class="headerlink" title="13.2 IO多线程"></a>13.2 IO多线程</h4><h5 id="13-2-1-简介"><a href="#13-2-1-简介" class="headerlink" title="13.2.1 简介"></a>13.2.1 简介</h5><p>​Redis6终于支撑多线程了，告别单线程了吗？</p><p>​IO多线程其实指<strong>客户端交互部分</strong>的<strong>网络IO</strong>交互处理模块<strong>多线程</strong>，而非<strong>执行命令多线程</strong>。Redis6执行命令依然是单线程。</p><h5 id="13-2-2-原理架构"><a href="#13-2-2-原理架构" class="headerlink" title="13.2.2 原理架构"></a>13.2.2 原理架构</h5><p>​Redis 6 加入多线程,但跟 Memcached 这种从 IO处理到数据访问多线程的实现模式有些差异。Redis 的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程。之所以这么设计是不想因为多线程而变得复杂，需要去控制 key、lua、事务，LPUSH/LPOP 等等的并发问题。整体的设计大体如下:</p> <img src="/2022/09/05/redis-ji-chu-zhi-shi/75.png" class=""><p>另外，多线程IO默认也是不开启的，需要再配置文件中配置</p><p>io-threads-do-reads yes </p><p>io-threads 4</p><h4 id="13-3-工具支持Cluster"><a href="#13-3-工具支持Cluster" class="headerlink" title="13.3 工具支持Cluster"></a>13.3 工具支持Cluster</h4><p>​之前老版Redis想要搭集群需要单独安装ruby环境，Redis 5 将 redis-trib.rb 的功能集成到 redis-cli 。另外官方 redis-benchmark 工具开始支持 cluster 模式了，通过多线程的方式对多个分片进行压测。</p>  <img src="/2022/09/05/redis-ji-chu-zhi-shi/76.png" class=""><h4 id="13-4-Redis新功能持续关注"><a href="#13-4-Redis新功能持续关注" class="headerlink" title="13.4 Redis新功能持续关注"></a>13.4 Redis新功能持续关注</h4><p>Redis6新功能还有：</p><p>1、RESP3新的 Redis 通信协议：优化服务端与客户端之间通信</p><p>2、Client side caching客户端缓存：基于 RESP3 协议实现的客户端缓存功能。为了进一步提升缓存的性能，将客户端经常访问的数据cache到客户端。减少TCP网络交互。</p><p>3、Proxy集群代理模式：Proxy 功能，让 Cluster 拥有像单实例一样的接入方式，降低大家使用cluster的门槛。不过需要注意的是代理不改变 Cluster 的功能限制，不支持的命令还是不会支持，比如跨 slot 的多Key操作。</p><p>4、Modules API</p><p>Redis 6中模块API开发进展非常大，因为Redis Labs为了开发复杂的功能，从一开始就用上Redis模块。Redis可以变成一个框架，利用Modules来构建不同系统，而不需要从头开始写然后还要BSD许可。Redis一开始就是一个向编写各种系统开放的平台。</p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NoSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dialog预览URL文件</title>
      <link href="/2022/08/28/dialog-yu-lan-url-wen-jian/"/>
      <url>/2022/08/28/dialog-yu-lan-url-wen-jian/</url>
      
        <content type="html"><![CDATA[<div class="note success no-icon"><p>Android使用Dialog预览URL资源文件</p></div><h2 id="1-Dialog弹窗"><a href="#1-Dialog弹窗" class="headerlink" title="1. Dialog弹窗"></a>1. Dialog弹窗</h2><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">//R.style.ActionSheetDialogStyle为dialog效果样式</span><span class="token class-name">Dialog</span> dialog <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dialog</span><span class="token punctuation">(</span><span class="token class-name">MyUploadGwActivity</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token class-name">R</span><span class="token punctuation">.</span>style<span class="token punctuation">.</span>ActionSheetDialogStyle<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//填充对话框的布局</span><span class="token class-name">View</span> inflate <span class="token operator">=</span> <span class="token class-name">LayoutInflater</span><span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token class-name">MyUploadGwActivity</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">inflate</span><span class="token punctuation">(</span><span class="token class-name">R</span><span class="token punctuation">.</span>layout<span class="token punctuation">.</span>video_dialog<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//通过view绑定布局中的控件</span><span class="token class-name">WebView</span> webView <span class="token operator">=</span> inflate<span class="token punctuation">.</span><span class="token function">findViewById</span><span class="token punctuation">(</span><span class="token class-name">R</span><span class="token punctuation">.</span>id<span class="token punctuation">.</span>mv_webview<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//填充对话框的布局</span>dialog<span class="token punctuation">.</span><span class="token function">setContentView</span><span class="token punctuation">(</span>inflate<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取当前Activity所在的窗体</span><span class="token class-name">Window</span> dialogWindow <span class="token operator">=</span> dialog<span class="token punctuation">.</span><span class="token function">getWindow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//设置Dialog窗体弹出位置</span>dialogWindow<span class="token punctuation">.</span><span class="token function">setGravity</span><span class="token punctuation">(</span><span class="token class-name">Gravity</span><span class="token punctuation">.</span>CENTER<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获得窗体的属性</span><span class="token class-name">WindowManager<span class="token punctuation">.</span>LayoutParams</span> lp <span class="token operator">=</span> dialogWindow<span class="token punctuation">.</span><span class="token function">getAttributes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//设置dialog的宽度</span>lp<span class="token punctuation">.</span>width <span class="token operator">=</span> <span class="token class-name">WindowManager<span class="token punctuation">.</span>LayoutParams</span><span class="token punctuation">.</span>MATCH_PARENT<span class="token punctuation">;</span><span class="token comment">//获取屏幕的分辨率</span><span class="token class-name">DisplayMetrics</span> dm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DisplayMetrics</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>dialog<span class="token punctuation">.</span><span class="token function">getWindow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getWindowManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDefaultDisplay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMetrics</span><span class="token punctuation">(</span>dm<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//按屏幕高度比例设置dialog高度</span>lp<span class="token punctuation">.</span>height <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>dm<span class="token punctuation">.</span>heightPixels <span class="token operator">*</span> <span class="token number">0.7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>dialogWindow<span class="token punctuation">.</span><span class="token function">setAttributes</span><span class="token punctuation">(</span>lp<span class="token punctuation">)</span><span class="token punctuation">;</span>dialog<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//显示对话框</span></code></pre><h2 id="2-WebView显示网页内容"><a href="#2-WebView显示网页内容" class="headerlink" title="2. WebView显示网页内容"></a>2. WebView显示网页内容</h2><pre class="language-java" data-language="java"><code class="language-java"><span class="token number">1.</span>添加网络权限<span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 添加网络权限 <span class="token operator">--</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token keyword">uses</span><span class="token operator">-</span>permission android<span class="token operator">:</span>name<span class="token operator">=</span><span class="token string">"android.permission.INTERNET"</span> <span class="token operator">/</span><span class="token operator">&gt;</span>    <span class="token number">2.</span>在布局文件中添加<span class="token class-name">WebView</span>控件；<span class="token operator">&lt;</span><span class="token class-name">WebView</span>         android<span class="token operator">:</span>id<span class="token operator">=</span><span class="token string">"@+id/wv_webview"</span>         android<span class="token operator">:</span>layout_width<span class="token operator">=</span><span class="token string">"match_parent"</span>         android<span class="token operator">:</span>layout_height<span class="token operator">=</span><span class="token string">"match_parent"</span> <span class="token operator">/</span><span class="token operator">&gt;</span>             <span class="token number">3.</span>在代码中让<span class="token class-name">WebView</span>控件加载显示网页<span class="token comment">//获得控件</span><span class="token class-name">WebView</span> webView <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">WebView</span><span class="token punctuation">)</span> <span class="token function">findViewById</span><span class="token punctuation">(</span><span class="token class-name">R</span><span class="token punctuation">.</span>id<span class="token punctuation">.</span>wv_webview<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//访问网页</span>webView<span class="token punctuation">.</span><span class="token function">loadUrl</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//系统默认会通过手机浏览器打开网页，为了能够直接通过WebView显示网页，则必须设置</span>webView<span class="token punctuation">.</span><span class="token function">setWebViewClient</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">WebViewClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">shouldOverrideUrlLoading</span><span class="token punctuation">(</span><span class="token class-name">WebView</span> view<span class="token punctuation">,</span> <span class="token class-name">WebResourceRequest</span> url<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//返回true</span>       <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment">//开始加载资源监听</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onPageStarted</span><span class="token punctuation">(</span><span class="token class-name">WebView</span> view<span class="token punctuation">,</span> <span class="token class-name">String</span> url<span class="token punctuation">,</span> <span class="token class-name">Bitmap</span> favicon<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//可添加loading动画</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onPageStarted</span><span class="token punctuation">(</span>view<span class="token punctuation">,</span> url<span class="token punctuation">,</span> favicon<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//加载资源完成监听</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onPageFinished</span><span class="token punctuation">(</span><span class="token class-name">WebView</span> view<span class="token punctuation">,</span> <span class="token class-name">String</span> url<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment">//结束loading动画</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onPageFinished</span><span class="token punctuation">(</span>view<span class="token punctuation">,</span> url<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>WebView更多使用可参考：</strong><a href="https://blog.csdn.net/weixin_40438421/article/details/85700109">https://blog.csdn.net/weixin_40438421/article/details/85700109</a></p><h2 id="3-Webview设置缩放以及自适应"><a href="#3-Webview设置缩放以及自适应" class="headerlink" title="3. Webview设置缩放以及自适应"></a>3. Webview设置缩放以及自适应</h2><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">WebSettings</span> settings <span class="token operator">=</span> webView<span class="token punctuation">.</span><span class="token function">getSettings</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>settings<span class="token punctuation">.</span><span class="token function">setUseWideViewPort</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//设定支持 viewport</span>settings<span class="token punctuation">.</span><span class="token function">setLoadWithOverviewMode</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//自适应屏幕</span>settings<span class="token punctuation">.</span><span class="token function">setBuiltInZoomControls</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>settings<span class="token punctuation">.</span><span class="token function">setDisplayZoomControls</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>settings<span class="token punctuation">.</span><span class="token function">setSupportZoom</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//设定支持缩放</span></code></pre><h2 id="4-使用WPS预览office文件"><a href="#4-使用WPS预览office文件" class="headerlink" title="4. 使用WPS预览office文件"></a>4. 使用WPS预览office文件</h2><p>使用过程中发现android中的WebView不能直接预览office文档，因此采用本地软件WPS预览。</p><p><strong>简单使用：</strong></p><pre class="language-java" data-language="java"><code class="language-java">   <span class="token comment">/**     * 通过获取应用列表对比判断是否安装有某个应用     * @param context     * @param pkgName  （wps包名："cn.wps.moffice_eng"）     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">checkAppInstalled</span><span class="token punctuation">(</span><span class="token class-name">Context</span> context<span class="token punctuation">,</span> <span class="token class-name">String</span> pkgName<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pkgName<span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> pkgName<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">final</span> <span class="token class-name">PackageManager</span> packageManager <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getPackageManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">PackageInfo</span><span class="token punctuation">&gt;</span></span> info <span class="token operator">=</span> packageManager<span class="token punctuation">.</span><span class="token function">getInstalledPackages</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>info <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> info<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> info<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>pkgName<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>info<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span>packageName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token class-name">Intent</span> intent <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Intent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Bundle</span> bundle <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Bundle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>bundle<span class="token punctuation">.</span><span class="token function">putString</span><span class="token punctuation">(</span><span class="token string">"OpenMode"</span><span class="token punctuation">,</span> <span class="token string">"ReadOnly"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打开模式,只读模式</span>bundle<span class="token punctuation">.</span><span class="token function">putBoolean</span><span class="token punctuation">(</span><span class="token string">"SendCloseBroad"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 关闭时是否发送广播</span>bundle<span class="token punctuation">.</span><span class="token function">putString</span><span class="token punctuation">(</span><span class="token string">"ThirdPackage"</span><span class="token punctuation">,</span> <span class="token function">getPackageName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 第三方应用的包名，用于对改应用合法性的验证</span>bundle<span class="token punctuation">.</span><span class="token function">putBoolean</span><span class="token punctuation">(</span><span class="token string">"ClearTrace"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 清除打开记录</span>bundle<span class="token punctuation">.</span><span class="token function">putBoolean</span><span class="token punctuation">(</span><span class="token string">"ClearFile"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//关闭后删除打开文件</span>intent<span class="token punctuation">.</span><span class="token function">addFlags</span><span class="token punctuation">(</span><span class="token class-name">Intent</span><span class="token punctuation">.</span>FLAG_ACTIVITY_NEW_TASK<span class="token punctuation">)</span><span class="token punctuation">;</span>intent<span class="token punctuation">.</span><span class="token function">setAction</span><span class="token punctuation">(</span><span class="token class-name"><span class="token namespace">android<span class="token punctuation">.</span>content<span class="token punctuation">.</span></span>Intent</span><span class="token punctuation">.</span>ACTION_VIEW<span class="token punctuation">)</span><span class="token punctuation">;</span>intent<span class="token punctuation">.</span><span class="token function">setClassName</span><span class="token punctuation">(</span><span class="token string">"cn.wps.moffice_eng"</span><span class="token punctuation">,</span> <span class="token string">"cn.wps.moffice.documentmanager.PreStartActivity2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//包名和类名</span>intent<span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span><span class="token class-name">Uri</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//这里采用传入文档的在线地址进行打开，免除下载的步骤，也不需要判断安卓版本号</span>intent<span class="token punctuation">.</span><span class="token function">putExtras</span><span class="token punctuation">(</span>bundle<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token function">startActivity</span><span class="token punctuation">(</span>intent<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ActivityNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>更多使用可参考：</strong><a href="https://www.jianshu.com/p/3de8dc4df569">https://www.jianshu.com/p/3de8dc4df569</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用Git命令</title>
      <link href="/2022/08/26/chang-yong-git-ming-ling/"/>
      <url>/2022/08/26/chang-yong-git-ming-ling/</url>
      
        <content type="html"><![CDATA[<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config --global user.name <span class="token string">"用户名"</span>   <span class="token comment">#配置全局的git提交用户名</span><span class="token function">git</span> config --global user.email <span class="token string">"邮箱"</span>    <span class="token comment">#配置全局的git提交者的邮箱</span><span class="token function">git</span> clone 仓库地址<span class="token comment">#将远程仓库克隆到本地</span><span class="token function">git</span> <span class="token function">add</span> <span class="token builtin class-name">.</span><span class="token comment">#添加文件（控制所有文件）</span><span class="token function">git</span> <span class="token function">add</span> 文件名<span class="token comment">#控制单个文件</span><span class="token function">git</span> commit -m <span class="token string">'本次提交的说明'</span><span class="token comment">#提交文件</span><span class="token function">git</span> push<span class="token comment">#上传文件</span><span class="token function">git</span> branch  <span class="token comment">#查看分支</span><span class="token function">git</span> pull<span class="token comment">#合并更新</span><span class="token function">git</span> branch 分支名    <span class="token comment">#创建分支</span><span class="token function">git</span> checkout -b 分支名   <span class="token comment">#创建并切换到当前分支</span><span class="token comment">### 合并分支并提交到远程仓库</span><span class="token function">git</span> checkout master   <span class="token comment">#先切换到主分支</span><span class="token function">git</span> merge 分支名  <span class="token comment">#将分支合并到主分支</span><span class="token function">git</span> push <span class="token comment">#将本地代码推送到云端</span></code></pre><h2 id="速查表"><a href="#速查表" class="headerlink" title="速查表"></a>速查表</h2><img src="/2022/08/26/chang-yong-git-ming-ling/01.png" class="" title="Git命令速查表">]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux安装MySQL5.7</title>
      <link href="/2022/08/25/linux-an-zhuang-mysql5-7/"/>
      <url>/2022/08/25/linux-an-zhuang-mysql5-7/</url>
      
        <content type="html"><![CDATA[<h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><h3 id="查看是否已有老版本MySQL并卸载"><a href="#查看是否已有老版本MySQL并卸载" class="headerlink" title="查看是否已有老版本MySQL并卸载"></a>查看是否已有老版本MySQL并卸载</h3><pre class="language-bash" data-language="bash"><code class="language-bash">查看包名：rpm -qa<span class="token operator">|</span><span class="token function">grep</span> -i mysql删除命令：rpm -ev 文件名</code></pre><p>如果提示依赖包错误，则使用以下命令尝试：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">rpm</span> -ev 文件名 --nodeps</code></pre><p>查找之前老版本MySQL的目录并删除：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">find</span> / -name mysql <span class="token function">rm</span> -rf 目录名</code></pre><p><strong>注意：</strong>卸载后/etc/my.cnf不会删除，需要进行手工删除</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">rm</span> -rf /etc/my.cnf</code></pre><p>再次查找机器是否安装MySQL</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">rpm</span> -qa<span class="token operator">|</span><span class="token function">grep</span> -i mysql</code></pre><h3 id="安装MySQL5-7"><a href="#安装MySQL5-7" class="headerlink" title="安装MySQL5.7"></a>安装MySQL5.7</h3><p>下载地址：<a href="https://dev.mysql.com/downloads/mysql/5.7.html#downloads">https://dev.mysql.com/downloads/mysql/5.7.html#downloads</a></p><p>自己用的安装包：<a href="https://pan.baidu.com/s/1eLjtjBJ-v9CJ19U5CqzbHQ">https://pan.baidu.com/s/1eLjtjBJ-v9CJ19U5CqzbHQ</a></p><p><strong>提取码：ipel</strong></p><img src="/2022/08/25/linux-an-zhuang-mysql5-7/01.png" class=""><p>传输到Linux后解压：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">tar</span> -xvf mysql-5.7.30-linux-glibc2.12-x86_64.tar.gz</code></pre><img src="/2022/08/25/linux-an-zhuang-mysql5-7/02.png" class=""><p>移动到合适目录并重命名：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">mv</span> mysql-5.7.30-linux-glibc2.12-x86_64 /usr/local/mysql</code></pre><img src="/2022/08/25/linux-an-zhuang-mysql5-7/03.png" class=""><p>创建MySQL用户组合用户并修改权限：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">groupadd</span> mysql<span class="token function">useradd</span> -r -g mysql mysql</code></pre><p>创建数据目录并赋予权限：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> -p  /data/mysql              <span class="token comment">#创建目录</span><span class="token function">chown</span> mysql:mysql -R /data/mysql   <span class="token comment">#赋予权限</span></code></pre><img src="/2022/08/25/linux-an-zhuang-mysql5-7/04.png" class=""><p>配置my.cnf：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /etc/my.cnf</code></pre><p>内容如下：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>mysqld<span class="token punctuation">]</span>bind-address<span class="token operator">=</span><span class="token number">0.0</span>.0.0<span class="token assign-left variable">port</span><span class="token operator">=</span><span class="token number">3306</span><span class="token assign-left variable">user</span><span class="token operator">=</span>mysql<span class="token comment">#根据自己路径修改</span><span class="token assign-left variable">basedir</span><span class="token operator">=</span>/usr/local/mysql<span class="token comment">#根据自己路径修改</span><span class="token assign-left variable">datadir</span><span class="token operator">=</span>/data/mysql<span class="token assign-left variable">socket</span><span class="token operator">=</span>/tmp/mysql.socklog-error<span class="token operator">=</span>/data/mysql/mysql.errpid-file<span class="token operator">=</span>/data/mysql/mysql.pid<span class="token comment">#character config</span><span class="token assign-left variable">character_set_server</span><span class="token operator">=</span>utf8mb4symbolic-links<span class="token operator">=</span><span class="token number">0</span><span class="token assign-left variable">explicit_defaults_for_timestamp</span><span class="token operator">=</span>true</code></pre><p>初始化数据库：</p><pre class="language-bash" data-language="bash"><code class="language-bash">进入MySQL的bin目录：<span class="token builtin class-name">cd</span> /usr/local/mysql/bin/初始化：./mysqld --defaults-file<span class="token operator">=</span>/etc/my.cnf --basedir<span class="token operator">=</span>/usr/local/mysql/ --datadir<span class="token operator">=</span>/data/mysql/ --user<span class="token operator">=</span>mysql --initialize</code></pre><p>若出现：</p><p>./mysqld: error while loading shared libraries: libaio.so.1: cannot open shared object file: No such</p><p>查看密码：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> /data/mysql/mysql.err</code></pre><img src="/2022/08/25/linux-an-zhuang-mysql5-7/05.png" class=""><pre class="language-bash" data-language="bash"><code class="language-bash">先将mysql.server放置到/etc/init.d/mysql中：<span class="token function">cp</span> /usr/local/mysql/support-files/mysql.server /etc/init.d/mysql启动MySQL：<span class="token function">service</span> mysql start<span class="token function">ps</span> -ef<span class="token operator">|</span><span class="token function">grep</span> mysql</code></pre><p>如图显示，说明MySQL已经安装成功！</p><img src="/2022/08/25/linux-an-zhuang-mysql5-7/06.png" class=""><p>修改密码</p><pre class="language-bash" data-language="bash"><code class="language-bash">使用上面的随机密码登录MySQL后执行下面三步操作，重新登录SET PASSWORD <span class="token operator">=</span> PASSWORD<span class="token punctuation">(</span><span class="token string">'123456'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ALTER <span class="token environment constant">USER</span> <span class="token string">'root'</span>@<span class="token string">'localhost'</span> PASSWORD EXPIRE NEVER<span class="token punctuation">;</span>FLUSH PRIVILEGES</code></pre><img src="/2022/08/25/linux-an-zhuang-mysql5-7/07.png" class=""><p><strong>设置任意目录都能执行mysql -u root -p登录MySQL（可选）：</strong></p><p>1、进入/etc目录，编辑profile文件</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /etc<span class="token function">vi</span> profile</code></pre><p>2、在文件末尾修改PATH变量，如图：在PATH变量的加上脚本的路径（存在其他路径用冒号“:”隔开在末尾添加）</p><img src="/2022/08/25/linux-an-zhuang-mysql5-7/08.png" class=""><p>3、保存修改的profile文件，让修改立即生效，运行命令：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">source</span> /etc/profile</code></pre><p><strong>这时候仍无法使用远程连接，登录数据库执行下面三个命令</strong></p><pre class="language-bash" data-language="bash"><code class="language-bash">use mysql                                            <span class="token comment">#访问mysql库</span>update user <span class="token builtin class-name">set</span> <span class="token function">host</span> <span class="token operator">=</span> <span class="token string">'%'</span> where user <span class="token operator">=</span> <span class="token string">'root'</span><span class="token punctuation">;</span>      <span class="token comment">#使root能再任何host访问</span>FLUSH PRIVILEGES<span class="token punctuation">;</span>                                    <span class="token comment">#刷新</span></code></pre><img src="/2022/08/25/linux-an-zhuang-mysql5-7/09.png" class=""><p><strong>再次使用远程连接</strong></p><img src="/2022/08/25/linux-an-zhuang-mysql5-7/10.png" class=""><p><strong>连接成功！！！</strong></p><p><strong>MySQL5.7装好了，这是我卸载了其他版本的MySQL重装的过程，按这个流程应该能顺利安装</strong></p><p><strong>远程连接注意防火墙问题！！！</strong><a href="https://feiutech.blog.csdn.net/article/details/74502967?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-8.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-8.control">防火墙相关操作</a></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo常用命令</title>
      <link href="/2022/08/24/hexo-chang-yong-ming-ling/"/>
      <url>/2022/08/24/hexo-chang-yong-ming-ling/</url>
      
        <content type="html"><![CDATA[<h2 id="一、安装、升级"><a href="#一、安装、升级" class="headerlink" title="一、安装、升级"></a>一、安装、升级</h2><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo -g <span class="token comment">#安装  </span><span class="token function">npm</span> update hexo -g <span class="token comment">#升级  </span>hexo init <span class="token comment">#初始化</span></code></pre><h2 id="二、简写"><a href="#二、简写" class="headerlink" title="二、简写"></a>二、简写</h2><pre class="language-bash" data-language="bash"><code class="language-bash">hexo n <span class="token string">"我的博客"</span> <span class="token operator">==</span> hexo new <span class="token string">"我的博客"</span> <span class="token comment">#新建文章</span>hexo p <span class="token operator">==</span> hexo publishhexo g <span class="token operator">==</span> hexo generate<span class="token comment">#生成</span>hexo s <span class="token operator">==</span> hexo server <span class="token comment">#启动服务预览</span>hexo d <span class="token operator">==</span> hexo deploy<span class="token comment">#部署</span></code></pre><h2 id="三、服务器"><a href="#三、服务器" class="headerlink" title="三、服务器"></a>三、服务器</h2><pre class="language-bash" data-language="bash"><code class="language-bash">hexo server <span class="token comment">#Hexo 会监视文件变动并自动更新，您无须重启服务器。</span>hexo server -s <span class="token comment">#静态模式</span>hexo server -p <span class="token number">5000</span> <span class="token comment">#更改端口</span>hexo server -i <span class="token number">192.168</span>.1.1 <span class="token comment">#自定义 IP</span>hexo clean <span class="token comment">#清除缓存 网页正常情况下可以忽略此条命令</span>hexo g <span class="token comment">#生成静态网页</span>hexo d <span class="token comment">#开始部署</span></code></pre><h2 id="四、监视文件变动"><a href="#四、监视文件变动" class="headerlink" title="四、监视文件变动"></a>四、监视文件变动</h2><pre class="language-bash" data-language="bash"><code class="language-bash">hexo generate <span class="token comment">#使用 Hexo 生成静态文件快速而且简单</span>hexo generate --watch <span class="token comment">#监视文件变动</span></code></pre><h2 id="五、完成后部署"><a href="#五、完成后部署" class="headerlink" title="五、完成后部署"></a>五、完成后部署</h2><pre class="language-bash" data-language="bash"><code class="language-bash">两个命令作用相同hexo generate --deployhexo deploy --generatehexo deploy -ghexo server -g</code></pre><h2 id="六、草稿"><a href="#六、草稿" class="headerlink" title="六、草稿"></a>六、草稿</h2><pre class="language-bash" data-language="bash"><code class="language-bash">hexo publish <span class="token punctuation">[</span>layout<span class="token punctuation">]</span> <span class="token operator">&lt;</span>title<span class="token operator">&gt;</span></code></pre><h2 id="七、模板"><a href="#七、模板" class="headerlink" title="七、模板"></a>七、模板</h2><pre class="language-bash" data-language="bash"><code class="language-bash">hexo new <span class="token string">"postName"</span> <span class="token comment">#新建文章</span>hexo new page <span class="token string">"pageName"</span> <span class="token comment">#新建页面</span>hexo generate <span class="token comment">#生成静态页面至public目录</span>hexo server <span class="token comment">#开启预览访问端口（默认端口4000，'ctrl + c'关闭server）</span>hexo deploy <span class="token comment">#将.deploy目录部署到GitHub</span>hexo new <span class="token punctuation">[</span>layout<span class="token punctuation">]</span> <span class="token operator">&lt;</span>title<span class="token operator">&gt;</span>hexo new photo <span class="token string">"My Gallery"</span>hexo new <span class="token string">"Hello World"</span> --lang tw</code></pre><h2 id="八、推送到服务器上"><a href="#八、推送到服务器上" class="headerlink" title="八、推送到服务器上"></a>八、推送到服务器上</h2><pre class="language-bash" data-language="bash"><code class="language-bash">hexo n <span class="token comment">#写文章</span>hexo g <span class="token comment">#生成</span>hexo d <span class="token comment">#部署 #可与hexo g合并为 hexo d -g</span></code></pre><p>更全面详细的指令使用参考官网：<a href="https://hexo.io/zh-cn/docs/commands">指令 | Hexo</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/08/23/hello-world/"/>
      <url>/2022/08/23/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="language-bash" data-language="bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="language-bash" data-language="bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="language-bash" data-language="bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
